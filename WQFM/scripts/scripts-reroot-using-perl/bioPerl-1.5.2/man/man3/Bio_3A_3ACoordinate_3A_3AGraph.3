.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Coordinate::Graph 3"
.TH Bio::Coordinate::Graph 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Coordinate::Graph \- Finds shortest path between nodes in a graph
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 15
\&  # get a hash of hashes representing the graph. E.g.:
\&  my $hash= {
\&             '1' => {
\&                     '2' => 1
\&                    },
\&             '2' => {
\&                     '4' => 1,
\&                     '3' => 1
\&                    },
\&             '3' => undef,
\&             '4' => {
\&                     '5' => 1
\&                    },
\&             '5' => undef
\&            };
.Ve
.PP
.Vb 2
\&  # create the object;
\&  my $graph = Bio::Coordinate::Graph->new(-graph => $hash);
.Ve
.PP
.Vb 5
\&  # find the shortest path between two nodes
\&  my $a = 1;
\&  my $b = 6;
\&  my @path = $graph->shortest_paths($a);
\&  print join (", ", @path), "\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class calculates the shortest path between input and output
coordinate systems in a graph that defines the relationships between
them. This class is primarely designed to analyze gene-related
coordinate systems. See Bio::Coordinate::GeneMapper.
.PP
Note that this module can not be used to manage graphs.
.PP
Technically the graph implemented here is known as Directed Acyclic
Graph (\s-1DAG\s0). \s-1DAG\s0 is composed of vertices (nodes) and edges (with
optional weights) linking them. Nodes of the graph are the coordinate
systems in gene mapper.
.PP
The shortest path is found using the Dijkstra's algorithm. This
algorithm is fast and greedy and requires all weights to be
positive. All weights in the gene coordinate system graph are
currently equal (1) making the graph unweighted. That makes the use of
Dijkstra's algorithm an overkill. A impler and faster breadth-first
would be enough. Luckily the difference for small graphs is not
signigicant and the implementation is capable to take weights into
account if needed at some later time.
.Sh "Input format"
.IX Subsection "Input format"
The graph needs to be primed using a hash of hashes where there is a
key for each node. The second keys are the names of the downstream
neighboring nodes and values are the weights for reaching them. Here
is part of the gene coordiante system graph::
.PP
.Vb 18
\&    $hash = {
\&             '6' => undef,
\&             '3' => {
\&                     '6' => 1
\&                    },
\&             '2' => {
\&                     '6' => 1,
\&                     '4' => 1,
\&                     '3' => 1
\&                    },
\&             '1' => {
\&                     '2' => 1
\&                    },
\&             '4' => {
\&                     '5' => 1
\&                    },
\&             '5' => undef
\&            };
.Ve
.PP
Note that the names need to be positive integrers. Root should be '1'
and directness of the graph is taken advantage of to speed
calculations by assuming that downsream nodes always have larger
number as name.
.PP
An alternative (shorter) way of describing input is to use hash of
arrays. See Bio::Coordinate::Graph::hash_of_arrays.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to the
Bioperl mailing lists  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Heikki Lehvaslaiho"
.IX Header "AUTHOR - Heikki Lehvaslaiho"
Email:  heikki-at-bioperl-dot-org
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.Sh "Graph structure input methods"
.IX Subsection "Graph structure input methods"
.Sh "graph"
.IX Subsection "graph"
.Vb 6
\& Title   : graph
\& Usage   : $obj->graph($my_graph)
\& Function: Read/write method for the graph structure
\& Example : 
\& Returns : hash of hashes grah structure
\& Args    : reference to a hash of hashes
.Ve
.Sh "hash_of_arrays"
.IX Subsection "hash_of_arrays"
.Vb 6
\& Title   : hash_of_arrays
\& Usage   : $obj->hash_of_array(%hasharray)
\& Function: An alternative method to read in the graph structure.
\&           Hash arrays are easier to type. This method converts
\&           arrays into hashes and assigns equal values "1" to
\&           weights.
.Ve
.PP
.Vb 1
\& Example : Here is an example of simple structure containing a graph.
.Ve
.PP
.Vb 8
\&           my $DAG = {
\&                      6  => [],
\&                      5  => [],
\&                      4  => [5],
\&                      3  => [6],
\&                      2  => [3, 4, 6],
\&                      1  => [2]
\&                     };
.Ve
.PP
.Vb 2
\& Returns : hash of hashes graph structure
\& Args    : reference to a hash of arrays
.Ve
.Sh "Methods for determining the shortest path in the graph"
.IX Subsection "Methods for determining the shortest path in the graph"
.Sh "shortest_path"
.IX Subsection "shortest_path"
.Vb 10
\& Title   : shortest_path
\& Usage   : $obj->shortest_path($a, $b);
\& Function: Method for retrieving the shortest path between nodes.
\&           If the start node remains the same, the method is sometimes
\&           able to use cached results, otherwise it will recalculate
\&           the paths.
\& Example : 
\& Returns : array of node names, only the start node name if no path
\& Args    : name of the start node
\&         : name of the end node
.Ve
.Sh "dijkstra"
.IX Subsection "dijkstra"
.Vb 10
\& Title   : dijkstra
\& Usage   : $graph->dijkstra(1);
\& Function: Implements Dijkstra's algorithm.
\&           Returns or sets a list of mappers. The returned path
\&           description is always directed down from the root.
\&           Called from shortest_path().
\& Example : 
\& Returns : Reference to a hash of hashes representing a linked list
\&           which contains shortest path down to all nodes from the start
\&           node. E.g.:
.Ve
.PP
.Vb 10
\&            $res = {
\&                      '2' => {
\&                               'prev' => '1',
\&                               'dist' => 1
\&                             },
\&                      '1' => {
\&                               'prev' => undef,
\&                               'dist' => 0
\&                             },
\&                    };
.Ve
.PP
.Vb 1
\& Args    : name of the start node
.Ve
