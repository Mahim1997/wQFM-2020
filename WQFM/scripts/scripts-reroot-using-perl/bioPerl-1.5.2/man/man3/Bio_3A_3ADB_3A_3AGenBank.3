.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::GenBank 3"
.TH Bio::DB::GenBank 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::DB::GenBank \- Database object interface to GenBank
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Bio::DB::GenBank;
\&    $gb = new Bio::DB::GenBank;
.Ve
.PP
.Vb 1
\&    $seq = $gb->get_Seq_by_id('MUSIGHBA1'); # Unique ID
.Ve
.PP
.Vb 1
\&    # or ...
.Ve
.PP
.Vb 3
\&    $seq = $gb->get_Seq_by_acc('J00522'); # Accession Number
\&    $seq = $gb->get_Seq_by_version('J00522.1'); # Accession.version
\&    $seq = $gb->get_Seq_by_gi('405830'); # GI Number
.Ve
.PP
.Vb 6
\&    # get a stream via a query string
\&    my $query = Bio::DB::Query::GenBank->new
\&        (-query   =>'Oryza sativa[Organism] AND EST',
\&         -reldate => '30',
\&         -db      => 'nucleotide');
\&    my $seqio = $gb->get_Stream_by_query($query);
.Ve
.PP
.Vb 3
\&    while( my $seq =  $seqio->next_seq ) {
\&      print "seq length is ", $seq->length,"\en";
\&    }
.Ve
.PP
.Vb 2
\&    # or ... best when downloading very large files, prevents
\&    # keeping all of the file in memory
.Ve
.PP
.Vb 10
\&    # also don't want features, just sequence so let's save bandwith
\&    # and request Fasta sequence
\&    $gb = new Bio::DB::GenBank(-retrievaltype => 'tempfile' , 
\&                                              -format => 'Fasta');
\&    my $seqio = $gb->get_Stream_by_acc(['AC013798', 'AC021953'] );
\&    while( my $clone =  $seqio->next_seq ) {
\&      print "cloneid is ", $clone->display_id, " ", 
\&             $clone->accession_number, "\en";
\&    }
\&    # note that get_Stream_by_version is not implemented
.Ve
.PP
.Vb 7
\&    # don't want the entire sequence or more options
\&    my $gb = Bio::DB::GenBank->new(-format     => 'Fasta',
\&                                   -seq_start  => 100,
\&                                   -seq_stop   => 200,
\&                                   -strand     => 1,
\&                                   -complexity => 4));
\&    my $seqi = $gb->get_Stream_by_query($query);
.Ve
.PP
These alternate methods are described at
<http://www.ncbi.nlm.nih.gov/entrez/query/static/efetchseq_help.html>
.PP
\&\s-1NOTE:\s0 strand should be 1 for plus or 2 for minus.
.PP
Complexity: gi is often a part of a biological blob, containing other gis
.PP
complexity regulates the display:
0 \- get the whole blob
1 \- get the bioseq for gi of interest (default in Entrez)
2 \- get the minimal bioseq-set containing the gi of interest
3 \- get the minimal nuc-prot containing the gi of interest
4 \- get the minimal pub-set containing the gi of interest
.PP
\&'seq_start' and 'seq_stop' will not work when setting complexity to any value
other than 1.  'strand' works for any setting other than a complexity of 0
(whole glob); when you try this with a GenBank return format nothing happens,
whereas using \s-1FASTA\s0 works but causes display problems with the other sequences
in the glob.  As Tao Tao says from \s-1NCBI\s0, \*(L"Better left it out or set it to 1.\*(R"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Allows the dynamic retrieval of Bio::Seq sequence objects from the
GenBank database at \s-1NCBI\s0, via an Entrez query.
.PP
\&\s-1WARNING:\s0 Please do \fB\s-1NOT\s0\fR spam the Entrez web server with multiple
requests.  \s-1NCBI\s0 offers Batch Entrez for this purpose.
.PP
Note that when querying for GenBank accessions starting with '\s-1NT_\s0' you
will need to call \f(CW$gb\fR\->request_format('fasta') beforehand, because
in GenBank format (the default) the sequence part will be left out
(the reason is that \s-1NT\s0 contigs are rather annotation with references
to clones).
.PP
Some work has been done to automatically detect and retrieve whole \s-1NT_\s0
clones when the data is in that format (\s-1NCBI\s0 RefSeq clones).  More
testing and feedback from users is needed to achieve a good fit of
functionality and ease of use.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists. Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Aaron Mackey, Jason Stajich"
.IX Header "AUTHOR - Aaron Mackey, Jason Stajich"
Email amackey@virginia.edu
Email jason@bioperl.org
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the
object methods. Internal methods are usually
preceded with a _
.Sh "new"
.IX Subsection "new"
.Vb 5
\& Title   : new
\& Usage   : $gb = Bio::DB::GenBank->new(@options)
\& Function: Creates a new genbank handle
\& Returns : New genbank handle
\& Args    : -delay   number of seconds to delay between fetches (3s)
.Ve
.PP
\&\s-1NOTE:\s0  There are other options that are used internally.  By \s-1NCBI\s0 policy, this
module introduces a 3s delay between fetches.  If you are fetching multiple genbank
ids, it is a good idea to use get
.Sh "get_params"
.IX Subsection "get_params"
.Vb 6
\& Title   : get_params
\& Usage   : my %params = $self->get_params($mode)
\& Function: Returns key,value pairs to be passed to NCBI database
\&           for either 'batch' or 'single' sequence retrieval method
\& Returns : a key,value pair hash
\& Args    : 'single' or 'batch' mode for retrieval
.Ve
.SH "Routines Bio::DB::WebDBSeqI from Bio::DB::RandomAccessI"
.IX Header "Routines Bio::DB::WebDBSeqI from Bio::DB::RandomAccessI"
.Sh "get_Seq_by_id"
.IX Subsection "get_Seq_by_id"
.Vb 6
\& Title   : get_Seq_by_id
\& Usage   : $seq = $db->get_Seq_by_id('ROA1_HUMAN')
\& Function: Gets a Bio::Seq object by its name
\& Returns : a Bio::Seq object
\& Args    : the id (as a string) of a sequence
\& Throws  : "id does not exist" exception
.Ve
.Sh "get_Seq_by_acc"
.IX Subsection "get_Seq_by_acc"
.Vb 7
\&  Title   : get_Seq_by_acc
\&  Usage   : $seq = $db->get_Seq_by_acc($acc);
\&  Function: Gets a Seq object by accession numbers
\&  Returns : a Bio::Seq object
\&  Args    : the accession number as a string
\&  Note    : For GenBank, this just calls the same code for get_Seq_by_id()
\&  Throws  : "id does not exist" exception
.Ve
.Sh "get_Seq_by_gi"
.IX Subsection "get_Seq_by_gi"
.Vb 6
\& Title   : get_Seq_by_gi
\& Usage   : $seq = $db->get_Seq_by_gi('405830');
\& Function: Gets a Bio::Seq object by gi number
\& Returns : A Bio::Seq object
\& Args    : gi number (as a string)
\& Throws  : "gi does not exist" exception
.Ve
.Sh "get_Seq_by_version"
.IX Subsection "get_Seq_by_version"
.Vb 6
\& Title   : get_Seq_by_version
\& Usage   : $seq = $db->get_Seq_by_version('X77802.1');
\& Function: Gets a Bio::Seq object by sequence version
\& Returns : A Bio::Seq object
\& Args    : accession.version (as a string)
\& Throws  : "acc.version does not exist" exception
.Ve
.SH "Routines implemented by Bio::DB::NCBIHelper"
.IX Header "Routines implemented by Bio::DB::NCBIHelper"
.Sh "get_Stream_by_query"
.IX Subsection "get_Stream_by_query"
.Vb 11
\&  Title   : get_Stream_by_query
\&  Usage   : $seq = $db->get_Stream_by_query($query);
\&  Function: Retrieves Seq objects from Entrez 'en masse', rather than one
\&            at a time.  For large numbers of sequences, this is far superior
\&            than get_Stream_by_[id/acc]().
\&  Example :
\&  Returns : a Bio::SeqIO stream object
\&  Args    : $query :   An Entrez query string or a
\&            Bio::DB::Query::GenBank object.  It is suggested that you
\&            create a Bio::DB::Query::GenBank object and get the entry
\&            count before you fetch a potentially large stream.
.Ve
.Sh "get_Stream_by_id"
.IX Subsection "get_Stream_by_id"
.Vb 6
\&  Title   : get_Stream_by_id
\&  Usage   : $stream = $db->get_Stream_by_id( [$uid1, $uid2] );
\&  Function: Gets a series of Seq objects by unique identifiers
\&  Returns : a Bio::SeqIO stream object
\&  Args    : $ref : a reference to an array of unique identifiers for
\&                   the desired sequence entries
.Ve
.Sh "get_Stream_by_acc"
.IX Subsection "get_Stream_by_acc"
.Vb 7
\&  Title   : get_Stream_by_acc
\&  Usage   : $seq = $db->get_Stream_by_acc([$acc1, $acc2]);
\&  Function: Gets a series of Seq objects by accession numbers
\&  Returns : a Bio::SeqIO stream object
\&  Args    : $ref : a reference to an array of accession numbers for
\&                   the desired sequence entries
\&  Note    : For GenBank, this just calls the same code for get_Stream_by_id()
.Ve
.Sh "get_Stream_by_gi"
.IX Subsection "get_Stream_by_gi"
.Vb 7
\&  Title   : get_Stream_by_gi
\&  Usage   : $seq = $db->get_Seq_by_gi([$gi1, $gi2]);
\&  Function: Gets a series of Seq objects by gi numbers
\&  Returns : a Bio::SeqIO stream object
\&  Args    : $ref : a reference to an array of gi numbers for
\&                   the desired sequence entries
\&  Note    : For GenBank, this just calls the same code for get_Stream_by_id()
.Ve
.Sh "get_Stream_by_batch"
.IX Subsection "get_Stream_by_batch"
.Vb 8
\&  Title   : get_Stream_by_batch
\&  Usage   : $seq = $db->get_Stream_by_batch($ref);
\&  Function: Retrieves Seq objects from Entrez 'en masse', rather than one
\&            at a time.
\&  Example :
\&  Returns : a Bio::SeqIO stream object
\&  Args    : $ref : either an array reference, a filename, or a filehandle
\&            from which to get the list of unique ids/accession numbers.
.Ve
.PP
\&\s-1NOTE:\s0 This method is redundant and deprecated.  Use \fIget_Stream_by_id()\fR
instead.
.Sh "get_request"
.IX Subsection "get_request"
.Vb 5
\& Title   : get_request
\& Usage   : my $url = $self->get_request
\& Function: HTTP::Request
\& Returns : 
\& Args    : %qualifiers = a hash of qualifiers (ids, format, etc)
.Ve
.Sh "default_format"
.IX Subsection "default_format"
.Vb 5
\& Title   : default_format
\& Usage   : my $format = $self->default_format
\& Function: Returns default sequence format for this module
\& Returns : string
\& Args    : none
.Ve
