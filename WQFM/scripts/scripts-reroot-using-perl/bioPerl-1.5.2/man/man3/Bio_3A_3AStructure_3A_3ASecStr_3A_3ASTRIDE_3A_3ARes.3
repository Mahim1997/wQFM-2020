.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Structure::SecStr::STRIDE::Res 3"
.TH Bio::Structure::SecStr::STRIDE::Res 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Structure::SecStr::STRIDE::Res \- Module for parsing/accessing stride output
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& my $stride_obj = new Bio::Structure::SecStr::STRIDE::Res( '-file' => 'filename.stride' );
.Ve
.PP
.Vb 1
\& # or
.Ve
.PP
.Vb 1
\& my $stride_obj = new Bio::Structure::SecStr::STRIDE::Res( '-fh' => \e*STDOUT );
.Ve
.PP
.Vb 2
\& # Get secondary structure assignment for PDB residue 20 of chain A
\& $sec_str = $stride_obj->resSecStr( '20:A' );
.Ve
.PP
.Vb 2
\& # same
\& $sec_str = $stride_obj->resSecStr( 20, 'A' )
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
STRIDE::Res is a module for objectifying \s-1STRIDE\s0 output.  \s-1STRIDE\s0 is a
program (similar to \s-1DSSP\s0) for assigning secondary structure to
individual residues of a pdb structure file.
.PP
.Vb 2
\&    ( Knowledge-Based Protein Secondary Structure Assignment,
\&    PROTEINS: Structure, Function, and Genetics 23:566-579 (1995) )
.Ve
.PP
\&\s-1STRIDE\s0 is available here:
http://www.embl\-heidelberg.de/argos/stride/down_stride.html
.PP
Methods are then available for extracting all of the infomation
present within the output or convenient subsets of it.
.PP
Although they are very similar in function, \s-1DSSP\s0 and \s-1STRIDE\s0 differ
somewhat in output format.  Thes differences are reflected in the
return value of some methods of these modules.  For example, both
the \s-1STRIDE\s0 and \s-1DSSP\s0 parsers have \fIresSecStr()\fR methods for returning
the secondary structure of a given residue.  However, the range of
return values for \s-1DSSP\s0 is ( H, B, E, G, I, T, and S ) whereas the
range of values for \s-1STRIDE\s0 is ( H, G, I, E, B, b, T, and C ).  See
individual methods for details.
.PP
The methods are roughly divided into 3 sections:
.PP
.Vb 12
\&  1.  Global features of this structure (PDB ID, total surface area,
\&      etc.).  These methods do not require an argument. 
\&  2.  Residue specific features ( amino acid, secondary structure,
\&      solvent exposed surface area, etc. ).  These methods do require an
\&      arguement.  The argument is supposed to uniquely identify a
\&      residue described within the structure.  It can be of any of the
\&      following forms:
\&      ('#A:B') or ( #, 'A', 'B' )
\&        || |
\&        || - Chain ID (blank for single chain)
\&        |--- Insertion code for this residue.  Blank for most residues.
\&        |--- Numeric portion of residue ID.
.Ve
.PP
.Vb 5
\&      (#)
\&       |
\&       --- Numeric portion of residue ID.  If there is only one chain and
\&           it has no ID AND there is no residue with an insertion code at this
\&           number, then this can uniquely specify a residue.
.Ve
.PP
.Vb 4
\&      ('#:C') or ( #, 'C' )
\&        | |
\&        | -Chain ID
\&        ---Numeric portion of residue ID.
.Ve
.PP
.Vb 4
\&     If a residue is incompletely specified then the first residue that
\&     fits the arguments is returned.  For example, if 19 is the argument
\&     and there are three chains, A, B, and C with a residue whose number
\&     is 19, then 19:A will be returned (assuming its listed first).
.Ve
.PP
.Vb 2
\&     Since neither DSSP nor STRIDE correctly handle alt-loc codes, they
\&     are not supported by these modules.
.Ve
.PP
.Vb 2
\& 3.  Value-added methods.  Return values are not verbatem strings
\&     parsed from DSSP or STRIDE output.
.Ve
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "MailingLists"
.IX Subsection "MailingLists"
UsUser feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Ed Green"
.IX Header "AUTHOR - Ed Green"
Email ed@compbio.berkeley.edu
.SH "APPENDIX"
.IX Header "APPENDIX"
The Rest of the documentation details each method.
Internal methods are preceded with a _.
.Sh "new"
.IX Subsection "new"
.Vb 8
\& Title         : new
\& Usage         : makes new object of this class
\& Function      : Constructor
\& Example       : $stride_obj = Bio::Structure::SecStr::STRIDE:Res->new( '-file' =>  filename 
\&                                                     # or 
\&                                                     '-fh'   => FILEHANDLE )
\& Returns       : object (ref)
\& Args          : filename or filehandle( must be proper STRIDE output )
.Ve
.Sh "totSurfArea"
.IX Subsection "totSurfArea"
.Vb 7
\& Title         : totSurfArea
\& Usage         : returns sum of surface areas of all residues of all
\&                 chains considered.  Result is memoized.
\& Function      :
\& Example       : $tot_SA = $stride_obj->totSurfArea();
\& Returns       : scalar
\& Args          : none
.Ve
.Sh "numResidues"
.IX Subsection "numResidues"
.Vb 7
\& Title         : numResidues
\& Usage         : returns total number of residues in all chains or
\&                 just the specified chain
\& Function      : 
\& Example       : $tot_res = $stride_obj->numResidues();
\& Returns       : scalar int
\& Args          : none or chain id
.Ve
.Sh "pdbID"
.IX Subsection "pdbID"
.Vb 6
\& Title         : pdbID
\& Usage         : returns pdb identifier ( 1FJM, e.g. )
\& Function      : 
\& Example       : $pdb_id = $stride_obj->pdbID();
\& Returns       : scalar string
\& Args          : none
.Ve
.Sh "pdbCompound"
.IX Subsection "pdbCompound"
.Vb 7
\& Title         : pdbCompound
\& Usage         : returns string of what was found on the  
\&                 CMP lines
\& Function      : 
\& Example       : $cmp = $stride_obj->pdbCompound();
\& Returns       : string
\& Args          : none
.Ve
.Sh "pdbDate"
.IX Subsection "pdbDate"
.Vb 6
\& Title         : pdbDate
\& Usage         : returns date given in PDB file
\& Function      :
\& Example       : $pdb_date = $stride_obj->pdbDate();
\& Returns       : scalar
\& Args          : none
.Ve
.Sh "pdbHeader"
.IX Subsection "pdbHeader"
.Vb 6
\& Title         : pdbHeader
\& Usage         : returns string of characters found on the PDB header line
\& Function      :
\& Example       : $head = $stride_obj->pdbHeader();
\& Returns       : scalar
\& Args          : none
.Ve
.Sh "pdbSource"
.IX Subsection "pdbSource"
.Vb 6
\& Title         : pdbSource
\& Usage         : returns string of what was found on SRC lines
\& Function      : 
\& Example       : $src = $stride_obj->pdbSource();
\& Returns       : scalar
\& Args          : none
.Ve
.Sh "resAA"
.IX Subsection "resAA"
.Vb 7
\& Title         : resAA
\& Usage         : returns 1 letter abbr. of the amino acid specified by
\&                 the arguments
\& Function      : 
\& Examples      : $aa = $stride_obj->resAA( RESIDUE_ID );
\& Returns       : scalar character
\& Args          : RESIDUE_ID
.Ve
.Sh "resPhi"
.IX Subsection "resPhi"
.Vb 6
\& Title         : resPhi
\& Usage         : returns phi angle of specified residue
\& Function      :
\& Example       : $phi = $stride_obj->resPhi( RESIDUE_ID );
\& Returns       : scaler
\& Args          : RESIDUE_ID
.Ve
.Sh "resPsi"
.IX Subsection "resPsi"
.Vb 6
\& Title         : resPsi
\& Usage         : returns psi angle of specified residue
\& Function      :
\& Example       : $psi = $stride_obj->resPsi( RESIDUE_ID );
\& Returns       : scalar
\& Args          : RESIDUE_ID
.Ve
.Sh "resSolvAcc"
.IX Subsection "resSolvAcc"
.Vb 6
\& Title         : resSolvAcc
\& Usage         : returns stride calculated surface area of specified residue
\& Function      : 
\& Example       : $sa = $stride_obj->resSolvAcc( RESIDUE_ID );
\& Returns       : scalar
\& Args          : RESIDUE_ID
.Ve
.Sh "resSurfArea"
.IX Subsection "resSurfArea"
.Vb 6
\& Title         : resSurfArea
\& Usage         : returns stride calculated surface area of specified residue
\& Function      : 
\& Example       : $sa = $stride_obj->resSurfArea( RESIDUE_ID );
\& Returns       : scalar
\& Args          : RESIDUE_ID
.Ve
.Sh "resSecStr"
.IX Subsection "resSecStr"
.Vb 16
\& Title         : resSecStr 
\& Usage         : gives one letter abbr. of stride determined secondary
\&                 structure of specified residue
\& Function      : 
\& Example       : $ss = $stride_obj->resSecStr( RESIDUE_ID );
\& Returns       : one of: 'H' => Alpha Helix
\&                         'G' => 3-10 helix
\&                         'I' => PI-helix
\&                         'E' => Extended conformation
\&                         'B' or 'b' => Isolated bridge
\&                         'T' => Turn
\&                         'C' => Coil
\&                         ' ' => None
\&                # NOTE:  This range is slightly DIFFERENT from the
\&                #        DSSP method of the same name
\& Args          : RESIDUE_ID
.Ve
.Sh "resSecStrSum"
.IX Subsection "resSecStrSum"
.Vb 7
\& Title         : resSecStrSum
\& Usage         : gives one letter summary of secondary structure of
\&                 specified residue.  More general than secStruc() 
\& Function      :
\& Example       : $ss_sum = $stride_obj->resSecStrSum( RESIDUE_ID );
\& Returns       : one of: 'H' (helix), 'B' (beta), 'T' (turn), or 'C' (coil)
\& Args          : residue identifier(s) ( SEE INTRO NOTE )
.Ve
.Sh "resSecStrName"
.IX Subsection "resSecStrName"
.Vb 7
\& Title         : resSecStrName
\& Usage         : gives full name of the secondary structural element
\&                 classification of the specified residue
\& Function      : 
\& Example       : $ss_name = $stride_obj->resSecStrName( RESIDUE_ID );
\& Returns       : scalar string
\& Args          : RESIDUE_ID
.Ve
.Sh "strideLocs"
.IX Subsection "strideLocs"
.Vb 13
\& Title         : strideLocs
\& Usage         : returns stride determined contiguous secondary
\&    structural elements as specified on the LOC lines
\& Function      : 
\& Example       : $loc_pnt = $stride_obj->strideLocs();
\& Returns       : pointer to array of 5 element arrays.
\&    0 => stride name of structural element
\&    1 => first residue pdb key (including insertion code, if app.)
\&    2 => first residue chain id
\&    3 => last residue pdb key (including insertion code, if app.)
\&    4 => last residue chain id
\&    NOTE the differences between this range and the range of SecBounds()
\& Args          : none
.Ve
.Sh "secBounds"
.IX Subsection "secBounds"
.Vb 11
\& Title         : secBounds
\& Usage         : gets residue ids of boundary residues in each
\&                 contiguous secondary structural element of specified
\&                 chain 
\& Function      : 
\& Example       : $ss_bound_pnt = $stride_obj->secBounds( 'A' );
\& Returns       : pointer to array of 3 element arrays.  First two elements
\&                 are the PDB IDs of the start and end points, respectively
\&                 and inclusively.  The last element is the STRIDE secondary
\&                 structural element code (same range as resSecStr).
\& Args          : chain identifier ( one character ).  If none, '-' is assumed
.Ve
.Sh "chains"
.IX Subsection "chains"
.Vb 6
\& Title         : chains
\& Usage         : gives array chain I.D.s (characters)
\& Function      :
\& Example       : @chains = $stride_obj->chains();
\& Returns       : array of characters
\& Args          : none
.Ve
.Sh "getSeq"
.IX Subsection "getSeq"
.Vb 20
\& Title         : getSeq
\& Usage         : returns a Bio::PrimarySeq object which represents an
\&                 approximation at the sequence of the specified chain.
\& Function      : For most chain of most entries, the sequence returned by
\&                 this method will be very good.  However, it it inherently 
\&                 unsafe to rely on STRIDE to extract sequence information about
\&                 a PDB entry.  More reliable information can be obtained from
\&                 the PDB entry itself.  If a second option is given
\&                 (and evaluates to true), the sequence generated will
\&                 have 'X' in spaces where the pdb residue numbers are
\&                 discontinuous.  In some cases this results in a
\&                 better sequence object (when the  discontinuity is
\&                 due to regions which were present, but could not be
\&                 resolved).  In other cases, it will result in a WORSE
\&                 sequence object (when the discontinuity is due to
\&                 historical sequence numbering and all sequence is
\&                 actually resolved).
\& Example       : $pso = $dssp_obj->getSeq( 'A' );
\& Returns       : (pointer to) a PrimarySeq object
\& Args          : Chain identifier.  If none given, '-' is assumed.
.Ve
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
.Sh "_pdbNum"
.IX Subsection "_pdbNum"
.Vb 9
\& Title        : _pdbNum
\& Usage        : fetches the numeric portion of the identifier for a given
\&                residue as reported by the pdb entry.  Note, this DOES NOT
\&                uniquely specify a residue.  There may be an insertion code
\&                and/or chain identifier differences.
\& Function     : 
\& Example      : $pdbNum = $self->pdbNum( 3, 'A' );
\& Returns      : a scalar
\& Args         : valid ordinal num / chain combination
.Ve
.Sh "_resAA"
.IX Subsection "_resAA"
.Vb 7
\& Title         : _resAA
\& Usage         : returns 1 letter abbr. of the amino acid specified by
\&                 the arguments
\& Function      : 
\& Examples      : $aa = $stride_obj->_resAA( 3, '-' );
\& Returns       : scalar character
\& Args          : ( ord. num, chain )
.Ve
.Sh "_pdbInsCo"
.IX Subsection "_pdbInsCo"
.Vb 6
\& Title        : _pdbInsCo
\& Usage        : fetches the Insertion code for this residue.
\& Function     : 
\& Example      : $pdb_ins_co = $self->_pdb_ins_co( 15, 'B' );
\& Returns      : a scalar
\& Args         : ordinal number and chain
.Ve
.Sh "_toOrdChain"
.IX Subsection "_toOrdChain"
.Vb 10
\& Title         : _toOrdChain
\& Usage         : takes any set of residue identifying parameters and
\&    wrestles them into a two element array:  the chain and the ordinal
\&    number of this residue.  This two element array can then be
\&    efficiently used as keys in many of the above accessor methods
\& ('#A:B') or ( #, 'A', 'B' )
\&   || |
\&   || - Chain ID (blank for single chain)
\&   |--- Insertion code for this residue.  Blank for most residues.
\&   |--- Numeric portion of residue ID.
.Ve
.PP
.Vb 5
\&  (#)
\&   |
\&   --- Numeric portion of residue ID.  If there is only one chain and
\&   it has no ID AND there is no residue with an insertion code at this
\&   number, then this can uniquely specify a residue.
.Ve
.PP
.Vb 4
\&  #  ('#:C) or ( #, 'C' )
\&       | |
\&       | -Chain ID
\&       ---Numeric portion of residue ID.
.Ve
.PP
.Vb 4
\&  If a residue is incompletely specified then the first residue that 
\&  fits the arguments is returned.  For example, if 19 is the argument 
\&  and there are three chains, A, B, and C with a residue whose number 
\&  is 19, then 19:A will be returned (assuming its listed first).
.Ve
.PP
.Vb 4
\& Function      :
\& Example       : my ( $ord, $chain ) = $self->_toOrdChain( @args );
\& Returns       : two element array
\& Args          : valid set of residue identifier(s) ( SEE NOTE ABOVE )
.Ve
.Sh "_parse"
.IX Subsection "_parse"
.Vb 6
\& Title         : _parse
\& Usage         : as name suggests, parses stride output, creating object
\& Function      :
\& Example       : $self->_parse( $io );
\& Returns       : 
\& Args          : valid Bio::Root::IO object
.Ve
.Sh "_parseTop"
.IX Subsection "_parseTop"
.Vb 6
\& Title         : _parseTop
\& Usage         : makes sure this looks like stride output
\& Function      :
\& Example       : 
\& Returns       :
\& Args          :
.Ve
.Sh "_parseHead"
.IX Subsection "_parseHead"
.Vb 6
\& Title         : _parseHead
\& Usage         : parses
\& Function      : HDR, CMP, SRC, and AUT lines
\& Example       :
\& Returns       :
\& Args          :
.Ve
.Sh "_parseSummary"
.IX Subsection "_parseSummary"
.Vb 6
\& Title         : _parseSummary
\& Usage         : parses LOC lines
\& Function      :
\& Example       :
\& Returns       :
\& Args          :
.Ve
.Sh "_parseASG"
.IX Subsection "_parseASG"
.Vb 6
\& Title         : _parseASG
\& Usage         : parses ASG lines
\& Function      :
\& Example       :
\& Returns       :
\& Args          :
.Ve
