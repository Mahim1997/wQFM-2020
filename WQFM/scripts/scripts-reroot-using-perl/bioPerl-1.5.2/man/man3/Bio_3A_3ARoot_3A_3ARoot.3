.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Root::Root 3"
.TH Bio::Root::Root 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Root::Root \- Hash\-based implementation of Bio::Root::RootI
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # Any Bioperl-compliant object is a RootI compliant object
.Ve
.PP
.Vb 1
\&  # Here's how to throw and catch an exception using the eval-based syntax.
.Ve
.PP
.Vb 1
\&  $obj->throw("This is an exception");
.Ve
.PP
.Vb 3
\&  eval {
\&      $obj->throw("This is catching an exception");
\&  };
.Ve
.PP
.Vb 5
\&  if( $@ ) {
\&      print "Caught exception";
\&  } else {
\&      print "no exception";
\&  }
.Ve
.PP
.Vb 1
\&  # Alternatively, using the new typed exception syntax in the throw() call:
.Ve
.PP
.Vb 3
\&  $obj->throw( -class => 'Bio::Root::BadParameter',
\&               -text  => "Can not open file $file",
\&               -value  => $file );
.Ve
.PP
.Vb 1
\&  # Want to see debug() outputs for this object
.Ve
.PP
.Vb 1
\&  my $obj = Bio::Object->new(-verbose=>1);
.Ve
.PP
.Vb 2
\&  my $obj = Bio::Object->new(%args);
\&  $obj->verbose(2);
.Ve
.PP
.Vb 1
\&  # Print debug messages which honour current verbosity setting
.Ve
.PP
.Vb 1
\&  $obj->debug("Boring output only to be seen if verbose > 0\en");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a hashref-based implementation of the Bio::Root::RootI
interface.  Most Bioperl objects should inherit from this.
.PP
See the documentation for Bio::Root::RootI for most of the methods
implemented by this module.  Only overridden methods are described
here.
.Sh "Throwing Exceptions"
.IX Subsection "Throwing Exceptions"
One of the functionalities that Bio::Root::RootI provides is the
ability to \fIthrow()\fR exceptions with pretty stack traces. Bio::Root::Root
enhances this with the ability to use Error (available from \s-1CPAN\s0)
if it has also been installed. 
.PP
If Error has been installed, \fIthrow()\fR will use it. This causes an
Error.pm\-derived object to be thrown. This can be caught within a
\&\f(CW\*(C`catch{}\*(C'\fR block, from wich you can extract useful bits of
information. If Error is not installed, it will use the 
Bio::Root::RootI\-based exception throwing facilty.
.Sh "Typed Exception Syntax"
.IX Subsection "Typed Exception Syntax"
The typed exception syntax of \fIthrow()\fR has the advantage of plainly
indicating the nature of the trouble, since the name of the class
is included in the title of the exception output.
.PP
To take advantage of this capability, you must specify arguments
as named parameters in the \fIthrow()\fR call. Here are the parameters:
.IP "\-class" 4
.IX Item "-class"
name of the class of the exception.
This should be one of the classes defined in Bio::Root::Exception,
or a custom error of yours that extends one of the exceptions
defined in Bio::Root::Exception.
.IP "\-text" 4
.IX Item "-text"
a sensible message for the exception
.IP "\-value" 4
.IX Item "-value"
the value causing the exception or $!, if appropriate.
.PP
Note that Bio::Root::Exception does not need to be imported into
your module (or script) namespace in order to throw exceptions
via \fIBio::Root::Root::throw()\fR, since Bio::Root::Root imports it.
.Sh "Try-Catch-Finally Support"
.IX Subsection "Try-Catch-Finally Support"
In addition to using an eval{} block to handle exceptions, you can
also use a try-catch-finally block structure if Error has been
installed in your system (available from \s-1CPAN\s0).  See the documentation
for Error for more details.
.PP
Here's an example. See the Bio::Root::Exception module for 
other pre-defined exception types:
.PP
.Vb 21
\&   try {
\&    open( IN, $file) || $obj->throw( -class => 'Bio::Root::FileOpenException',
\&                                     -text => "Cannot open file $file for reading",
\&                                     -value => $!);
\&   }
\&   catch Bio::Root::BadParameter with {
\&       my $err = shift;   # get the Error object
\&       # Perform specific exception handling code for the FileOpenException
\&   }
\&   catch Bio::Root::Exception with {
\&       my $err = shift;   # get the Error object
\&       # Perform general exception handling code for any Bioperl exception.
\&   }
\&   otherwise {
\&       # A catch-all for any other type of exception
\&   }
\&   finally {
\&       # Any code that you want to execute regardless of whether or not
\&       # an exception occurred.
\&   };  
\&   # the ending semicolon is essential!
.Ve
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this
and other Bioperl modules. Send your comments and suggestions preferably
to one of the Bioperl mailing lists.
.PP
Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Functions originally from Steve Chervitz. 
Refactored by Ewan Birney.
Re-refactored by Lincoln Stein.
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.Sh "new"
.IX Subsection "new"
.Vb 2
\& Purpose   : generic instantiation function can be overridden if 
\&             special needs of a module cannot be done in _initialize
.Ve
.Sh "verbose"
.IX Subsection "verbose"
.Vb 9
\& Title   : verbose
\& Usage   : $self->verbose(1)
\& Function: Sets verbose level for how ->warn behaves
\&           -1 = no warning
\&            0 = standard, small warning
\&            1 = warning with stack trace
\&            2 = warning becomes throw
\& Returns : The current verbosity setting (integer between -1 to 2)
\& Args    : -1,0,1 or 2
.Ve
.Sh "throw"
.IX Subsection "throw"
.Vb 24
\& Title   : throw
\& Usage   : $obj->throw("throwing exception message");
\&           or
\&           $obj->throw( -class => 'Bio::Root::Exception',
\&                        -text  => "throwing exception message",
\&                        -value => $bad_value  );
\& Function: Throws an exception, which, if not caught with an eval or
\&           a try block will provide a nice stack trace to STDERR 
\&           with the message.
\&           If Error.pm is installed, and if a -class parameter is
\&           provided, Error::throw will be used, throwing an error 
\&           of the type specified by -class.
\&           If Error.pm is installed and no -class parameter is provided
\&           (i.e., a simple string is given), A Bio::Root::Exception 
\&           is thrown.
\& Returns : n/a
\& Args    : A string giving a descriptive error message, optional
\&           Named parameters:
\&           '-class'  a string for the name of a class that derives 
\&                     from Error.pm, such as any of the exceptions 
\&                     defined in Bio::Root::Exception.
\&                     Default class: Bio::Root::Exception
\&           '-text'   a string giving a descriptive error message
\&           '-value'  the value causing the exception, or $! (optional)
.Ve
.PP
.Vb 10
\&           Thus, if only a string argument is given, and Error.pm is available,
\&           this is equivalent to the arguments:
\&                 -text  => "message",
\&                 -class => Bio::Root::Exception
\& Comments : If Error.pm is installed, and you don't want to use it
\&            for some reason, you can block the use of Error.pm by
\&            Bio::Root::Root::throw() by defining a scalar named
\&            $main::DONT_USE_ERROR (define it in your main script
\&            and you don't need the main:: part) and setting it to 
\&            a true value; you must do this within a BEGIN subroutine.
.Ve
.PP
.Vb 2
\&            Also note that if you use the string form, the string cannot
\&            start with a dash, or the resulting throw message will be empty.
.Ve
.Sh "debug"
.IX Subsection "debug"
.Vb 5
\& Title   : debug
\& Usage   : $obj->debug("This is debugging output");
\& Function: Prints a debugging message when verbose is > 0
\& Returns : none
\& Args    : message string(s) to print to STDERR
.Ve
.Sh "_load_module"
.IX Subsection "_load_module"
.Vb 6
\& Title   : _load_module
\& Usage   : $self->_load_module("Bio::SeqIO::genbank");
\& Function: Loads up (like use) the specified module at run time on demand.
\& Example : 
\& Returns : TRUE on success. Throws an exception upon failure.
\& Args    : The module to load (_without_ the trailing .pm).
.Ve
