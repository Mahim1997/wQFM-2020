.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Graph::ProteinGraph 3"
.TH Bio::Graph::ProteinGraph 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Graph::ProteinGraph \- a representation of a protein interaction graph.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  # Read in from file
\&  my $graphio = Bio::Graph::IO->new(-file   => 'myfile.dat',
\&                                    -format => 'dip');
\&  my $graph   = $graphio->next_network();
.Ve
.Sh "Using ProteinGraph"
.IX Subsection "Using ProteinGraph"
.Vb 2
\&  # Remove duplicate interactions from within a dataset
\&  $graph->remove_dup_edges();
.Ve
.PP
.Vb 2
\&  # Get a node (represented by a sequence object) from the graph.
\&  my $seqobj = $gr->nodes_by_id('P12345');
.Ve
.PP
.Vb 5
\&  # Get clustering coefficient of a given node.
\&  my $cc = $gr->clustering_coefficient($graph->nodes_by_id('NP_023232'));
\&  if ($cc != -1) {  ## result is -1 if cannot be calculated
\&    print "CC for NP_023232 is $cc";
\&  }
.Ve
.PP
.Vb 2
\&  # Get graph density
\&  my $density = $gr->density();
.Ve
.PP
.Vb 2
\&  # Get connected subgraphs
\&  my @graphs = $gr->components();
.Ve
.PP
.Vb 2
\&  # Remove a node
\&  $gr->remove_nodes($gr->nodes_by_id('P12345'));
.Ve
.PP
.Vb 2
\&  # How many interactions are there?
\&  my $count = $gr->edge_count;
.Ve
.PP
.Vb 2
\&  # How many nodes are there?
\&  my $ncount = $gr->node_count();
.Ve
.PP
.Vb 9
\&  # Let's get interactions above a threshold confidence score.
\&  my $edges = $gr->edges;
\&  for my $edge (keys %$edges) {
\&         if (defined($edges->{$edge}->weight()) &&
\&      $edges->{$edge}->weight() > 0.6) {
\&                    print $edges->{$edge}->object_id(), "\et",
\&             $edges->{$edge}->weight(),"\en";
\&         }
\&  }
.Ve
.PP
.Vb 6
\&  # Get interactors of your favourite protein
\&  my $node      = $graph->nodes_by_id('NP_023232');
\&  my @neighbors = $graph->neighbors($node); 
\&  print "      NP_023232 interacts with ";
\&  print join " ,", map{$_->object_id()} @neighbors;
\&  print "\en";
.Ve
.PP
.Vb 15
\&  # Annotate your sequences with interaction info
\&  my @seqs; ## array of sequence objects
\&  for my $seq(@seqs) {
\&    if ($graph->has_node($seq->accession_number)) {
\&       my $node = $graph->nodes_by_id( $seq->accession_number);
\&       my @neighbors = $graph->neighbors($node);
\&       for my $n (@neighbors) {
\&         my $ft = Bio::SeqFeature::Generic->new(
\&                      -primary_tag => 'Interactor',
\&                      -tags        => { id => $n->accession_number }
\&                      );
\&            $seq->add_SeqFeature($ft);
\&        }
\&     }
\&  }
.Ve
.PP
.Vb 10
\&  # Get proteins with > 10 interactors
\&  my @nodes = $graph->nodes();
\&  my @hubs;
\&  for my $node (@nodes) {
\&    if ($graph->neighbor_count($node) > 10) {
\&       push @hubs, $node;
\&    }
\&  }
\&  print "the following proteins have > 10 interactors:\en";
\&  print join "\en", map{$_->object_id()} @hubs;
.Ve
.PP
.Vb 5
\&  # Merge graphs 1 and 2 and flag duplicate edges
\&  $g1->union($g2);
\&  my @duplicates = $g1->dup_edges();
\&  print "these interactions exist in $g1 and $g2:\en";
\&  print join "\en", map{$_->object_id} @duplicates;
.Ve
.Sh "Creating networks from your own data"
.IX Subsection "Creating networks from your own data"
If you have interaction data in your own format, e.g. 
.PP
.Vb 1
\&  edgeid  node1  node2  score
.Ve
.PP
.Vb 4
\&  my $io = Bio::Root::IO->new(-file => 'mydata');
\&  my $gr = Bio::Graph::ProteinGraph->new();
\&  my %seen = (); # to record seen nodes
\&  while (my $l = $io->_readline() ) {
.Ve
.PP
.Vb 2
\&  # Parse out your data...
\&  my ($e_id, $n1, $n2, $sc) = split /\es+/, $l;
.Ve
.PP
.Vb 11
\&  # ...then make nodes if they don't already exist in the graph...
\&  my @nodes =();
\&    for my $n ($n1, $n2 ) {
\&                if (!exists($seen{$n})) {
\&        push @nodes,  Bio::Seq->new(-accession_number => $n);
\&                  $seen{$n} = $nodes[$#nodes];
\&      } else {
\&                        push @nodes, $seen{$n};
\&           }
\&    }
\&  }
.Ve
.PP
.Vb 5
\&  # ...and add a new edge to the graph
\&  my $edge  = Bio::Graph::Edge->new(-nodes => \e@nodes,
\&                                    -id    => 'myid',
\&                                    -weight=> 1);
\&  $gr->add_edge($edge);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A ProteinGraph is a representation of a protein interaction network.
It derives most of its functionality from the Bio::Graph::SimpleGraph
module, but is adapted to be able to use protein identifiers to
identify the nodes.
.PP
This graph can use any objects that implement Bio::AnnotatableI and 
Bio::IdentifiableI interfaces.  Bio::Seq (but not Bio::PrimarySeqI)
objects can therefore be used for the nodes but any object that supports 
annotation objects and the \fIobject_id()\fR method should work fine. 
.PP
At present it is fairly 'lightweight' in that it represents nodes and
edges but does not contain all the data about experiment ids etc. found
in the Protein Standards Initiative schema. Hopefully that will be
available soon.
.PP
A dataset may contain duplicate or redundant interactions. 
Duplicate interactions are interactions that occur twice in the dataset 
but with a different interaction \s-1ID\s0, perhaps from a different 
experiment. The dup_edges method will retrieve these.
.PP
Redundant interaction are interactions that occur twice or more in a 
dataset with the same interaction id. These are more likely to be 
due to database errors. These methods are useful when merging 2 
datasets using the \fIunion()\fR method. Interactions present in both 
datasets, with different IDs, will be duplicate edges. 
.Sh "For Developers"
.IX Subsection "For Developers"
In this module, nodes are represented by Bio::Seq::RichSeq objects
containing all possible database identifiers but no sequence, as
parsed from the interaction files. However, a node represented by a
Bio::PrimarySeq object should work fine too.
.PP
Edges are represented by Bio::Graph::Edge objects. In order to
work with SimpleGraph these objects must be array references, with the
first 2 elements being references to the 2 nodes. More data can be
added in \f(CW$e\fR[2]. etc. Edges should  be Bio::Graph::Edge objects, which 
are Bio::IdentifiableI implementing objects.
.PP
At present edges only have an identifier and a \fIweight()\fR method, to 
hold confidence data, but subclasses of this could hold all the 
interaction data held in an \s-1XML\s0 document.
.PP
So, a graph has the following data:
.PP
1. A hash of nodes ('_nodes'), where keys are the text representation of a 
nodes memory address and values are the sequence object references.
.PP
2. A hash of neighbors ('_neighbors'), where keys are the text representation of a 
nodes memory address and a value is a reference to a list of 
neighboring node references.
.PP
3. A hash of edges ('_edges'), where a key is a text representation of the 2 nodes.
E.g., \*(L"address1,address2\*(R" as a string, and values are Bio::Graph::Edge 
objects.
.PP
4. Look up hash ('_id_map') for finding a node by any of its ids. 
.PP
5. Look up hash for edges ('_edge_id_map') for retrieving an edge 
object  from its identifier.
.PP
6. Hash ('_components').
.PP
7. An array of duplicate edges ('_dup_edges').
.PP
8. Hash ('_is_connected').
.SH "REQUIREMENTS"
.IX Header "REQUIREMENTS"
To use this code you will need the Clone.pm module availabe from \s-1CPAN\s0.
You also need Class::AutoClass, available from \s-1CPAN\s0 as well.  To read in
\&\s-1XML\s0 data you will need XML::Twig available from \s-1CPAN\s0.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Bio::Graph::SimpleGraph
Bio::Graph::IO
Bio::Graph::Edge
Bio::Graph::IO::dip
Bio::Graph::IO::psi_xml
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists. Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
.Vb 1
\& Richard Adams - this module, Graph::IO modules.
.Ve
.PP
.Vb 1
\& Email richard.adams@ed.ac.uk
.Ve
.Sh "\s-1AUTHOR2\s0"
.IX Subsection "AUTHOR2"
.Vb 1
\& Nat Goodman - SimpleGraph.pm, and all underlying graph algorithms.
.Ve
.Sh "has_node"
.IX Subsection "has_node"
.Vb 5
\& name      : has_node
\& purpose   : Is a protein in the graph?
\& usage     : if ($g->has_node('NP_23456')) {....}
\& returns   : 1 if true, 0 if false
\& arguments : A sequence identifier.
.Ve
.Sh "nodes_by_id"
.IX Subsection "nodes_by_id"
.Vb 7
\& Name      : nodes_by_id
\& Purpose   : get node memory address from an id
\& Usage     : my @neighbors= $self->neighbors($self->nodes_by_id('O232322'))
\& Returns   : a SimpleGraph node representation ( a text representation
\&             of a node needed for other graph methods e.g.,
\&             neighbors(), edges()
\& Arguments : a protein identifier., e.g., its accession number.
.Ve
.Sh "union"
.IX Subsection "union"
.Vb 10
\& Name        : union
\& Purpose     : To merge two graphs together, flagging interactions as 
\&               duplicate.
\& Usage       : $g1->union($g2), where g1 and g2 are 2 graph objects. 
\& Returns     : void, $g1 is modified
\& Arguments   : A Graph object of the same class as the calling object. 
\& Description : This method merges 2 graphs. The calling graph is modified, 
\&               the parameter graph ($g2) in usage) is unchanged. To take 
\&               account of differing IDs identifying the same protein, all 
\&               ids are compared. The following rules are used to modify $g1.
.Ve
.PP
.Vb 2
\&               First of all both graphs are scanned for nodes that share 
\&               an id in common.
.Ve
.PP
.Vb 3
\&         1. If 2 nodes(proteins) share an interaction in both graphs,
\&            the edge in graph 2 is copied to graph 1 and added as a
\&            duplicate edge to graph 1,
.Ve
.PP
.Vb 3
\&         2. If 2 nodes interact in $g2 but not $g1, but both nodes exist
\&            in $g1, the attributes of the interaction in $g2 are 
\&            used to make a new edge in $g1.
.Ve
.PP
.Vb 3
\&         3. If 2 nodes interact in g2 but not g1, and 1 of them is a new
\&            protein, that protein is put in $g1 and a new edge made to
\&            it.
.Ve
.PP
.Vb 5
\&         4. At present, if there is an interaction in $g2 composed of a
\&            pair of interactors that are not present in $g1, they are 
\&            not copied to $g1. This is rather conservative but prevents
\&            the problem of having redundant nodes in $g1 due to the same
\&            protein being identified by different ids in the same graph.
.Ve
.PP
.Vb 1
\&         So, for example
.Ve
.PP
.Vb 1
\&              Edge   N1  N2 Comment
.Ve
.PP
.Vb 3
\&    Graph 1:  E1     P1  P2
\&              E2     P3  P4
\&              E3     P1  P4
.Ve
.PP
.Vb 5
\&    Graph 2:  X1     P1  P2 - will be added as duplicate to Graph1
\&              X2     P1  X4 - X4 added to Graph 1 and new edge made
\&              X3     P2  P3 - new edge links existing proteins in G1
\&              X4     Z4  Z5 - not added to Graph1. Are these different
\&                              proteins or synonyms for proteins in G1?
.Ve
.Sh "edge_count"
.IX Subsection "edge_count"
.Vb 6
\& Name     : edge_count
\& Purpose  : returns number of unique interactions, excluding 
\&            redundancies/duplicates
\& Arguments: void
\& Returns  : An integer
\& Usage    : my $count  = $graph->edge_count;
.Ve
.Sh "node_count"
.IX Subsection "node_count"
.Vb 5
\& Name     : node_count
\& Purpose  : returns number of nodes.
\& Arguments: void
\& Returns  : An integer
\& Usage    : my $count = $graph->node_count;
.Ve
.Sh "neighbor_count"
.IX Subsection "neighbor_count"
.Vb 5
\& Name      : neighbor_count
\& Purpose   : returns number of neighbors of a given node
\& Usage     : my $count = $gr->neighbor_count($node)
\& Arguments : a node object
\& Returns   : an integer
.Ve
.Sh "_get_ids_by_db"
.IX Subsection "_get_ids_by_db"
.Vb 5
\& Name     : _get_ids_by_db
\& Purpose  : gets all ids for a node, assuming its Bio::Seq object
\& Arguments: A Bio::SeqI object
\& Returns  : A hash: Keys are db ids, values are accessions
\& Usage    : my %ids = $gr->_get_ids_by_db($seqobj);
.Ve
.Sh "add_edge"
.IX Subsection "add_edge"
.Vb 10
\& Name        : add_edge
\& Purpose     : adds an interaction to a graph.
\& Usage       : $gr->add_edge($edge)
\& Arguments   : a Bio::Graph::Edge object, or a reference to a 2 element list. 
\& Returns     : void
\& Description : This is the method to use to add an interaction to a graph. 
\&               It contains the logic used to determine if a graph is a 
\&               new edge, a duplicate (an existing interaction with a 
\&               different edge id) or a redundant edge (same interaction, 
\&               same edge id).
.Ve
.Sh "subgraph"
.IX Subsection "subgraph"
.Vb 9
\& Name      : subgraph
\& Purpose   : To construct a subgraph of  nodes from the main network.This 
\&             method overrides that of Bio::Graph::SimpleGraph in its dealings with 
\&             Edge objects. 
\& Usage     : my $sg = $gr->subgraph(@nodes).
\& Returns   : A subgraph of the same class as the original graph. Edge objects are 
\&             cloned from the original graph but node objects are shared, so beware if you 
\&             start deleting nodes from the parent graph whilst operating on subgraph nodes. 
\& Arguments : A list of node objects.
.Ve
.Sh "add_dup_edge"
.IX Subsection "add_dup_edge"
.Vb 14
\& Name       : add_dup_edge
\& Purpose    : to flag an interaction as a duplicate, take advantage of 
\&              edge ids. The idea is that interactions from 2 sources with 
\&              different interaction ids can be used to provide more 
\&              evidence for a interaction being true, while preventing 
\&              redundancy of the same interaction being present more than 
\&              once in the same dataset. 
\& Returns    : 1 on successful addition, 0 on there being an existing 
\&              duplicate. 
\& Usage      : $gr->add_dup_edge(edge->new (-nodes => [$n1, $n2],
\&                                           -score => $score
\&                                           -id    => $id);
\& Arguments  : an EdgeI implementing object.
\& Descripton :
.Ve
.Sh "edge_by_id"
.IX Subsection "edge_by_id"
.Vb 5
\& Name        : edge_by_id
\& Purpose     : retrieve data about an edge from its id
\& Arguments   : a text identifier
\& Returns     : a Bio::Graph::Edge object or undef
\& Usage       : my $edge = $gr->edge_by_id('1000E');
.Ve
.Sh "remove_dup_edges"
.IX Subsection "remove_dup_edges"
.Vb 7
\& Name        : remove_dup_edges
\& Purpose     : removes duplicate edges from graph
\& Arguments   : none         - removes all duplicate edges
\&               edge id list - removes specified edges
\& Returns     : void
\& Usage       :    $gr->remove_dup_edges()
\&               or $gr->remove_dup_edges($edgeid1, $edgeid2);
.Ve
.Sh "redundant_edge"
.IX Subsection "redundant_edge"
.Vb 7
\& Name        : redundant_edge
\& Purpose     : adds/retrieves redundant edges to graph
\& Usage       : $gr->redundant_edge($edge)
\& Arguments   : none (getter) or a Biuo::Graph::Edge object (setter). 
\& Description : redundant edges are edges in a graph that have the 
\&               same edge id, ie. are 2 identical interactions. 
\&               With edge arg adds it to list, else returns list as reference.
.Ve
.Sh "redundant_edges"
.IX Subsection "redundant_edges"
.Vb 2
\& Name         : redundant_edges
\& Purpose      : alias for redundant_edge
.Ve
.Sh "remove_redundant_edges"
.IX Subsection "remove_redundant_edges"
.Vb 8
\& Name        : remove_redundant_edges
\& Purpose     : removes redundant_edges from graph, used by remove_node(),
\&               may be better as an internal method??
\& Arguments   : none         - removes all redundant edges
\&               edge id list - removes specified edges
\& Returns     : void
\& Usage       :    $gr->remove_redundant_edges()
\&               or $gr->remove_redundant_edges($edgeid1, $edgeid2);
.Ve
.Sh "clustering_coefficient"
.IX Subsection "clustering_coefficient"
.Vb 10
\& Name      : clustering_coefficient
\& Purpose   : determines the clustering coefficient of a node, a number 
\&             in range 0-1 indicating the extent to which the neighbors of
\&             a node are interconnnected.
\& Arguments : A sequence object (preferred) or a text identifier
\& Returns   : The clustering coefficient. 0 is a valid result.
\&             If the CC is not calculable ( if the node has <2 neighbors),
\&                returns -1.
\& Usage     : my $node = $gr->nodes_by_id('P12345');
\&             my $cc   = $gr->clustering_coefficient($node);
.Ve
.Sh "remove_nodes"
.IX Subsection "remove_nodes"
.Vb 6
\& Name      : remove_nodes
\& Purpose   : to delete a node from a graph, e.g., to simulate effect 
\&             of mutation
\& Usage     : $gr->remove_nodes($seqobj);
\& Arguments : a single $seqobj or list of seq objects (nodes)
\& Returns   : 1 on success
.Ve
.Sh "unconnected_nodes"
.IX Subsection "unconnected_nodes"
.Vb 5
\& Name      : unconnected_nodes
\& Purpose   : return a list of nodes with no connections. 
\& Arguments : none
\& Returns   : an array or array reference of unconnected nodes
\& Usage     : my @ucnodes = $gr->unconnected_nodes();
.Ve
.Sh "articulation_points"
.IX Subsection "articulation_points"
.Vb 13
\& Name      : articulation_points
\& Purpose   : to find edges in a graph that if broken will fragment
\&               the graph into islands.
\& Usage     : my $edgeref = $gr->articulation_points();
\&             for my $e (keys %$edgeref) {
\&                                   print $e->[0]->accession_number. "-".
\&                     $e->[1]->accession_number ."\en";
\&             }
\& Arguments : none
\& Returns   : a list references to nodes that will fragment the graph 
\&             if deleted. 
\& Notes     : This is a "slow but sure" method that works with graphs
\&               up to a few hundred nodes reasonably fast.
.Ve
.Sh "is_articulation_point"
.IX Subsection "is_articulation_point"
.Vb 5
\& Name      : is_articulation_point
\& Purpose   : to determine if a given node is an articulation point or not. 
\& Usage     : if ($gr->is_articulation_point($node)) {.... 
\& Arguments : a text identifier for the protein or the node itself
\& Returns   : 1 if node is an articulation point, 0 if it is not
.Ve
