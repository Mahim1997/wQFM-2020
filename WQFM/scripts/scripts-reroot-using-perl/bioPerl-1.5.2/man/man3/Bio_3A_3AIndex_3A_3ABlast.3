.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Index::Blast 3"
.TH Bio::Index::Blast 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Index::Blast \- Indexes Blast reports and supports retrieval 
based on query accession(s)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&    use strict;
\&    use Bio::Index::Blast;
\&    my ($indexfile,$file1,$file2,$query);
\&    my $index = new Bio::Index::Blast(-filename => $indexfile,
\&                                                          -write_flag => 1);
\&    $index->make_index($file1,$file2);
.Ve
.PP
.Vb 1
\&    my $data = $index->get_stream($query);
.Ve
.PP
.Vb 9
\&    my $blast_report = $index->fetch_report($query);
\&    print "query is ", $blast_report->query, "\en";
\&    while ( my $result = $blast_report->next_result ) {
\&            print $result->algorithm, "\en";
\&            while ( my $hsp = $result->next_hit ) {
\&              print "\et name ", $hsp->name,
\&            }
\&            print "\en";
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object allows one to build an index on a blast file (or files)
and provide quick access to the blast report for that accession.
Note: for best results 'use strict'.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Jason Stajich"
.IX Header "AUTHOR - Jason Stajich"
Email jason-at-bioperl-dot-org
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.Sh "new"
.IX Subsection "new"
.Vb 5
\&  Usage   : $index = Bio::Index::Abstract->new(
\&                -filename    => $dbm_file,
\&                -write_flag  => 0,
\&                -dbm_package => 'DB_File',
\&                -verbose     => 0);
.Ve
.PP
.Vb 12
\&  Function: Returns a new index object.  If filename is
\&            specified, then open_dbm() is immediately called. 
\&            Bio::Index::Abstract->new() will usually be called
\&            directly only when opening an existing index.
\&  Returns : A new index object
\&  Args    : -filename    The name of the dbm index file.
\&            -write_flag  TRUE if write access to the dbm file is
\&                         needed.
\&            -dbm_package The Perl dbm module to use for the
\&                         index.
\&            -verbose     Print debugging output to STDERR if
\&                         TRUE.
.Ve
.Sh "Bio::Index::Blast implemented methods"
.IX Subsection "Bio::Index::Blast implemented methods"
.Sh "fetch_report"
.IX Subsection "fetch_report"
.Vb 6
\& Title   : fetch_report
\& Usage   : my $blastreport = $idx->fetch_report($id);
\& Function: Returns a Bio::SearchIO report object 
\&           for a specific blast report
\& Returns : Bio::SearchIO
\& Args    : valid id
.Ve
.Sh "Require methods from Bio::Index::Abstract"
.IX Subsection "Require methods from Bio::Index::Abstract"
.Sh "_index_file"
.IX Subsection "_index_file"
.Vb 8
\&  Title   : _index_file
\&  Usage   : $index->_index_file( $file_name, $i )
\&  Function: Specialist function to index BLAST report file(s).
\&            Is provided with a filename and an integer
\&            by make_index in its SUPER class.
\&  Example : 
\&  Returns : 
\&  Args    :
.Ve
.Sh "Bio::Index::Abstract methods"
.IX Subsection "Bio::Index::Abstract methods"
.Sh "filename"
.IX Subsection "filename"
.Vb 7
\& Title   : filename
\& Usage   : $value = $self->filename();
\&           $self->filename($value);
\& Function: Gets or sets the name of the dbm index file.
\& Returns : The current value of filename
\& Args    : Value of filename if setting, or none if
\&           getting the value.
.Ve
.Sh "write_flag"
.IX Subsection "write_flag"
.Vb 9
\& Title   : write_flag
\& Usage   : $value = $self->write_flag();
\&           $self->write_flag($value);
\& Function: Gets or sets the value of write_flag, which
\&           is wether the dbm file should be opened with
\&           write access.
\& Returns : The current value of write_flag (default 0)
\& Args    : Value of write_flag if setting, or none if
\&           getting the value.
.Ve
.Sh "dbm_package"
.IX Subsection "dbm_package"
.Vb 2
\& Usage   : $value = $self->dbm_package();
\&           $self->dbm_package($value);
.Ve
.PP
.Vb 7
\& Function: Gets or sets the name of the Perl dbm module used. 
\&           If the value is unset, then it returns the value of
\&           the package variable $USE_DBM_TYPE or if that is
\&           unset, then it chooses the best available dbm type,
\&           choosing 'DB_File' in preference to 'SDBM_File'. 
\&           Bio::Abstract::Index may work with other dbm file
\&           types.
.Ve
.PP
.Vb 3
\& Returns : The current value of dbm_package
\& Args    : Value of dbm_package if setting, or none if
\&           getting the value.
.Ve
.Sh "get_stream"
.IX Subsection "get_stream"
.Vb 4
\& Title   : get_stream
\& Usage   : $stream = $index->get_stream( $id );
\& Function: Returns a file handle with the file pointer
\&           at the approprite place
.Ve
.PP
.Vb 2
\&           This provides for a way to get the actual
\&           file contents and not an object
.Ve
.PP
.Vb 3
\&           WARNING: you must parse the record deliminter
\&           *yourself*. Abstract wont do this for you 
\&           So this code
.Ve
.PP
.Vb 6
\&           $fh = $index->get_stream($myid);
\&           while( <$fh> ) {
\&              # do something
\&           }
\&           will parse the entire file if you do not put in
\&           a last statement in, like
.Ve
.PP
.Vb 4
\&           while( <$fh> ) {
\&              /^\e/\e// && last; # end of record
\&              # do something
\&           }
.Ve
.PP
.Vb 3
\& Returns : A filehandle object
\& Args    : string represents the accession number
\& Notes   : This method should not be used without forethought
.Ve
.Sh "open_dbm"
.IX Subsection "open_dbm"
.Vb 8
\&  Usage   : $index->open_dbm()
\&  Function: Opens the dbm file associated with the index
\&            object.  Write access is only given if explicitly
\&            asked for by calling new(-write => 1) or having set
\&            the write_flag(1) on the index object.  The type of
\&            dbm file opened is that returned by dbm_package(). 
\&            The name of the file to be is opened is obtained by
\&            calling the filename() method.
.Ve
.PP
.Vb 2
\&  Example : $index->_open_dbm()
\&  Returns : 1 on success
.Ve
.Sh "_version"
.IX Subsection "_version"
.Vb 9
\&  Title   : _version
\&  Usage   : $type = $index->_version()
\&  Function: Returns a string which identifes the version of an
\&            index module.  Used to permanently identify an index
\&            file as having been created by a particular version
\&            of the index module.  Must be provided by the sub class
\&  Example : 
\&  Returns : 
\&  Args    : none
.Ve
.Sh "_filename"
.IX Subsection "_filename"
.Vb 6
\&  Title   : _filename
\&  Usage   : $index->_filename( FILE INT )
\&  Function: Indexes the file
\&  Example : 
\&  Returns : 
\&  Args    :
.Ve
.Sh "_file_handle"
.IX Subsection "_file_handle"
.Vb 10
\&  Title   : _file_handle
\&  Usage   : $fh = $index->_file_handle( INT )
\&  Function: Returns an open filehandle for the file
\&            index INT.  On opening a new filehandle it
\&            caches it in the @{$index->_filehandle} array.
\&            If the requested filehandle is already open,
\&            it simply returns it from the array.
\&  Example : $fist_file_indexed = $index->_file_handle( 0 );
\&  Returns : ref to a filehandle
\&  Args    : INT
.Ve
.Sh "_file_count"
.IX Subsection "_file_count"
.Vb 9
\&  Title   : _file_count
\&  Usage   : $index->_file_count( INT )
\&  Function: Used by the index building sub in a sub class to
\&            track the number of files indexed.  Sets or gets
\&            the number of files indexed when called with or
\&            without an argument.
\&  Example : 
\&  Returns : INT
\&  Args    : INT
.Ve
.Sh "add_record"
.IX Subsection "add_record"
.Vb 10
\&  Title   : add_record
\&  Usage   : $index->add_record( $id, @stuff );
\&  Function: Calls pack_record on @stuff, and adds the result
\&            of pack_record to the index database under key $id.
\&            If $id is a reference to an array, then a new entry
\&            is added under a key corresponding to each element
\&            of the array.
\&  Example : $index->add_record( $id, $fileNumber, $begin, $end )
\&  Returns : TRUE on success or FALSE on failure
\&  Args    : ID LIST
.Ve
.Sh "pack_record"
.IX Subsection "pack_record"
.Vb 8
\&  Title   : pack_record
\&  Usage   : $packed_string = $index->pack_record( LIST )
\&  Function: Packs an array of scalars into a single string
\&            joined by ASCII 034 (which is unlikely to be used
\&            in any of the strings), and returns it. 
\&  Example : $packed_string = $index->pack_record( $fileNumber, $begin, $end )
\&  Returns : STRING or undef
\&  Args    : LIST
.Ve
.Sh "unpack_record"
.IX Subsection "unpack_record"
.Vb 7
\&  Title   : unpack_record
\&  Usage   : $index->unpack_record( STRING )
\&  Function: Splits the sting provided into an array,
\&            splitting on ASCII 034.
\&  Example : ( $fileNumber, $begin, $end ) = $index->unpack_record( $self->db->{$id} )
\&  Returns : A 3 element ARRAY
\&  Args    : STRING containing ASCII 034
.Ve
.Sh "\s-1DESTROY\s0"
.IX Subsection "DESTROY"
.Vb 6
\& Title   : DESTROY
\& Usage   : Called automatically when index goes out of scope
\& Function: Closes connection to database and handles to
\&           sequence files
\& Returns : NEVER
\& Args    : NONE
.Ve
