.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Tools::SeqWords 3"
.TH Bio::Tools::SeqWords 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Tools::SeqWords \- Object holding n\-mer statistics for a sequence
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Take a sequence object and create an object for the purposes of 
holding n\-mer word statistics about that sequence. The sequence can 
be nucleic acid or protein.
.PP
In \fIcount_words()\fR the words are counted in a non-overlapping manner,
ie. in the style of a codon table, but with any word length.
.PP
In \fIcount_overlap_words()\fR the words are counted in an overlapping
manner.
.PP
For counts on opposite strand (\s-1DNA/RNA\s0), a reverse complement
method should be performed, and then the count repeated.
.PP
Create the SeqWords object, e.g.:
.PP
.Vb 4
\&  my $inputstream = Bio::SeqIO->new(-file => "seqfile", 
\&                                         -format => 'Fasta');
\&  my $seqobj = $inputstream->next_seq();
\&  my $seq_word = Bio::Tools::SeqWords->new(-seq => $seqobj);
.Ve
.PP
Or:
.PP
.Vb 4
\&  my $seqobj = Bio::PrimarySeq->new(-seq => "agggtttccc",
\&                                    -alphabet => 'dna',
\&                                    -id => 'test');
\&  my $seq_word  =  Bio::Tools::SeqWords->new(-seq => $seqobj);
.Ve
.PP
.Vb 1
\&  # obtain a hash of word counts, eg:
.Ve
.PP
.Vb 1
\&  my $hash_ref = $seq_stats->count_words($word_length);
.Ve
.PP
.Vb 1
\&  # display hash table, eg:
.Ve
.PP
.Vb 5
\&  my %hash = %$hash_ref;
\&  foreach my $key(sort keys %hash)
\&  {
\&    print "\en$key\et$hash{$key}";
\&  }
.Ve
.PP
Or:
.PP
.Vb 2
\&  my $hash_ref = 
\&     Bio::Tools::SeqWords->count_words($seqobj,$word_length);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::Tools::SeqWords is a featherweight object for the calculation of
n\-mer word occurrences in a single sequence.  It is envisaged that the
object will be useful for construction of scripts which use n\-mer word
tables as the raw material for statistical calculations; for instance,
hexamer frequency for the calculation of coding protential, or the
calculation of periodicity in repetitive \s-1DNA\s0.  Triplet frequency is
already handled by Bio::Tools::SeqStats (author: Peter Schattner).
.PP
There are a few possible applications for protein, e.g. hypothesised
amino acid 7\-mers in heat shock proteins, or proteins with multiple
simple motifs.  Sometimes these protein periodicities are best seen
when the amino acid alphabet is truncated, e.g. Shulman alphabet.  Since
there are quite a few of these shortened alphabets, this module does
not specify any particular alphabet.
.PP
See Synopsis above for object creation code.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Derek Gatherer, in the loosest sense of the word 'author'.  The
general shape of the module is lifted directly from the SeqStat
module of Peter Schattner. The central subroutine to count the words is
adapted from original code provided by Dave Shivak, in response to a
query on the bioperl mailing list.  At least 2 other people provided
alternative means (equally good but not used in the end) of performing
the same calculation.  Thanks to all for your assistance.
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Jason Stajich, jason\-at\-bioperl.org
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.Sh "count_words"
.IX Subsection "count_words"
.Vb 13
\& Title   : count_words
\& Usage   : $word_count = $seq_stats->count_words($word_length)
\&                or 
\&           $word_count = $seq_stats->Bio::Tools::SeqWords->($seqobj,$word_length);
\& Function: Counts non-overlapping words within a string, any alphabet is 
\&           used
\& Example : a sequence ACCGTCCGT, counted at word length 4, will give the hash
\&           {ACCG => 1, TCCG => 1}
\& Returns : Reference to a hash in which keys are words (any length) of the
\&           alphabet used and values are number of occurrences of the word 
\&           in the sequence.
\& Args    : Word length as scalar and, reference to sequence object if
\&           required
.Ve
.PP
.Vb 2
\&           Throws an exception word length is not a positive integer
\&           or if word length is longer than the sequence.
.Ve
.Sh "count_overlap_words"
.IX Subsection "count_overlap_words"
.Vb 9
\& Title   : count_overlap_words
\& Usage   : $word_count = $word_obj->count_overlap_words($word_length);
\& Function: Counts overlapping words within a string, any alphabet is used
\& Example : A sequence ACCAACCA, counted at word length 4, will give the hash
\&                {ACCA=>2, CCAA=>1, CAAC=>1, AACC=>1}
\& Returns : Reference to a hash in which keys are words (any length) of the 
\&           alphabet used and values are number of occurrences of the word in 
\&           the sequence.
\& Args    : Word length as scalar
.Ve
.PP
.Vb 2
\&           Throws an exception if word length is not a positive integer
\&           or if word length is longer than the sequence.
.Ve
