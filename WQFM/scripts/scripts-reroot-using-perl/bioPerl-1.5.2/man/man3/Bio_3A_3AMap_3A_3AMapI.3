.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Map::MapI 3"
.TH Bio::Map::MapI 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Map::MapI \- Interface for describing Map objects in bioperl 
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&    # get a MapI somehow
\&    my $name   = $map->name();     # string
\&    my $length = $map->length();   # integer
\&    my $species= $map->species;    # Bio::Species
\&    my $type   = $map->type();     # genetic/sts/rh/
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object describes the basic functionality of a Map in bioperl.
Maps are anything from Genetic Map to Sequence Map to Assembly Map
to Restriction Enzyme to \s-1FPC\s0.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Jason Stajich"
.IX Header "AUTHOR - Jason Stajich"
Email jason@bioperl.org
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Lincoln Stein, lstein@cshl.org
Heikki Lehvaslaiho, heikki-at-bioperl-dot-org
Sendu Bala, bix@sendu.me.uk
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.Sh "EntityI methods"
.IX Subsection "EntityI methods"
.Vb 2
\& These are fundamental to coordination of Maps and other entities, so are
\& implemented at the interface level
.Ve
.Sh "get_position_handler"
.IX Subsection "get_position_handler"
.Vb 5
\& Title   : get_position_handler
\& Usage   : my $position_handler = $entity->get_position_handler();
\& Function: Gets a PositionHandlerI that $entity is registered with.
\& Returns : Bio::Map::PositionHandlerI object
\& Args    : none
.Ve
.Sh "PositionHandlerI-related methods"
.IX Subsection "PositionHandlerI-related methods"
.Vb 2
\& These are fundamental to coordination of Maps and other entities, so are
\& implemented at the interface level
.Ve
.Sh "get_positions"
.IX Subsection "get_positions"
.Vb 6
\& Title   : get_positions
\& Usage   : my @positions = $mappable->get_positions();
\& Function: Get all the Positions on this Map (sorted).
\& Returns : Array of L<Bio::Map::PositionI> objects
\& Args    : none for all, OR
\&           L<Bio::Map::MappableI> object for positions of the given Mappable
.Ve
.Sh "each_position"
.IX Subsection "each_position"
.Vb 3
\& Title   : each_position
\& Function: Synonym of the get_positions() method.
\& Status  : deprecated, will be removed in next version
.Ve
.Sh "purge_positions"
.IX Subsection "purge_positions"
.Vb 9
\& Title   : purge_positions
\& Usage   : $map->purge_position();
\& Function: Remove all positions from this map. Notifies the positions they are
\&           no longer on this map.
\& Returns : n/a
\& Args    : none to remove all positions, OR
\&           L<Bio::Map::PositionI> object to remove just that Position, OR
\&                   L<Bio::Map::MappableI> object to remove only those positions of the
\&           given mappable
.Ve
.Sh "get_elements"
.IX Subsection "get_elements"
.Vb 5
\& Title   : get_elements
\& Usage   : my @elements = $map->get_elements;
\& Function: Retrieves all the elements on a map (unordered)
\& Returns : Array of Map elements (L<Bio::Map::MappableI>)
\& Args    : none
.Ve
.Sh "each_element"
.IX Subsection "each_element"
.Vb 3
\& Title   : each_element
\& Function: Synonym of the get_elements() method.
\& Status  : deprecated, will be removed in the next version
.Ve
.Sh "common_elements"
.IX Subsection "common_elements"
.Vb 19
\& Title   : common_elements
\& Usage   : my @common_elements = $map->common_elements(\e@other_maps);
\&           my @common_elements = Bio::Map::SimpleMap->common_elements(\e@maps);
\& Function: Find the elements that are common to multiple maps.
\& Returns : array of Bio::Map::MappableI
\& Args    : arg #1 = L<Bio::Map::MapI> to compare this one to, or an array ref
\&                    of such objects (mandatory)
\&           arg #2 = optionally, one or more of the key => value pairs below
\&           -min_num => int        : the minimum number of input maps an element
\&                                    must be found on before before returned
\&                                    [default is 1]
\&           -min_percent => number : as above, but the minimum percentage of
\&                                    input maps [default is 100 - note that this
\&                                    will effectively override all other options]
\&           -require_self => 1|0   : require that all output elements at least
\&                                    be on the calling map [default is 1, has no
\&                                    effect when the second usage form is used]
\&           -required => \e@maps    : require that all output elements be on at
\&                                    least all the maps supplied here
.Ve
.Sh "MapI-specific methods"
.IX Subsection "MapI-specific methods"
.Sh "species"
.IX Subsection "species"
.Vb 5
\& Title   : species
\& Usage   : my $species = $map->species;
\& Function: Get/Set Species for a map
\& Returns : L<Bio::Species> object
\& Args    : (optional) Bio::Species
.Ve
.Sh "units"
.IX Subsection "units"
.Vb 5
\& Title   : units
\& Usage   : $map->units('cM');
\& Function: Get/Set units for a map
\& Returns : units for a map
\& Args    : units for a map (string)
.Ve
.Sh "type"
.IX Subsection "type"
.Vb 5
\& Title   : type
\& Usage   : my $type = $map->type
\& Function: Get/Set Map type
\& Returns : String coding map type
\& Args    : (optional) string
.Ve
.Sh "name"
.IX Subsection "name"
.Vb 5
\& Title   : name
\& Usage   : my $name = $map->name
\& Function: Get/Set Map name
\& Returns : Map name
\& Args    : (optional) string
.Ve
.Sh "length"
.IX Subsection "length"
.Vb 8
\& Title   : length
\& Usage   : my $length = $map->length();
\& Function: Retrieves the length of the map. 
\&           It is possible for the length to be unknown for maps such as
\&           Restriction Enzyme, will return 0 in that case
\& Returns : integer representing length of map in current units
\&           will return undef if length is not calculateable
\& Args    : none
.Ve
