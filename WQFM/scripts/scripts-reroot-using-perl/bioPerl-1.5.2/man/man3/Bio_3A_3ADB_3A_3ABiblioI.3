.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::BiblioI 3"
.TH Bio::DB::BiblioI 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::DB::BiblioI \- An interface to a Bibliographic Query Service
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This is an interface module \- you do not instantiate it.
Use \fIBio::Biblio\fR module:
.PP
.Vb 2
\&  use Bio::Biblio;
\&  my $biblio = new Bio::Biblio (@args);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This interface describes the methods for accessing a bibliographic
repository, for quering it and for retrieving citations from it. The
retrieved citations are in \s-1XML\s0 format and can be converted to perl
objects using \fIBio::Biblio::IO\fR.
.PP
The interface complies (with some simplifications) with the
specification described in the \fBOpenBQS\fR project. Its home page is at
http://www.ebi.ac.uk/~senger/openbqs/.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Martin Senger (martin.senger@gmail.com)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002 European Bioinformatics Institute. All Rights Reserved.
.PP
This module is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This software is provided \*(L"as is\*(R" without warranty of any kind.
.SH "APPENDIX"
.IX Header "APPENDIX"
This is actually the main documentation...
.PP
If you try to call any of these methods directly on this
Bio::DB::BiblioI object you will get a \fInot implemented\fR error
message. You need to call them on a Bio::Biblio object.
.Sh "get_collection_id"
.IX Subsection "get_collection_id"
.Vb 4
\& Usage   : my $collection_id = $biblio->get_collection_id;
\& Returns : string identifying a query collection
\&           represented by the $biblio object
\& Args    : none
.Ve
.PP
Every query collection is uniquely identify-able by its collection
\&\s-1ID\s0. The returned value can be used to populate another \f(CW$biblio\fR object
and then to access that collection.
.Sh "get_count"
.IX Subsection "get_count"
.Vb 3
\& Usage   : my $count = $biblio->get_count;
\& Returns : integer
\& Args    : none, or a string identifying a query collection
.Ve
.PP
It returns a number of citations in the query collection represented
by the calling \f(CW$biblio\fR object, or in the collection whose \s-1ID\s0 is given
as an argument.
.Sh "find"
.IX Subsection "find"
.Vb 11
\& Usage   : my $new_biblio = $biblio->find ($keywords, $attrs);
\&           my $new_biblio = $biblio->find ('perl', 'abstract');
\&           my $new_biblio = $biblio->find ( [ 'perl', 'Java' ] );
\& Returns : new Bio::Biblio object representing a new query
\&           collection
\& Args    : $keywords - what to look for (mandatory)
\&            - a comma-delimited list of keywords, or
\&            - an array reference with keywords as elements
\&           $attrs - where to look in (optional)
\&            - a comma-delimited list of attribute names, or
\&            - an array reference with attribute names as elements
.Ve
.PP
This is the main query method. It looks for the \f(CW$keywords\fR in a default
set of attributes, or \- if \f(CW$attrs\fR given \- only in the given
attributes.
.PP
Because it returns a new Bio::Biblio object which can be again queried
it is possible to chain together several invocations:
.PP
.Vb 1
\&    $biblio->find ('Brazma')->find ('Robinson')->get_collection_id;
.Ve
.Sh "reset_retrieval"
.IX Subsection "reset_retrieval"
.Vb 3
\& Usage   : $biblio->reset_retrieval;
\& Returns : nothing
\& Args    : none
.Ve
.PP
It sets an iterator stored in the \f(CW$biblio\fR object back to its
beginning. After this, the retrieval methods \fIhas_next\fR, \fIget_next\fR
and \fIget_more\fR start to iterate the underlying query collection
again from its start.
.PP
It throws an exception if this object does not represent any query
result (e.i. it does not contain a collection \s-1ID\s0). Note that a
collection \s-1ID\s0 is created automatically when this object was returned
by a \fIfind\fR method, or it can be assigned in a constructor using
argument \fI\-collection_id\fR.
.Sh "get_next"
.IX Subsection "get_next"
.Vb 3
\& Usage   : my $citation = $biblio->get_next;
\& Returns : a citation in an XML format
\& Args    : none
.Ve
.PP
It returns the next available citation from the underlying query
collection. It throws an exception if there are no more citations. In
order to avoid this, use it together with the \fIhas_next\fR method:
.PP
.Vb 4
\&  my $result = $biblio->find ('brazma', 'authors');
\&  while ( $result->has_next ) {
\&      print $result->get_next;
\&  }
.Ve
.PP
It also throws an exception if this object does not represent any
query result \- see explanation in the \fIreset_retrieval\fR elsewhere in
this document.
.Sh "get_more"
.IX Subsection "get_more"
.Vb 5
\& Usage   : my $r_citations = $biblio->get_more (5);
\& Returns : an array reference - each element has a citation
\&           in an XML format
\& Args    : an integer 'how_many' citations to return;
\&           default is 1 - but it is assigned with warning
.Ve
.PP
It returns the next \fIhow_many\fR available citations from the
underlying query collection. It does not throw any exception if
\&'how_many' is more than currently available \- it simply returns
less. However, it throws an exception if used again without calling
first \fIreset_retrieval\fR.
.PP
It also throws an exception if this object does not represent any
query result \- see explanation in method \fIreset_retrieval\fR elsewhere
in this document.
.Sh "has_next"
.IX Subsection "has_next"
.Vb 3
\& Usage   : my $is = $biblio->has_next;
\& Returns : 1 or undef
\& Args    : none
.Ve
.PP
It returns 1 if there is a next citation available in the underlying
query collection. Otherwise it returns undef.
.PP
It throws an exception if this object does not represent any query
result \- see explanation in method \fIreset_retrieval\fR elsewhere in
this document.
.Sh "get_all_ids"
.IX Subsection "get_all_ids"
.Vb 4
\& Usage   : my $r_ids = $biblio->get_all_ids;
\& Returns : an array reference - each element has
\&           a citation identifier
\& Args    : none
.Ve
.PP
The identifiers of all citations in the underlying query collection
are returned. A usual pattern is to use them then in the \fIget_by_id\fR
method:
.PP
.Vb 4
\&    my $biblio = $repository->find ('brazma')->find ('robinson');
\&    foreach my $id ( @{ $biblio->get_all_ids } ) {
\&        print $biblio->get_by_id ($id);
\&    }
.Ve
.PP
It throws an exception if this object does not represent any query
result \- see explanation in method \fIreset_retrieval\fR elsewhere in
this document.
.Sh "get_by_id"
.IX Subsection "get_by_id"
.Vb 3
\& Usage   : my $citation = $biblio->get_by_id ('12368254');
\& Returns : a citation in an XML format
\& Args    : a citation identifier (PMID for Medline)
.Ve
.PP
It returns a citation \- disregarding if the citation is or is not in
the underlying query collection (of course, it must be in the
repository).
.Sh "get_all"
.IX Subsection "get_all"
.Vb 3
\& Usage   : my $all = $biblio->get_all;
\& Returns : a (big) string with all citations in an XML format
\& Args    : none
.Ve
.PP
It returns an \s-1XML\s0 valid string (which means that individual citations
are also surrounded by a \*(L"set\*(R" \s-1XML\s0 tag) representing all citations
from the underlying query collection.
.PP
Note that some servers may limit the number of citations which can be
returned by this method. In such case you need either to refine
further your query collection (using \fIfind\fR method) or to retrieve
results by iteration (methods \fIhas_next\fR, \fIget_next\fR, \fIget_more\fR).
.PP
It throws an exception if this object does not represent any query
result \- see explanation in method \fIreset_retrieval\fR elsewhere in
this document.
.Sh "exists"
.IX Subsection "exists"
.Vb 3
\& Usage   : my $exists = $biblio->exists;
\& Returns : 1 or undef
\& Args    : none
.Ve
.PP
It returns 1 if the underlying query collection represented by the
\&\f(CW$biblio\fR object still exists (on the server side).
.PP
If you have a collection \s-1ID\s0 (e.g. stored or printed in a previous
session) but you do not have anymore a \f(CW\*(C`Bio::Biblio\*(C'\fR object representing
it this is how you can check the collection existence:
.PP
.Vb 3
\&    use Bio::Biblio;
\&    print
\&      new Bio::Biblio (-collection_id => '1014324148861')->exists;
.Ve
.PP
It throws an exception if this object does not represent any query
result \- see explanation in method \fIreset_retrieval\fR elsewhere in
this document.
.Sh "destroy"
.IX Subsection "destroy"
.Vb 3
\& Usage   : $biblio->destroy;
\& Returns : nothing
\& Args    : none
.Ve
.PP
It sends a message to the remote server to forget (or free, or destroy
\&\- whatever server choose to do) the query collection represented by
this object.
.PP
It throws an exception if this object does not represent any query
collection.
.Sh "get_vocabulary_names"
.IX Subsection "get_vocabulary_names"
.Vb 4
\& Usage   : print join ("\en", @{ $biblio->get_vocabulary_names });
\& Returns : an array reference - each element has a name
\&           of a controlled vocabulary
\& Args    : none
.Ve
.PP
The controlled vocabularies allow to introspect bibliographic
repositories and to find what citation resource types (such as journal
and book articles, patents or technical reports) are provided by the
repository, what attributes they have, eventually what attribute
values are allowed.
.PP
This method returns names of all available controlled
vocabularies. The names can than be used in other methods dealing with
vocabularies: \fIcontains\fR, \fIget_entry_description\fR,
\&\fIget_all_values\fR, and \fIget_all_entries\fR.
.Sh "contains"
.IX Subsection "contains"
.Vb 4
\& Usage   : my $yes = $biblio->contains ($vocabulary_name, $value);
\& Returns : 1 or undef
\& Args    : $vocabulary_name defines a vocabulary where to look,
\&           and a $value defines what to look for
.Ve
.PP
It returns 1 if the given controlled vocabulary contains the given
value.
.PP
For example, when you know, that a vocabulary
\&\f(CW\*(C`MEDLINE/JournalArticle/properties\*(C'\fR contains value \f(CW\*(C`COUNTRY\*(C'\fR you can
use it in the \fIfind\fR method:
.PP
.Vb 1
\&    $biblio->find ('United States', 'COUNTRY');
.Ve
.Sh "get_entry_description"
.IX Subsection "get_entry_description"
.Vb 4
\& Usage   : $biblio->get_entry_description ($voc_name, $value);
\& Returns : a string with a desciption
\& Args    : $voc_name defines a vocabulary where to look,
\&           and a $value defines whose description to return
.Ve
.PP
Each vocabulary entry has its value (mandatory attribute), and can
have a description (optional attribute). The description may be just a
human readable explanation of an attribute, or it can have more exact
meaning. For example, the server implementation of the bibliographic
query service provided by the \s-1EBI\s0 puts into attribute descriptions
words \fIqueryable\fR and/or \fIretrievable\fR to distinguish the role of
the attributes.
.PP
It throws an exception if either vocabulary or value do not exist.
.Sh "get_all_values"
.IX Subsection "get_all_values"
.Vb 5
\& Usage   : $biblio->get_all_values ($vocabulary_name);
\& Returns : an array reference - each element has a value (scalar)
\&           from the given controlled vocabulary
\& Args    : $vocabulary_name defines a vocabulary whose values
\&           are being returned
.Ve
.PP
It returns all values of the given vocabulary.  It throws an exception
if the vocabulary does not exist.
.Sh "get_all_entries"
.IX Subsection "get_all_entries"
.Vb 5
\& Usage   : $biblio->get_all_entries ($vocabulary_name);
\& Returns : a hash reference - keys are vocabulary values
\&           and values are their descriptions
\& Args    : $vocabulary_name defines a vocabulary whose entries
\&           are being returned
.Ve
.PP
It returns pairs of values and their descriptions of the whole
vocabulary. It throws an exception if the vocabulary does not exist.
.PP
This is one way how to get it and print it:
.PP
.Vb 4
\&    my $name = 'MEDLINE2005/JournalArticle/properties';
\&    use Data::Dumper;
\&    print Data::Dumper->Dump ( [$biblio->get_all_entries ($name)],
\&                               ['All entries']);
.Ve
.Sh "\s-1VERSION\s0 and Revision"
.IX Subsection "VERSION and Revision"
.Vb 2
\& Usage   : print $Bio::DB::BiblioI::VERSION;
\&           print $Bio::DB::BiblioI::Revision;
.Ve
