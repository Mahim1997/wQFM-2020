.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Tools::Spidey::Results 3"
.TH Bio::Tools::Spidey::Results 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Tools::Spidey::Results \- Results of a Spidey run
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   use Bio::Tools::Spidey::Results;
\&        my $spidey = Bio::Tools::Spidey::Results->new(-file => 'result.spidey' );
.Ve
.PP
.Vb 1
\&        # or
.Ve
.PP
.Vb 1
\&        my $spidey = Bio::Tools::Spidey::Results->new( -fh   => \e*INPUT );
.Ve
.PP
.Vb 2
\&        # get the exons before doing anything else
\&        my $exonset = $spidey->next_exonset();
.Ve
.PP
.Vb 3
\&        # parse the results
\&        my @exons = $exonset->sub_SeqFeature();
\&        print "Total no of Exons: ", scalar(@exons), "\en";
.Ve
.PP
.Vb 1
\&        print "Genomic sequence length: ", $spidey->genomic_dna_length(), "\en";
.Ve
.PP
.Vb 4
\&        # $exonset is-a Bio::SeqFeature::Generic with Bio::Tools::Spidey::Exons
\&        # as sub features
\&        print "Delimited on sequence ", $exonset->seq_id(), " from ", 
\&                $exonset->start(), " to ", $exonset->end(), "\en";
.Ve
.PP
.Vb 9
\&        foreach my $exon ( $exonset->sub_SeqFeature() ) {
\&                # $exon is-a Bio::SeqFeature::FeaturePair
\&                print "Exon from ", $exon->start, " to ", $exon->end, 
\&                        " on strand ", $exon->strand(), "\en";
\&                # you can get out what it matched using the est_hit attribute
\&                my $homol = $exon->est_hit();
\&                print "Matched to sequence ", $homol->seq_id, 
\&                        " at ", $homol->start," to ", $homol->end, "\en";
\&        }
.Ve
.PP
.Vb 3
\&        # essential if you gave a filename at initialization (otherwise 
\&        # the file stays open)
\&        $spidey->close();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The spidey module provides a parser and results object for spidey 
output. The spidey results are specialised types of SeqFeatures, 
meaning you can add them to AnnSeq objects fine, and manipulate them 
in the \*(L"normal\*(R" seqfeature manner.
.PP
The spidey Exon objects are Bio::SeqFeature::FeaturePair inherited 
objects. The \f(CW$esthit\fR = \f(CW$exon\fR\->\fIest_hit()\fR is the alignment as a 
feature on the matching object (normally, a cDNA), in which the 
start/end points are where the hit lies.
.PP
To make this module work sensibly you need to run
.PP
.Vb 1
\&     spidey -i genomic.fasta -m cDNA.fasta
.Ve
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Ryan Golhar"
.IX Header "AUTHOR - Ryan Golhar"
Email golharam@umdnj.edu
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods. 
Internal methods are usually preceded with a _
.Sh "analysis_method"
.IX Subsection "analysis_method"
.Vb 5
\& Usage     : $spidey->analysis_method();
\& Purpose   : Inherited method. Overridden to ensure that the name matches
\&             /Spidey/i.
\& Returns   : String
\& Argument  : n/a
.Ve
.Sh "parse_next_alignment"
.IX Subsection "parse_next_alignment"
.Vb 12
\& Title   : parse_next_alignment
\& Usage   : @exons = $spidey_result->parse_next_alignment;
\&           foreach $exon (@exons) {
\&               # do something
\&           }
\& Function: Parses the next alignment of the Spidey result file and returns the
\&           found exons as an array of Bio::Tools::Spidey::Exon objects. Call
\&           this method repeatedly until an empty array is returned to get the
\&           results for all alignments.
\& Example :
\& Returns : An array of Bio::Tools::Spidey::Exon objects
\& Args    :
.Ve
.Sh "next_exonset"
.IX Subsection "next_exonset"
.Vb 12
\& Title   : next_exonset
\& Usage   : $exonset = $spidey_result->parse_next_exonset;
\&           print "Exons start at ", $exonset->start(), 
\&                 "and end at ", $exonset->end(), "\en";
\&           foreach $exon ($exonset->sub_SeqFeature()) {
\&               # do something
\&           }
\& Function: Parses the next alignment of the Spidey result file and returns the
\&           set of exons as a container of features. The container is itself
\&           a Bio::SeqFeature::Generic object, with the Bio::Tools::Spidey::Exon
\&           objects as sub features. Start, end, and strand of the container
\&           will represent the total region covered by the exons of this set.
.Ve
.PP
.Vb 2
\&           See the documentation of parse_next_alignment() for further
\&           reference about parsing and how the information is stored.
.Ve
.PP
.Vb 4
\& Example : 
\& Returns : An Bio::SeqFeature::Generic object holding Bio::Tools::Spidey::Exon
\&           objects as sub features.
\& Args    :
.Ve
.Sh "next_feature"
.IX Subsection "next_feature"
.Vb 7
\& Title   : next_feature
\& Usage   : while($exonset = $spidey->next_feature()) {
\&                  # do something
\&           }
\& Function: Does the same as L<next_exonset()>. See there for documentation of
\&           the functionality. Call this method repeatedly until FALSE is
\&           returned.
.Ve
.PP
.Vb 4
\&           The returned object is actually a SeqFeatureI implementing object.
\&           This method is required for classes implementing the
\&           SeqAnalysisParserI interface, and is merely an alias for 
\&           next_exonset() at present.
.Ve
.PP
.Vb 3
\& Example :
\& Returns : A Bio::SeqFeature::Generic object.
\& Args    :
.Ve
.Sh "genomic_dna_length"
.IX Subsection "genomic_dna_length"
.Vb 6
\& Title   : genomic_dna_length
\& Usage   : $spidey->genomic_dna_length();
\& Function: Returns the length of the genomic DNA used in this Spidey result
\& Example :
\& Returns : An integer value.
\& Args    :
.Ve
.Sh "splicesites"
.IX Subsection "splicesites"
.Vb 6
\& Title   : splicesites
\& Usage   : $spidey->splicesites();
\& Function: Returns the number of splice sites found in this Spidey result
\& Example :
\& Returns : An integer value.
\& Args    :
.Ve
.Sh "est_coverage"
.IX Subsection "est_coverage"
.Vb 6
\& Title   : est_coverage
\& Usage   : $spidey->est_coverage();
\& Function: Returns the percent of est coverage in this Spidey result
\& Example :
\& Returns : An integer value.
\& Args    :
.Ve
.Sh "overall_percentage_id"
.IX Subsection "overall_percentage_id"
.Vb 6
\& Title   : overall_percentage_id
\& Usage   : $spidey->overall_percentage_id();
\& Function: Returns the overall percent id in this Spidey result
\& Example :
\& Returns : An float value.
\& Args    :
.Ve
.Sh "missing_mrna_ends"
.IX Subsection "missing_mrna_ends"
.Vb 6
\& Title   : missing_mrna_ends
\& Usage   : $spidey->missing_mrna_ends();
\& Function: Returns left/right/neither from Spidey
\& Example :
\& Returns : A string value.
\& Args    :
.Ve
