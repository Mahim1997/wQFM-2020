.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::SeqIO::table 3"
.TH Bio::SeqIO::table 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::SeqIO::table \- sequence input/output stream from a delimited table
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  #It is probably best not to use this object directly, but
\&  #rather go through the SeqIO handler system. Go:
.Ve
.PP
.Vb 1
\&  $stream = Bio::SeqIO->new(-file => $filename, -format => 'table');
.Ve
.PP
.Vb 3
\&  while ( my $seq = $stream->next_seq() ) {
\&        # do something with $seq
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class transforms records in a table-formatted text file into
Bio::Seq objects.
.PP
A table-formatted text file of sequence records for the purposes of
this module is defined as a text file with each row corresponding to a
sequence, and the attributes of the sequence being in different
columns. Columns are delimited by a common delimiter, for instance tab
or comma.
.PP
The module permits specifying which columns hold which type of
annotation. The semantics of certain attributes, if present, are
pre\-defined, e.g., accession number and sequence. Additional
attributes may be added to the annotation bundle.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.
.PP
Bug reports can be submitted via email or the web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Hilmar Lapp"
.IX Header "AUTHOR - Hilmar Lapp"
Email hlapp at gmx.net
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.Sh "new"
.IX Subsection "new"
.Vb 5
\& Title   : new
\& Usage   : $stream = Bio::SeqIO->new(-file => $filename, -format => 'table')
\& Function: Returns a new seqstream
\& Returns : A Bio::SeqIO stream for a table format
\& Args    : Named parameters:
.Ve
.PP
.Vb 27
\&             -file    name of file to read
\&             -fh      filehandle to attach to
\&             -comment leading character(s) introducing a comment line
\&             -header  the number of header lines to skip; the first
\&                      non-comment header line will be used to obtain
\&                      column names; column names will be used as the
\&                      default tags for attaching annotation.
\&             -delim   the delimiter for columns as a regular expression;
\&                      consecutive occurrences of the delimiter will
\&                      not be collapsed.
\&             -display_id the one-based index of the column containing
\&                      the display ID of the sequence
\&             -accession_number the one-based index of the column
\&                      containing the accession number of the sequence
\&             -seq     the one-based index of the column containing
\&                      the sequence string of the sequence
\&             -species the one-based index of the column containing the
\&                      species for the sequence record; if not a
\&                      number, will be used as the static species
\&                      common to all records
\&             -annotation if provided and a scalar (but see below), a
\&                      flag whether or not all additional columns are
\&                      to be preserved as annotation, the tags used
\&                      will either be 'colX' if there is no column
\&                      header and where X is the one-based column
\&                      index, and otherwise the column headers will be
\&                      used as tags;
.Ve
.PP
.Vb 4
\&                      if a reference to an array, or a square
\&                      bracket-enclosed string of comma-delimited
\&                      values, only those columns (one-based index)
\&                      will be preserved as annotation, tags as before;
.Ve
.PP
.Vb 17
\&                      if a reference to a hash, or a curly
\&                      braces-enclosed string of comma-delimited key
\&                      and value pairs in alternating order, the keys
\&                      are one-based column indexes to be preserved,
\&                      and the values are the tags under which the
\&                      annotation is to be attached; if not provided or
\&                      supplied as undef, no additional annotation will
\&                      be preserved.
\&             -colnames a reference to an array of column labels, or a
\&                      string of comma-delimited labels, denoting the
\&                      columns to be converted into annotation; this is
\&                      an alternative to -annotation and will be
\&                      ignored if -annotation is also supplied with a
\&                      valid value.
\&             -trim    flag determining whether or not all values should
\&                      be trimmed of leading and trailing white space
\&                      and double quotes
.Ve
.PP
.Vb 3
\&           Additional arguments may be used to e.g. set factories and
\&           builders involved in the sequence object creation (see the
\&           POD of Bio::SeqIO).
.Ve
.Sh "next_seq"
.IX Subsection "next_seq"
.Vb 5
\& Title   : next_seq
\& Usage   : $seq = $stream->next_seq()
\& Function: returns the next sequence in the stream
\& Returns : Bio::Seq::RichSeq object
\& Args    :
.Ve
.Sh "comment_char"
.IX Subsection "comment_char"
.Vb 7
\& Title   : comment_char
\& Usage   : $obj->comment_char($newval)
\& Function: Get/set the leading character(s) designating a line as
\&           a comment-line.
\& Example :
\& Returns : value of comment_char (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.Sh "header"
.IX Subsection "header"
.Vb 4
\& Title   : header
\& Usage   : $obj->header($newval)
\& Function: Get/set the number of header lines to skip before the
\&           rows containing actual sequence records.
.Ve
.PP
.Vb 2
\&           If set to zero or undef, means that there is no header and
\&           therefore also no column headers.
.Ve
.PP
.Vb 3
\& Example :
\& Returns : value of header (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.Sh "delimiter"
.IX Subsection "delimiter"
.Vb 5
\& Title   : delimiter
\& Usage   : $obj->delimiter($newval)
\& Function: Get/set the column delimiter. This will in fact be
\&           treated as a regular expression. Consecutive occurrences
\&           will not be collapsed to a single one.
.Ve
.PP
.Vb 3
\& Example :
\& Returns : value of delimiter (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.Sh "attribute_map"
.IX Subsection "attribute_map"
.Vb 4
\& Title   : attribute_map
\& Usage   : $obj->attribute_map($newval)
\& Function: Get/set the map of sequence object initialization
\&           attributes (keys) to one-based column index.
.Ve
.PP
.Vb 3
\&           Attributes will usually need to be prefixed by a dash, just
\&           as if they were passed to the new() method of the sequence
\&           class.
.Ve
.PP
.Vb 3
\& Example :
\& Returns : value of attribute_map (a reference to a hash)
\& Args    : on set, new value (a reference to a hash or undef, optional)
.Ve
.Sh "annotation_map"
.IX Subsection "annotation_map"
.Vb 4
\& Title   : annotation_map
\& Usage   : $obj->annotation_map($newval)
\& Function: Get/set the mapping between one-based column indexes
\&           (keys) and annotation tags (values).
.Ve
.PP
.Vb 5
\&           Note that the map returned by this method may change after
\&           the first next_seq() call if the file contains a column
\&           header and no annotation keys have been predefined in the
\&           map, because upon reading the column header line the tag
\&           names will be set automatically.
.Ve
.PP
.Vb 2
\&           Note also that the map may reference columns that are used
\&           as well in the sequence attribute map.
.Ve
.PP
.Vb 3
\& Example :
\& Returns : value of annotation_map (a reference to a hash)
\& Args    : on set, new value (a reference to a hash or undef, optional)
.Ve
.Sh "keep_annotation"
.IX Subsection "keep_annotation"
.Vb 4
\& Title   : keep_annotation
\& Usage   : $obj->keep_annotation($newval)
\& Function: Get/set flag whether or not to keep values from
\&           additional columns as annotation.
.Ve
.PP
.Vb 2
\&           Additional columns are all those columns in the input file
\&           that aren't referenced in the attribute map.
.Ve
.PP
.Vb 3
\& Example :
\& Returns : value of keep_annotation (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.Sh "annotation_columns"
.IX Subsection "annotation_columns"
.Vb 4
\& Title   : annotation_columns
\& Usage   : $obj->annotation_columns($newval)
\& Function: Get/set the names (labels) of the columns to be used for
\&           annotation.
.Ve
.PP
.Vb 4
\&           This is an alternative to using annotation_map. In order to
\&           have any effect, it must be set before the first call of
\&           next_seq(), and obviously there must be a header line (or
\&           row) too giving the column labels.
.Ve
.PP
.Vb 3
\& Example :
\& Returns : value of annotation_columns (a reference to an array)
\& Args    : on set, new value (a reference to an array of undef, optional)
.Ve
.Sh "trim_values"
.IX Subsection "trim_values"
.Vb 7
\& Title   : trim_values
\& Usage   : $obj->trim_values($newval)
\& Function: Get/set whether or not to trim leading and trailing
\&           whitespace off all column values.
\& Example :
\& Returns : value of trim_values (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.SH "Internal methods"
.IX Header "Internal methods"
All methods with a leading underscore are not meant to be part of the
\&'official' \s-1API\s0. They are for use by this module only, consider them
private unless you are a developer trying to modify this module.
.Sh "_attribute_map"
.IX Subsection "_attribute_map"
.Vb 3
\& Title   : _attribute_map
\& Usage   : $obj->_attribute_map($newval)
\& Function: Get only. Same as attribute_map, but zero-based indexes.
.Ve
.PP
.Vb 4
\&           Note that any changes made to the returned map will change
\&           the map used by this instance. You should know what you are
\&           doing if you modify the returned value (or if you call this
\&           method in the first place).
.Ve
.PP
.Vb 3
\& Example :
\& Returns : value of _attribute_map (a reference to a hash)
\& Args    : none
.Ve
.Sh "_annotation_map"
.IX Subsection "_annotation_map"
.Vb 3
\& Title   : _annotation_map
\& Usage   : $obj->_annotation_map($newval)
\& Function: Get only. Same as annotation_map, but with zero-based indexes.
.Ve
.PP
.Vb 4
\&           Note that any changes made to the returned map will change
\&           the map used by this instance. You should know what you are
\&           doing if you modify the returned value (or if you call this
\&           method in the first place).
.Ve
.PP
.Vb 3
\& Example :
\& Returns : value of _annotation_map (a reference to a hash)
\& Args    : none
.Ve
.Sh "_header_skipped"
.IX Subsection "_header_skipped"
.Vb 7
\& Title   : _header_skipped
\& Usage   : $obj->_header_skipped($newval)
\& Function: Get/set the flag whether the header was already
\&           read (and skipped) or not.
\& Example :
\& Returns : value of _header_skipped (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.Sh "_next_record"
.IX Subsection "_next_record"
.Vb 3
\& Title   : _next_record
\& Usage   :
\& Function: Navigates the underlying file to the next record.
.Ve
.PP
.Vb 3
\&           For row-based records in delimited text files, this will
\&           skip all empty lines and lines with a leading comment
\&           character.
.Ve
.PP
.Vb 3
\&           This method is here is to serve as a hook for other formats
\&           that conceptually also represent tables but aren't
\&           formatted as row-based text files.
.Ve
.PP
.Vb 5
\& Example :
\& Returns : TRUE if the navigation was successful and FALSE
\&           otherwise. Unsuccessful navigation will usually be treated
\&           as an end-of-file condition.
\& Args    :
.Ve
.Sh "_parse_header"
.IX Subsection "_parse_header"
.Vb 3
\& Title   : _parse_header
\& Usage   :
\& Function: Parse the table header and navigate past it.
.Ve
.PP
.Vb 6
\&           This method is called if the number of header rows has been
\&           specified equal to or greater than one, and positioned at
\&           the first header line (row). By default the first header
\&           line (row) is used for setting column names, but additional
\&           lines (rows) may be skipped too. Empty lines and comment
\&           lines do not count as header lines (rows).
.Ve
.PP
.Vb 4
\&           This method will call _next_record() to navigate to the
\&           next header line (row), if there is more than one header
\&           line (row). Upon return, the file is presumed to be
\&           positioned at the first record after the header.
.Ve
.PP
.Vb 3
\&           This method is here is to serve as a hook for other formats
\&           that conceptually also represent tables but aren't
\&           formatted as row-based text files.
.Ve
.PP
.Vb 4
\&           Note however that the only methods used to access file
\&           content or navigate the position are _get_row_values() and
\&           _next_record(), so it should usually suffice to override
\&           those.
.Ve
.PP
.Vb 5
\& Example :
\& Returns : TRUE if navigation past the header was successful and FALSE
\&           otherwise. Unsuccessful navigation will usually be treated
\&           as an end-of-file condition.
\& Args    :
.Ve
.Sh "_get_row_values"
.IX Subsection "_get_row_values"
.Vb 4
\& Title   : _get_row_values
\& Usage   :
\& Function: Get the values for the current line (or row) as an array in
\&           the order of columns.
.Ve
.PP
.Vb 3
\&           This method is here is to serve as a hook for other formats
\&           that conceptually also represent tables but aren't
\&           formatted as row-based text files.
.Ve
.PP
.Vb 3
\& Example :
\& Returns : An array of column values for the current row.
\& Args    :
.Ve
