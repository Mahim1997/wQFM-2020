.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Tools::BPpsilite 3"
.TH Bio::Tools::BPpsilite 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Tools::BPpsilite \- Lightweight BLAST parser for (iterated) psiblast reports
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use Bio::Tools::BPpsilite;
\&  open my $FH, "t/psiblastreport.out";
\&  $report = Bio::Tools::BPpsilite->new(-fh=>$FH);
.Ve
.PP
.Vb 3
\&  # determine number of iterations executed by psiblast
\&  $total_iterations = $report->number_of_iterations;
\&  $last_iteration = $report->round($total_iterations);
.Ve
.PP
.Vb 8
\&  # Process only hits found in last iteration ...
\&   $oldhitarray_ref = $last_iteration->oldhits;
\&   HIT: while($sbjct = $last_iteration->nextSbjct) {
\&          $id = $sbjct->name;
\&          $is_old =  grep  /\eQ$id\eE/, @$oldhitarray_ref;
\&          if ($is_old ){next HIT;}
\&  #  do something with new hit...
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB\s-1NOTE:\s0\fR This module's functionality has been implemented in
Bio::SearchIO::blast and therefore is not actively maintained.
.PP
BPpsilite is a package for parsing multiple iteration \s-1PSIBLAST\s0
reports.  It is based closely on Ian Korf's Bio::Tools::BPlite
module for parsing single iteration \s-1BLAST\s0 reports (as modified by
Lorenz Pollak).
.PP
Two of the four basic objects of Bio::Tools::BPpsilite are
identical to the corresponding objects in BPlite \- the \*(L"\s-1HSP\s0.pm\*(R" and
\&\*(L"Sbjct.pm\*(R" objects.  This \s-1DESCRIPTION\s0 documents only the one new
object, the \*(L"iteration\*(R", as well as the additional methods that are
implemented in BPpsilite that are not in BPlite.  See the BPlite
documentation for information on the BPlite, \s-1SBJCT\s0 and \s-1HSP\s0 objects.
.PP
The essential difference between \s-1PSIBLAST\s0 and the other \s-1BLAST\s0 programs
(in terms of report parsing) is that \s-1PSIBLAST\s0 performs multiple
iterations of the BLASTing of the database and the results of all of
these iterations are stored in a single \s-1PSIBLAST\s0 report.  (For general
information on \s-1PSIBLAST\s0 see the \s-1README\s0.bla file in the standalone
\&\s-1BLAST\s0 distribution and references therein). \s-1PSIBLAST\s0's use of multiple
iterations imposes additional demands on the report parser: * There
are several iterations of hits.  Many of those hits will be repeated
in more than one iteration.  Often only the last iteration will be of
interest.  * Each iteration will list two different kinds of hits \-
repeated hits that were used in the model and newly identified hits \-
which may need to be processed in different manners * The total number
of iterations performed is not displayed in the report until (almost)
the very end of the report.  (The user can specify a maximum number of
iterations for the \s-1PSIBLAST\s0 search, but the program may perform fewer
iterations if convergence is reached)
.PP
BPpsilite addresses these issues by offering the following methods:
.PP
* The total number of iteration used is given by the method
   number_of_iterations as in:
.PP
.Vb 1
\&        $total_iterations = $report->number_of_iterations;
.Ve
.PP
* Results from an arbitrary iteration round can be accessed by using
  the 'round' method:
.PP
.Vb 1
\&        $iteration3_report = $report->round(3);
.Ve
.PP
* The ids of the sequences which passed the significance threshold for
  the first time in the \*(L"nth\*(R" iteration can be identified by using the
  newhits method.  Previously identified hits are identified by using
  the oldhits method, as in:
.PP
.Vb 2
\&        $oldhitarray_ref = $iteration3_report->oldhits;
\&        $newhitarray_ref = $iteration3_report->newhits;
.Ve
.PP
BPpsilite.pm should work equally well on reports generated by the
StandAloneBlast.pm local \s-1BLAST\s0 module as with reports generated by
remote psiblast searches. For examples of usage of BPpsilite.pm, the
user is referred to the BPpsilite.t script in the \*(L"t\*(R" directory.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Peter Schattner"
.IX Header "AUTHOR - Peter Schattner"
Email: schattner@alum.mit.edu
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Jason Stajich, jason\-at\-bioperl.org
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Based on work of:
Ian Korf (ikorf@sapiens.wustl.edu, http://sapiens.wustl.edu/~ikorf), 
Lorenz Pollak (lorenz@ist.org, bioperl port)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
BPlite.pm is copyright (C) 1999 by Ian Korf. 
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This software is provided \*(L"as is\*(R" without warranty of any kind.
.Sh "query"
.IX Subsection "query"
.Vb 5
\& Title    : query
\& Usage    : $query = $obj->query();
\& Function : returns the query object
\& Returns  : query object
\& Args     :
.Ve
.Sh "qlength"
.IX Subsection "qlength"
.Vb 5
\& Title    : qlength
\& Usage    : $len = $obj->qlength();
\& Function : returns the length of the query 
\& Returns  : length of query
\& Args     :
.Ve
.Sh "database"
.IX Subsection "database"
.Vb 5
\& Title    : database
\& Usage    : $db = $obj->database();
\& Function : returns the database used in this search
\& Returns  : database used for search
\& Args     :
.Ve
.Sh "number_of_iterations"
.IX Subsection "number_of_iterations"
.Vb 5
\& Title    : number_of_iterations
\& Usage    : $total_iterations = $obj-> number_of_iterations();
\& Function : returns the total number of iterations used in this search
\& Returns  : total number of iterations used for search
\& Args     : none
.Ve
.Sh "pattern"
.IX Subsection "pattern"
.Vb 3
\& Title    : database
\& Usage    : $pattern = $obj->pattern();
\& Function : returns the pattern used in a PHIBLAST search
.Ve
.Sh "query_pattern_location"
.IX Subsection "query_pattern_location"
.Vb 4
\& Title    : query_pattern_location
\& Usage    : $qpl = $obj->query_pattern_location();
\& Function : returns reference to array of locations in the query sequence
\&            of pattern used in a PHIBLAST search
.Ve
.Sh "round"
.IX Subsection "round"
.Vb 7
\& Title    : round
\& Usage    : $Iteration3 = $report->round(3);
\& Function : Method of retrieving data from a specific iteration 
\& Example  :  
\& Returns  : reference to requested Iteration object or null if argument
\&                is greater than total number of iterations
\& Args     : number of the requested iteration
.Ve
.Sh "_preprocess"
.IX Subsection "_preprocess"
.Vb 8
\& Title    : _preprocess
\& Usage    : internal routine, not called directly
\& Function : determines number of iterations in report and prepares
\&            data so individual iterations canbe parsed in non-sequential 
\&            order 
\& Example  :  
\& Returns  : nothing. Sets TOTAL_ITERATION_NUMBER in object's hash
\& Args     : reference to calling object
.Ve
