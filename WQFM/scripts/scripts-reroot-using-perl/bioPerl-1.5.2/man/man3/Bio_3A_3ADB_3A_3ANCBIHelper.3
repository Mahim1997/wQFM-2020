.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::NCBIHelper 3"
.TH Bio::DB::NCBIHelper 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::DB::NCBIHelper \- A collection of routines useful for queries to
NCBI databases.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& # Do not use this module directly.
.Ve
.PP
.Vb 5
\& # get a Bio::DB::NCBIHelper object somehow
\& my $seqio = $db->get_Stream_by_acc(['MUSIGHBA1']);
\& foreach my $seq ( $seqio->next_seq ) {
\&     # process seq
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Provides a single place to setup some common methods for querying \s-1NCBI\s0
web databases.  This module just centralizes the methods for
constructing a \s-1URL\s0 for querying \s-1NCBI\s0 GenBank and \s-1NCBI\s0 GenPept and the
common \s-1HTML\s0 stripping done in postprocess_data().
.PP
The base \s-1NCBI\s0 query \s-1URL\s0 used is:
http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi 
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the
evolution of this and other Bioperl modules. Send
your comments and suggestions preferably to one
of the Bioperl mailing lists. Your participation
is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to
help us keep track the bugs and their resolution.
Bug reports can be submitted via the web.
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Jason Stajich"
.IX Header "AUTHOR - Jason Stajich"
Email jason@bioperl.org
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the
object methods. Internal methods are usually
preceded with a _
.Sh "get_params"
.IX Subsection "get_params"
.Vb 6
\& Title   : get_params
\& Usage   : my %params = $self->get_params($mode)
\& Function: Returns key,value pairs to be passed to NCBI database
\&           for either 'batch' or 'single' sequence retrieval method
\& Returns : a key,value pair hash
\& Args    : 'single' or 'batch' mode for retrieval
.Ve
.Sh "default_format"
.IX Subsection "default_format"
.Vb 5
\& Title   : default_format
\& Usage   : my $format = $self->default_format
\& Function: Returns default sequence format for this module
\& Returns : string
\& Args    : none
.Ve
.Sh "get_request"
.IX Subsection "get_request"
.Vb 5
\& Title   : get_request
\& Usage   : my $url = $self->get_request
\& Function: HTTP::Request
\& Returns : 
\& Args    : %qualifiers = a hash of qualifiers (ids, format, etc)
.Ve
.Sh "get_Stream_by_batch"
.IX Subsection "get_Stream_by_batch"
.Vb 9
\&  Title   : get_Stream_by_batch
\&  Usage   : $seq = $db->get_Stream_by_batch($ref);
\&  Function: Retrieves Seq objects from Entrez 'en masse', rather than one
\&            at a time.  For large numbers of sequences, this is far superior
\&            than get_Stream_by_[id/acc]().
\&  Example :
\&  Returns : a Bio::SeqIO stream object
\&  Args    : $ref : either an array reference, a filename, or a filehandle
\&            from which to get the list of unique ids/accession numbers.
.Ve
.PP
\&\s-1NOTE:\s0 deprecated \s-1API\s0.  Use \fIget_Stream_by_id()\fR instead.
.Sh "get_Stream_by_query"
.IX Subsection "get_Stream_by_query"
.Vb 11
\&  Title   : get_Stream_by_query
\&  Usage   : $seq = $db->get_Stream_by_query($query);
\&  Function: Retrieves Seq objects from Entrez 'en masse', rather than one
\&            at a time.  For large numbers of sequences, this is far superior
\&            than get_Stream_by_[id/acc]().
\&  Example :
\&  Returns : a Bio::SeqIO stream object
\&  Args    : $query :   An Entrez query string or a
\&            Bio::DB::Query::GenBank object.  It is suggested that you
\&            create a Bio::DB::Query::GenBank object and get the entry
\&            count before you fetch a potentially large stream.
.Ve
.Sh "postprocess_data"
.IX Subsection "postprocess_data"
.Vb 8
\& Title   : postprocess_data
\& Usage   : $self->postprocess_data ( 'type' => 'string',
\&                                                         'location' => \e$datastr);
\& Function: process downloaded data before loading into a Bio::SeqIO
\& Returns : void
\& Args    : hash with two keys - 'type' can be 'string' or 'file'
\&                              - 'location' either file location or string 
\&                                           reference containing data
.Ve
.Sh "request_format"
.IX Subsection "request_format"
.Vb 9
\& Title   : request_format
\& Usage   : my ($req_format, $ioformat) = $self->request_format;
\&           $self->request_format("genbank");
\&           $self->request_format("fasta");
\& Function: Get/Set sequence format retrieval. The get-form will normally not
\&           be used outside of this and derived modules.
\& Returns : Array of two strings, the first representing the format for
\&           retrieval, and the second specifying the corresponding SeqIO format.
\& Args    : $format = sequence format
.Ve
.Sh "Bio::DB::WebDBSeqI methods"
.IX Subsection "Bio::DB::WebDBSeqI methods"
Overriding WebDBSeqI method to help newbies to retrieve sequences
.Sh "get_Stream_by_acc"
.IX Subsection "get_Stream_by_acc"
.Vb 7
\&  Title   : get_Stream_by_acc
\&  Usage   : $seq = $db->get_Stream_by_acc([$acc1, $acc2]);
\&  Function: Gets a series of Seq objects by accession numbers
\&  Returns : a Bio::SeqIO stream object
\&  Args    : $ref : a reference to an array of accession numbers for
\&                   the desired sequence entries
\&  Note    : For GenBank, this just calls the same code for get_Stream_by_id()
.Ve
.Sh "_check_id"
.IX Subsection "_check_id"
.Vb 5
\&  Title   : _check_id
\&  Usage   : 
\&  Function: 
\&  Returns : A Bio::DB::RefSeq reference or throws
\&  Args    : $id(s), $string
.Ve
.Sh "delay_policy"
.IX Subsection "delay_policy"
.Vb 5
\&  Title   : delay_policy
\&  Usage   : $secs = $self->delay_policy
\&  Function: return number of seconds to delay between calls to remote db
\&  Returns : number of seconds to delay
\&  Args    : none
.Ve
.PP
.Vb 2
\&  NOTE: NCBI requests a delay of 3 seconds between requests.  This method
\&        implements that policy.
.Ve
.Sh "cookie"
.IX Subsection "cookie"
.Vb 5
\& Title   : cookie
\& Usage   : ($cookie,$querynum) = $db->cookie
\& Function: return the NCBI query cookie
\& Returns : list of (cookie,querynum)
\& Args    : none
.Ve
.PP
\&\s-1NOTE:\s0 this information is used by Bio::DB::GenBank in
conjunction with efetch.
.Sh "_parse_response"
.IX Subsection "_parse_response"
.Vb 6
\& Title   : _parse_response
\& Usage   : $db->_parse_response($content)
\& Function: parse out response for cookie
\& Returns : empty
\& Args    : none
\& Throws  : 'unparseable output exception'
.Ve
