.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::LiveSeq::IO::BioPerl 3"
.TH Bio::LiveSeq::IO::BioPerl 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::LiveSeq::IO::BioPerl \- Loader for LiveSeq from EMBL entries with BioPerl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  my $db="EMBL";
\&  my $file="../data/M20132";
\&  my $id="HSANDREC";
.Ve
.PP
.Vb 3
\&  my $loader=Bio::LiveSeq::IO::BioPerl->load(-db=>"$db", -file=>"$file");
\&  #                      or
\&  my $loader=Bio::LiveSeq::IO::BioPerl->load(-db=>"$db", -id=>"$id");
.Ve
.PP
.Vb 1
\&  my @translationobjects=$loader->entry2liveseq();
.Ve
.PP
.Vb 3
\&  my $genename="AR";
\&  my $gene=$loader->gene2liveseq(-gene_name => "$genename",
\&                                    -getswissprotinfo => 0);
.Ve
.PP
.Vb 10
\&  #NOTE1: The only -db now supported is EMBL. Hence it defaults to EMBL.
\&  #NOTE2: -file requires a filename (and path if necessary) containing an
\&  #             EMBL entry
\&  #       -id will use Bio::DB::EMBL.pm to fetch the sequence from the web,
\&  #             (bioperl wraparound to [w]getz from SRS)
\&  #NOTE3: To retrieve the swissprot (if possible) attached to the embl entry
\&  #             (to get protein domains at dna level), only Bio::DB::EMBL.pm
\&  #             is supported under BioPerl. Refer to Bio::LiveSeq::IO::SRS
\&  #             otherwise.
\&  #NOTE4: NOTE3 is not implemented yet for bioperl, working on it
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package uses BioPerl (SeqIO) to fetch a sequence database entry,
analyse it and create LiveSeq objects out of it.
.PP
A filename (or an \s-1ID\s0 that will fetch entry through the web) has to be passed
to this package which will return references to all translation objects
created from the \s-1EMBL\s0 entry. References to Transcription, \s-1DNA\s0 and Exon
objects can all be retrieved departing from these.
.PP
Alternatively, a specific \*(L"gene\*(R" name can be specified, together with
the embl-acc \s-1ID\s0. This will create a LiveSeq::Gene object with all
relevant gene features attached/created.
.PP
\&\s-1ATTENTION:\s0 if web fetching is requested, the package HTTP::Request needs
to be installed.
.SH "AUTHOR \- Joseph A.L. Insana"
.IX Header "AUTHOR - Joseph A.L. Insana"
Email:  Insana@ebi.ac.uk, jinsana@gmx.net
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.Sh "load"
.IX Subsection "load"
.Vb 5
\&  Title   : load
\&  Usage   : my $filename="../data/M20132";
\&            $loader=Bio::LiveSeq::IO::BioPerl->load(-db=>"EMBL", -file=>"$filename");
\&                                   or
\&            $loader=Bio::LiveSeq::IO::BioPerl->load(-db=>"EMBL", -id=>"HSANDREC");
.Ve
.PP
.Vb 4
\&  Function: loads an entry with BioPerl from a database into a hash
\&  Returns : reference to a new object of class IO::BioPerl holding an entry
\&  Errorcode 0
\&  Args    : an filename containing an EMBL entry OR an ID or ACCESSION code
.Ve
.Sh "embl2hash"
.IX Subsection "embl2hash"
.Vb 11
\&  Title   : embl2hash
\&  Function: retrieves with BioPerl an EMBL entry, parses it and creates
\&            a hash that contains all the information.
\&  Returns : a reference to a hash
\&  Errorcode: 0
\&  Args    : a BioPerl Sequence Object (from file or web fetching)
\&            two array references to skip features and qualifiers (for
\&            performance)
\&  Example: @valid_features=qw(CDS exon prim_transcript mRNA);
\&           @valid_qualifiers=qw(gene codon_start db_xref product rpt_family);
\&           $hashref=&embl2hash($seqobj,\e@valid_features,\e@valid_qualifiers);
.Ve
.Sh "novelaasequence2gene"
.IX Subsection "novelaasequence2gene"
.Vb 8
\&  Title   : novelaasequence2gene
\&  Usage   : $gene=Bio::LiveSeq::IO::BioPerl->novelaasequence2gene(-aasequence => "MGLAAPTRS*");
\&          : $gene=Bio::LiveSeq::IO::BioPerl->novelaasequence2gene(-aasequence => "MGLAAPTRS*",
\&                                             -cusg_data => "58 44 7 29 3 3 480 267 105 143 122 39 144 162 14 59 53 25 233 292 19 113 88 246 28 68 161 231 27 102 128 151 67 60 138 131 48 61 153 19 233 73 150 31 129 38 147 71 138 43 181 81 44 15 255 118 312 392 236 82 20 10 14 141");
\&          : $gene=Bio::LiveSeq::IO::BioPerl->novelaasequence2gene(-aasequence => "MGLAAPTRS*",
\&                                             -cusg_data => "58 44 7 29 3 3 480 267 105 143 122 39 144 162 14 59 53 25 233 292 19 113 88 246 28 68 161 231 27 102 128 151 67 60 138 131 48 61 153 19 233 73 150 31 129 38 147 71 138 43 181 81 44 15 255 118 312 392 236 82 20 10 14 141",
\&                                             -translation_table => "2",
\&                                             -gene_name => "tyr-kinase");
.Ve
.PP
.Vb 13
\&  Function: creates LiveSeq objects from a novel amino acid sequence,
\&            using codon usage information (loaded from a file) to choose
\&            codons according to relative frequencies.
\&            If a codon_usage information is not specified,
\&            the default is to use Homo sapiens data (taxonomy ID 9606).
\&            If a translation_table ID is not specified, it will default to 1
\&            (standard code).
\&  Returns : reference to a Gene object containing references to LiveSeq objects
\&  Errorcode 0
\&  Args    : string containing an amino acid sequence
\&            string (optional) with codon usage data (64 integer numbers)
\&            string (optional) specifying a gene_name
\&            integer (optional) specifying a translation_table ID
.Ve
