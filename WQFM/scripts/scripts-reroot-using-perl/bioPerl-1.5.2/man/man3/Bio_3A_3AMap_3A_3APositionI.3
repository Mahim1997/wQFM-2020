.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Map::PositionI 3"
.TH Bio::Map::PositionI 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Map::PositionI \- Abstracts the notion of a position having a value in the context of a marker and a Map
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    # do not use this module directly
\&    # See Bio::Map::Position for an example of
\&    # implementation.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object stores one of the postions that a mappable object
(e.g. Marker) may have in a map.
.PP
Positions can have non-numeric values or other methods to store the locations,
so they have a method \fInumeric()\fR which does the conversion. \fInumeric()\fR
returns the position in a form that can be compared between other positions of
the same type. It is not necessarily a value suitable for sorting positions (it
may be the distance from the previous position); for that purpose the result of
\&\fIsortable()\fR should be used.
.PP
A 'position', in addition to being a single point, can also be an area and so
can be imagined as a range and compared with other positions on the basis of
overlap, intersection etc.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Jason Stajich"
.IX Header "AUTHOR - Jason Stajich"
Email jason\-at\-bioperl.org
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Lincoln Stein, lstein\-at\-cshl.org
Heikki Lehvaslaiho, heikki-at-bioperl-dot-org
Sendu Bala, bix@sendu.me.uk
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.Sh "EntityI methods"
.IX Subsection "EntityI methods"
.Vb 2
\& These are fundamental to coordination of Positions and other entities, so are
\& implemented at the interface level
.Ve
.Sh "get_position_handler"
.IX Subsection "get_position_handler"
.Vb 5
\& Title   : get_position_handler
\& Usage   : my $position_handler = $entity->get_position_handler();
\& Function: Gets a PositionHandlerI that $entity is registered with.
\& Returns : Bio::Map::PositionHandlerI object
\& Args    : none
.Ve
.Sh "PositionHandlerI-related methods"
.IX Subsection "PositionHandlerI-related methods"
.Vb 2
\& These are fundamental to coordination of Positions and other entities, so are
\& implemented at the interface level
.Ve
.Sh "map"
.IX Subsection "map"
.Vb 7
\& Title   : map
\& Usage   : my $map = $position->map();
\&           $position->map($map);
\& Function: Get/Set the map the position is in.
\& Returns : L<Bio::Map::MapI>
\& Args    : none to get
\&           new L<Bio::Map::MapI> to set
.Ve
.Sh "element"
.IX Subsection "element"
.Vb 7
\& Title   : element
\& Usage   : my $element = $position->element();
\&           $position->element($element);
\& Function: Get/Set the element the position is for.
\& Returns : L<Bio::Map::MappableI>
\& Args    : none to get
\&           new L<Bio::Map::MappableI> to set
.Ve
.Sh "marker"
.IX Subsection "marker"
.Vb 3
\& Title   : marker
\& Function: This is a synonym of the element() method
\& Status  : deprecated, will be removed in the next version
.Ve
.Sh "PositionI-specific methods"
.IX Subsection "PositionI-specific methods"
.Sh "value"
.IX Subsection "value"
.Vb 5
\& Title   : value
\& Usage   : my $pos = $position->value();
\& Function: Get/Set the value for this position
\& Returns : scalar, value
\& Args    : [optional] new value to set
.Ve
.Sh "numeric"
.IX Subsection "numeric"
.Vb 8
\& Title   : numeric
\& Usage   : my $num = $position->numeric;
\& Function: Read-only method that is guaranteed to return a numeric 
\&           representation of the start of this position. 
\& Returns : scalar numeric
\& Args    : none to get the co-ordinate normally (see absolute() method), OR
\&           Bio::Map::RelativeI to get the co-ordinate converted to be
\&           relative to what this Relative describes.
.Ve
.Sh "sortable"
.IX Subsection "sortable"
.Vb 8
\& Title   : sortable
\& Usage   : my $num = $position->sortable();
\& Function: Read-only method that is guaranteed to return a value suitable
\&           for correctly sorting this kind of position amongst other positions
\&           of the same kind on the same map. Note that sorting different kinds
\&           of position together is unlikely to give sane results.
\& Returns : numeric
\& Args    : none
.Ve
.Sh "relative"
.IX Subsection "relative"
.Vb 9
\&  Title   : relative
\&  Usage   : my $relative = $position->relative();
\&            $position->relative($relative);
\&  Function: Get/set the thing this Position's coordinates (numerical(), start(),
\&            end()) are relative to, as described by a Relative object.
\&  Returns : Bio::Map::RelativeI (default is one describing "relative to the
\&            start of the Position's map")
\&  Args    : none to get, OR
\&            Bio::Map::RelativeI to set
.Ve
.Sh "absolute"
.IX Subsection "absolute"
.Vb 9
\&  Title   : absolute
\&  Usage   : my $absolute = $position->absolute();
\&            $position->absolute($absolute);
\&  Function: Get/set how this Position's co-ordinates (numerical(), start(),
\&            end()) are reported. When absolute is off, co-ordinates are
\&            relative to the thing described by relative(). Ie. the value
\&            returned by start() will be the same as the value you set start()
\&            to. When absolute is on, co-ordinates are converted to be relative
\&            to the start of the map.
.Ve
.PP
.Vb 5
\&            So if relative() currently points to a Relative object describing
\&            "relative to another position which is 100 bp from the start of
\&            the map", this Position's start() had been set to 50 and absolute()
\&            returns 1, $position->start() will return 150. If absolute() returns
\&            0 in the same situation, $position->start() would return 50.
.Ve
.PP
.Vb 3
\&  Returns : boolean (default 0)
\&  Args    : none to get, OR
\&            boolean to set
.Ve
.Sh "RangeI-based methods"
.IX Subsection "RangeI-based methods"
.Sh "start"
.IX Subsection "start"
.Vb 9
\&  Title   : start
\&  Usage   : my $start = $position->start();
\&            $position->start($start);
\&  Function: Get/set the start co-ordinate of this position.
\&  Returns : the start of this position
\&  Args    : scalar numeric to set, OR
\&            none to get the co-ordinate normally (see absolute() method), OR
\&            Bio::Map::RelativeI to get the co-ordinate converted to be
\&            relative to what this Relative describes.
.Ve
.Sh "end"
.IX Subsection "end"
.Vb 9
\&  Title   : end
\&  Usage   : my $end = $position->end();
\&            $position->end($end);
\&  Function: Get/set the end co-ordinate of this position.
\&  Returns : the end of this position
\&  Args    : scalar numeric to set, OR
\&            none to get the co-ordinate normally (see absolute() method), OR
\&            Bio::Map::RelativeI to get the co-ordinate converted to be
\&            relative to what this Relative describes.
.Ve
.Sh "length"
.IX Subsection "length"
.Vb 5
\&  Title   : length
\&  Usage   : $length = $position->length();
\&  Function: Get the length of this position.
\&  Returns : the length of this position
\&  Args    : none
.Ve
.Sh "strand"
.IX Subsection "strand"
.Vb 6
\&  Title   : strand
\&  Usage   : $strand = $position->strand();
\&  Function: Get the strand of this position; it is always 1 since maps to not
\&            have strands.
\&  Returns : 1
\&  Args    : none
.Ve
.Sh "toString"
.IX Subsection "toString"
.Vb 6
\&  Title   : toString
\&  Usage   : print $position->toString(), "\en";
\&  Function: stringifies this range
\&  Returns : a string representation of the range of this Position
\&  Args    : optional Bio::Map::RelativeI to have the co-ordinates reported
\&            relative to the thing described by that Relative
.Ve
.SH "RangeI-related methods"
.IX Header "RangeI-related methods"
These methods work by considering only the values of \fIstart()\fR and \fIend()\fR, as
modified by considering every such co-ordinate relative to the start of the map
(ie. \fIabsolute\fR\|(1) is set temporarily during the calculation), or any supplied
Relative. For the boolean methods, when the comparison Position is on the same
map as the calling Position, there is no point supplying a Relative since the
answer will be the same as without. Relative is most useful when comparing
Positions on different maps and you have a Relative that describes some special
place on each map like 'the start of the gene', where the actual start of the
gene relative to the start of the map is different for each map.
.PP
The methods do not consider maps during their calculations \- things on different
maps can overlap/contain/intersect/etc. each other.
.PP
The geometrical methods (intersect, union etc.) do things to the geometry of
ranges, and return Bio::Map::PositionI compliant objects or triplets (start,
stop, strand) from which new positions could be built. When a PositionI is made
it will have a map transferred to it if all the arguments shared the same map.
If a Relative was supplied the result will have that same Relative.
.PP
Note that the strand-testing args are there for compatability with the RangeI
interface. They have no meaning when only using PositionI objects since maps do
not have strands. Typically you will just set the argument to undef if you want
to supply the argument after it.
.Sh "equals"
.IX Subsection "equals"
.Vb 10
\&  Title   : equals
\&  Usage   : if ($p1->equals($p2)) {...}
\&  Function: Test whether $p1 has the same start, end, length as $p2.
\&  Returns : true if they are describing the same position (regardless of map)
\&  Args    : arg #1 = a Bio::RangeI (eg. a Bio::Map::Position) to compare this
\&                     one to (mandatory)
\&            arg #2 = optional strand-testing arg ('strong', 'weak', 'ignore')
\&            arg #3 = optional Bio::Map::RelativeI to ask if the Positions
\&                     equal in terms of their relative position to the thing
\&                     described by that Relative
.Ve
.Sh "less_than"
.IX Subsection "less_than"
.Vb 9
\& Title   : less_than
\& Usage   : if ($position->less_than($other_position)) {...}
\& Function: Ask if this Position ends before another starts.
\& Returns : boolean
\& Args    : arg #1 = a Bio::RangeI (eg. a Bio::Map::Position) to compare this
\&                    one to (mandatory)
\&           arg #2 = optional Bio::Map::RelativeI to ask if the Position is less
\&                    in terms of their relative position to the thing described
\&                    by that Relative
.Ve
.Sh "greater_than"
.IX Subsection "greater_than"
.Vb 9
\& Title   : greater_than
\& Usage   : if ($position->greater_than($other_position)) {...}
\& Function: Ask if this Position starts after another ends.
\& Returns : boolean
\& Args    : arg #1 = a Bio::RangeI (eg. a Bio::Map::Position) to compare this
\&                    one to (mandatory)
\&           arg #2 = optional Bio::Map::RelativeI to ask if the Position is
\&                    greater in terms of their relative position to the thing
\&                    described by that Relative
.Ve
.Sh "overlaps"
.IX Subsection "overlaps"
.Vb 10
\&  Title   : overlaps
\&  Usage   : if ($p1->overlaps($p2)) {...}
\&  Function: Tests if $p1 overlaps $p2.
\&  Returns : True if the positions overlap (regardless of map), false otherwise
\&  Args    : arg #1 = a Bio::RangeI (eg. a Bio::Map::Position) to compare this
\&                     one to (mandatory)
\&            arg #2 = optional strand-testing arg ('strong', 'weak', 'ignore')
\&            arg #3 = optional Bio::Map::RelativeI to ask if the Positions
\&                     overlap in terms of their relative position to the thing
\&                     described by that Relative
.Ve
.Sh "contains"
.IX Subsection "contains"
.Vb 11
\&  Title   : contains
\&  Usage   : if ($p1->contains($p2)) {...}
\&  Function: Tests whether $p1 totally contains $p2.
\&  Returns : true if the argument is totally contained within this position
\&            (regardless of map), false otherwise
\&  Args    : arg #1 = a Bio::RangeI (eg. a Bio::Map::Position) to compare this
\&                     one to, or scalar number (mandatory)
\&            arg #2 = optional strand-testing arg ('strong', 'weak', 'ignore')
\&            arg #3 = optional Bio::Map::RelativeI to ask if the Position
\&                     is contained in terms of their relative position to the
\&                     thing described by that Relative
.Ve
.Sh "intersection"
.IX Subsection "intersection"
.Vb 17
\& Title   : intersection
\& Usage   : ($start, $stop, $strand) = $p1->intersection($p2)
\&           ($start, $stop, $strand) = Bio::Map::Position->intersection(\e@positions);
\&           $mappable = $p1->intersection($p2, undef, $relative);
\&           $mappable = Bio::Map::Position->intersection(\e@positions);
\& Function: gives the range that is contained by all ranges
\& Returns : undef if they do not overlap, OR
\&           Bio::Map::Mappable object who's positions are the
\&           cross-map-calculated intersection of the input positions on all the
\&           maps that the input positions belong to, OR, in list context, a three
\&           element array (start, end, strand)
\& Args    : arg #1 = [REQUIRED] a Bio::RangeI (eg. a Bio::Map::Position) to
\&                    compare this one to, or an array ref of Bio::RangeI
\&           arg #2 = optional strand-testing arg ('strong', 'weak', 'ignore')
\&           arg #3 = optional Bio::Map::RelativeI to ask how the Positions
\&                    intersect in terms of their relative position to the thing
\&                    described by that Relative
.Ve
.Sh "union"
.IX Subsection "union"
.Vb 15
\& Title   : union
\& Usage   : ($start, $stop, $strand) = $p1->union($p2);
\&           ($start, $stop, $strand) = Bio::Map::Position->union(@positions);
\&           my $mappable = $p1->union($p2);
\&           my $mappable = Bio::Map::Position->union(@positions);
\& Function: finds the minimal position/range that contains all of the positions
\& Returns : Bio::Map::Mappable object who's positions are the
\&           cross-map-calculated union of the input positions on all the maps
\&           that the input positions belong to, OR, in list context, a three
\&           element array (start, end, strand)
\& Args    : a Bio::Map::PositionI to compare this one to, or a list of such
\&           OR
\&           a single Bio::Map::PositionI or array ref of such AND a
\&           Bio::Map::RelativeI to ask for the Position's union in terms of their
\&           relative position to the thing described by that Relative
.Ve
.Sh "overlap_extent"
.IX Subsection "overlap_extent"
.Vb 9
\& Title   : overlap_extent
\& Usage   : ($a_unique,$common,$b_unique) = $a->overlap_extent($b)
\& Function: Provides actual amount of overlap between two different
\&           positions
\& Example :
\& Returns : array of values containing the length unique to the calling 
\&           position, the length common to both, and the length unique to 
\&           the argument position
\& Args    : a position
.Ve
.Sh "disconnected_ranges"
.IX Subsection "disconnected_ranges"
.Vb 11
\& Title   : disconnected_ranges
\& Usage   : my @disc_ranges = Bio::Map::Position->disconnected_ranges(@ranges);
\& Function: Creates the minimal set of positions such that each input position is
\&           fully contained by at least one output position, and none of the
\&           output positions overlap.
\& Returns : Bio::Map::Mappable with the calculated disconnected ranges
\& Args    : a Bio::Map::PositionI to compare this one to, or a list of such,
\&           OR
\&           a single Bio::Map::PositionI or array ref of such AND a
\&           Bio::Map::RelativeI to consider all Position's co-ordinates in terms
\&           of their relative position to the thing described by that Relative
.Ve
