.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::EUtilities 3"
.TH Bio::DB::EUtilities 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::DB::EUtilities \- interface for handling web queries and data
retrieval from Entrez Utilities at NCBI.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use Bio::DB::EUtilities;
.PP
.Vb 4
\&  my $esearch = Bio::DB::EUtilities->new(-eutil      => 'esearch',
\&                                         -db         => 'pubmed',
\&                                         -term       => 'hutP',
\&                                         -usehistory => 'y');
.Ve
.PP
.Vb 1
\&  $esearch->get_response; # parse the response, fetch a cookie
.Ve
.PP
.Vb 5
\&  my $elink = Bio::DB::EUtilities->new(-eutil        => 'elink',
\&                                       -db           => 'protein',
\&                                       -dbfrom       => 'pubmed',
\&                                       -cookie       => $esearch->next_cookie,
\&                                       -cmd          => 'neighbor_history');
.Ve
.PP
.Vb 1
\&  $elink->get_response; # parse the response, fetch the next cookie
.Ve
.PP
.Vb 3
\&  my $efetch = Bio::DB::EUtilities->new(-cookie       => $elink->next_cookie,
\&                                        -retmax       => 10,
\&                                        -rettype      => 'fasta');
.Ve
.PP
.Vb 1
\&  print $efetch->get_response->content;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1WARNING:\s0 Please do \fB\s-1NOT\s0\fR spam the Entrez web server with multiple requests.
\&\s-1NCBI\s0 offers Batch Entrez for this purpose, now accessible here via epost!
.PP
This is a test interface to the Entrez Utilities at \s-1NCBI\s0.  The main purpose of this
is to enable access to all of the \s-1NCBI\s0 databases available through Entrez and
allow for more complex queries.  It is likely that the \s-1API\s0 for this module as
well as the documentation will change dramatically over time. So, novice users
and neophytes beware!
.PP
The experimental base class is Bio::DB::GenericWebDBI,
which as the name implies enables access to any web database which will accept
parameters.  This was originally born from an idea to replace
WebDBSeqI/NCBIHelper with a more general web database accession tool so one
could access sequence information, taxonomy, \s-1SNP\s0, PubMed, and so on.
However, this may ultimately prove to be better used as a replacement for
LWP::UserAgent when ccessing NCBI-related web tools
(Entrez Utilitites, or EUtilities).  Using the base class GenericWebDBI,
one could also build web interfaces to other databases to access anything
via \s-1CGI\s0 parameters.
.PP
Currently, you can access any database available through the \s-1NCBI\s0 interface:
.PP
.Vb 1
\&  http://eutils.ncbi.nlm.nih.gov/
.Ve
.PP
At this point, Bio::DB::EUtilities uses the EUtilities plugin modules somewhat
like Bio::SeqIO.  So, one would call the particular EUtility (epost, efetch,
and so forth) upon instantiating the object using a set of parameters:
.PP
.Vb 4
\&  my $esearch = Bio::DB::EUtilities->new(-eutil      => 'esearch',
\&                                         -db         => 'pubmed',
\&                                         -term       => 'dihydroorotase',
\&                                         -usehistory => 'y');
.Ve
.PP
The default EUtility (when \f(CW\*(C`eutil\*(C'\fR is left out) is 'efetch'.  For specifics on
each EUtility, see their respective \s-1POD\s0 (**these are incomplete**) or
the \s-1NCBI\s0 Entrez Utilities page:
.PP
.Vb 1
\&  http://eutils.ncbi.nlm.nih.gov/entrez/query/static/eutils_help.html
.Ve
.PP
At this time, retrieving the response is accomplished by using the method
get_response (which also parses for cookies and other information, see below).
This method returns an HTTP::Response object.  The raw data is accessed by using
the object method \f(CW\*(C`content\*(C'\fR, like so:
.PP
.Vb 3
\&  my $efetch = Bio::DB::EUtilities->new(-cookie       => $elink->next_cookie,
\&                                        -retmax       => 10,
\&                                        -rettype      => 'fasta');
.Ve
.PP
.Vb 1
\&  print $efetch->get_response->content;
.Ve
.PP
Based on this, if one wanted to retrieve sequences or other raw data
but was not interested in directly using Bio* objects (such as if
genome sequences were to be retrieved) one could do so by using the
proper EUtility object(s) and query(ies) and get the raw response back
from \s-1NCBI\s0 through 'efetch'.  
.PP
A great deal of the documentation here will likely end up in the form
of a \s-1HOWTO\s0 at some future point, focusing on getting data into Bioperl
objects.
.Sh "Cookies"
.IX Subsection "Cookies"
Some EUtilities (\f(CW\*(C`epost\*(C'\fR, \f(CW\*(C`esearch\*(C'\fR, or \f(CW\*(C`elink\*(C'\fR) retain information on
the \s-1NCBI\s0 server under certain settings.  This information can be retrieved by
using a \fBcookie\fR.  Here, the idea of the 'cookie' is similar to the
\&'cookie' set on a your computer when browsing the Web.  \s-1XML\s0 data returned
by these EUtilities, when applicable, is parsed for the cookie information
(the 'WebEnv' and 'query_key' tags to be specific)  The information along
with other identifying data, such as the calling eutility, description
of query, etc.) is stored as a
Bio::DB::EUtilities::Cookie object
in an internal queue.  These can be retrieved one at a time by using
the next_cookie method or all at once in an array using get_all_cookies.
Each cookie can then be 'fed', one at a time, to another EUtility object,
thus enabling chained queries as demonstrated in the synopsis.
.PP
For more information, see the \s-1POD\s0 documentation for
Bio::DB::EUtilities::Cookie.
.SH "TODO"
.IX Header "TODO"
Resetting internal parameters is planned so one could feasibly reuse
the objects once instantiated, such as if one were to use this as a
replacement for LWP::UserAgent when retrieving responses i.e. when
using many of the Bio::DB* NCBI-related modules.
.PP
File and filehandle support to be added.
.PP
Switch over \s-1XML\s0 parsing in most EUtilities to \s-1XML::SAX\s0 (currently
use XML::Simple)
.PP
Any feedback is welcome.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the 
evolution of this and other Bioperl modules. Send
your comments and suggestions preferably to one
of the Bioperl mailing lists. Your participation
is much appreciated.
.PP
.Vb 2
\&  bioperl-l@lists.open-bio.org               - General discussion
\&  http://www.bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to
help us keep track the bugs and their resolution.
Bug reports can be submitted via the web.
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Email cjfields at uiuc dot edu
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the
object methods. Internal methods are usually
preceded with a _
.Sh "add_cookie"
.IX Subsection "add_cookie"
.Vb 5
\& Title   : cookie
\& Usage   : $db->add_cookie($cookie)
\& Function: adds an NCBI query cookie to the internal cookie queue
\& Returns : none
\& Args    : a Bio::DB::EUtilities::Cookie object
.Ve
.Sh "next_cookie"
.IX Subsection "next_cookie"
.Vb 5
\& Title   : next_cookie
\& Usage   : $cookie = $db->next_cookie
\& Function: return a cookie from the internal cookie queue
\& Returns : a Bio::DB::EUtilities::Cookie object
\& Args    : none
.Ve
.Sh "reset_cookies"
.IX Subsection "reset_cookies"
.Vb 5
\& Title   : reset_cookies
\& Usage   : $db->reset_cookies
\& Function: resets (empties) the internal cookie queue
\& Returns : none
\& Args    : none
.Ve
.Sh "get_all_cookies"
.IX Subsection "get_all_cookies"
.Vb 6
\& Title   : get_all_cookies
\& Usage   : @cookies = $db->get_all_cookies
\& Function: retrieves all cookies from the internal cookie queue; this leaves
\&           the cookies in the queue intact 
\& Returns : array of cookies (if wantarray) of first cookie
\& Args    : none
.Ve
.Sh "get_cookie_count"
.IX Subsection "get_cookie_count"
.Vb 5
\& Title   : get_cookie_count
\& Usage   : $ct = $db->get_cookie_count
\& Function: returns # cookies in internal queue
\& Returns : integer 
\& Args    : none
.Ve
.Sh "rewind_cookies"
.IX Subsection "rewind_cookies"
.Vb 5
\& Title   : rewind_cookies
\& Usage   : $elink->rewind_cookies;
\& Function: resets cookie index to 0 (starts over)
\& Returns : None
\& Args    : None
.Ve
.Sh "keep_cookies"
.IX Subsection "keep_cookies"
.Vb 6
\& Title   : keep_cookies
\& Usage   : $db->keep_cookie(1)
\& Function: Flag to retain the internal cookie queue;
\&           this is normally emptied upon using get_response
\& Returns : none
\& Args    : Boolean - value that evaluates to TRUE or FALSE
.Ve
.Sh "parse_response"
.IX Subsection "parse_response"
.Vb 6
\& Title   : parse_response
\& Usage   : $db->_parse_response($content)
\& Function: parse out response for cookies and other goodies
\& Returns : empty
\& Args    : none
\& Throws  : Not implemented (implemented in plugin classes)
.Ve
.Sh "get_response"
.IX Subsection "get_response"
.Vb 5
\& Title   : get_response
\& Usage   : $db->get_response($content)
\& Function: main method to submit request and retrieves a response
\& Returns : HTTP::Response object
\& Args    : None
.Ve
.Sh "get_ids"
.IX Subsection "get_ids"
.Vb 9
\& Title   : get_ids
\& Usage   : $count = $elink->get_ids($db); # array ref of specific db ids
\&           @ids   = $esearch->get_ids(); # array
\&           $ids   = $esearch->get_ids(); # array ref
\& Function: returns an array or array ref of unique IDs.
\& Returns : array or array ref of ids 
\& Args    : Optional : database string if elink used (required arg if searching
\&           multiple databases for related IDs)
\&           Currently implemented only for elink object with single linksets
.Ve
.Sh "delay_policy"
.IX Subsection "delay_policy"
.Vb 5
\&  Title   : delay_policy
\&  Usage   : $secs = $self->delay_policy
\&  Function: return number of seconds to delay between calls to remote db
\&  Returns : number of seconds to delay
\&  Args    : none
.Ve
.PP
.Vb 2
\&  NOTE: NCBI requests a delay of 3 seconds between requests.  This method
\&        implements that policy.
.Ve
.Sh "get_entrezdbs"
.IX Subsection "get_entrezdbs"
.Vb 5
\&  Title   : get_entrezdbs
\&  Usage   : @dbs = $self->get_entrezdbs;
\&  Function: return list of all Entrez databases; convenience method
\&  Returns : array or array ref (based on wantarray) of databases 
\&  Args    : none
.Ve
.SH "Private methods"
.IX Header "Private methods"
.Sh "_eutil"
.IX Subsection "_eutil"
.Vb 5
\& Title   : _eutil
\& Usage   : $db->_eutil;
\& Function: sets eutil 
\& Returns : eutil
\& Args    : eutil
.Ve
