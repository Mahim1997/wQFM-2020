.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Ontology::OBOEngine 3"
.TH Bio::Ontology::OBOEngine 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Ontology::OBOEngine \- An Ontology Engine for OBO style flat file
format from the Gene Ontology Consortium
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Bio::Ontology::OBOEngine;
.Ve
.PP
.Vb 2
\&  my $parser = Bio::Ontology::OBOEngine->new
\&        ( -file => "gene_ontology.obo" );
.Ve
.PP
.Vb 1
\&  my $engine = $parser->parse();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Needs Graph.pm from \s-1CPAN\s0.
.PP
This module replaces SimpleGOEngine.pm, which is deprecated.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to the
Bioperl mailing lists  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via
the web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Sohel Merchant
.PP
Email: s\-merchant@northwestern.edu
.PP
Address:
.PP
.Vb 5
\&  Northwestern University
\&  Center for Genetic Medicine (CGM), dictyBase
\&  Suite 1206,
\&  676 St. Clair st
\&  Chicago IL 60611
.Ve
.Sh "\s-1CONTRIBUTOR\s0"
.IX Subsection "CONTRIBUTOR"
.Vb 2
\& Hilmar Lapp, hlapp at gmx.net
\& Chris Mungall,   cjm at fruitfly.org
.Ve
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.Sh "new"
.IX Subsection "new"
.Vb 5
\& Title   : new
\& Usage   : $engine = Bio::Ontology::OBOEngine->new()
\& Function: Creates a new OBOEngine
\& Returns : A new OBOEngine object
\& Args    :
.Ve
.Sh "init"
.IX Subsection "init"
.Vb 5
\& Title   : init()
\& Usage   : $engine->init();
\& Function: Initializes this Engine.
\& Returns :
\& Args    :
.Ve
.Sh "is_a_relationship"
.IX Subsection "is_a_relationship"
.Vb 6
\& Title   : is_a_relationship()
\& Usage   : $IS_A = $engine->is_a_relationship();
\& Function: Returns a Bio::Ontology::RelationshipType object for "is-a"
\&           relationships
\& Returns : Bio::Ontology::RelationshipType set to "IS_A"
\& Args    :
.Ve
.Sh "part_of_relationship"
.IX Subsection "part_of_relationship"
.Vb 6
\& Title   : part_of_relationship()
\& Usage   : $PART_OF = $engine->part_of_relationship();
\& Function: Returns a Bio::Ontology::RelationshipType object for "part-of"
\&           relationships
\& Returns : Bio::Ontology::RelationshipType set to "PART_OF"
\& Args    :
.Ve
.Sh "related_to_relationship"
.IX Subsection "related_to_relationship"
.Vb 6
\& Title   : related_to_relationship()
\& Usage   : $RELATED_TO = $engine->related_to_relationship();
\& Function: Returns a Bio::Ontology::RelationshipType object for "related-to"
\&           relationships
\& Returns : Bio::Ontology::RelationshipType set to "RELATED_TO"
\& Args    :
.Ve
.Sh "add_term"
.IX Subsection "add_term"
.Vb 6
\& Title   : add_term
\& Usage   : $engine->add_term( $term_obj );
\& Function: Adds a Bio::Ontology::TermI to this engine
\& Returns : true if the term was added and false otherwise (e.g., if the
\&           term already existed in the ontology engine)
\& Args    : Bio::Ontology::TermI
.Ve
.Sh "has_term"
.IX Subsection "has_term"
.Vb 7
\& Title   : has_term
\& Usage   : $engine->has_term( $term );
\& Function: Checks whether this engine contains a particular term
\& Returns : true or false
\& Args    : Bio::Ontology::TermI
\&           or
\&           Term identifier (e.g. "GO:0012345")
.Ve
.Sh "add_relationship_type"
.IX Subsection "add_relationship_type"
.Vb 7
\& Title   : add_relationship_type
\& Usage   : $engine->add_relationship_type( $type_name, $ont );
\& Function: Adds a new relationship type to the engine.  Use
\&           get_relationship_type($type_name) to retrieve.
\& Returns : true if successfully added, false otherwise
\& Args    : relationship type name to add (scalar)
\&           ontology to which to assign the relationship type
.Ve
.Sh "get_relationship_type"
.IX Subsection "get_relationship_type"
.Vb 6
\& Title   : get_relationship_type
\& Usage   : $engine->get_relationship_type( $type_name );
\& Function: Gets a Bio::Ontology::RelationshipI object corresponding
\&           to $type_name
\& Returns : a Bio::Ontology::RelationshipI object
\& Args    :
.Ve
.Sh "add_relationship"
.IX Subsection "add_relationship"
.Vb 9
\& Title   : add_relationship
\& Usage   : $engine->add_relationship( $relationship );
\&           $engine->add_relatioship( $subject_term, $predicate_term,
\&                                     $object_term, $ontology );
\&           $engine->add_relatioship( $subject_id, $predicate_id,
\&                                     $object_id, $ontology);
\& Function: Adds a relationship to this engine
\& Returns : true if successfully added, false otherwise
\& Args    : The relationship in one of three ways:
.Ve
.PP
.Vb 2
\&             a) subject (or child) term id, Bio::Ontology::TermI
\&                (rel.type), object (or parent) term id, ontology
.Ve
.PP
.Vb 1
\&           or
.Ve
.PP
.Vb 3
\&             b) subject Bio::Ontology::TermI, predicate
\&                Bio::Ontology::TermI (rel.type), object
\&                Bio::Ontology::TermI, ontology
.Ve
.PP
.Vb 1
\&           or
.Ve
.PP
.Vb 1
\&             c) Bio::Ontology::RelationshipI-compliant object
.Ve
.Sh "get_relationships"
.IX Subsection "get_relationships"
.Vb 8
\& Title   : get_relationships
\& Usage   : $engine->get_relationships( $term );
\& Function: Returns all relationships of a term, or all relationships in
\&           the graph if no term is specified.
\& Returns : Relationship
\& Args    : term id
\&           or
\&           Bio::Ontology::TermI
.Ve
.Sh "get_all_relationships"
.IX Subsection "get_all_relationships"
.Vb 5
\& Title   : get_all_relationships
\& Usage   : @rels = $engine->get_all_relationships();
\& Function: Returns all relationships in the graph.
\& Returns : Relationship
\& Args    :
.Ve
.Sh "get_predicate_terms"
.IX Subsection "get_predicate_terms"
.Vb 5
\& Title   : get_predicate_terms
\& Usage   : $engine->get_predicate_terms();
\& Function: Returns the types of relationships this engine contains
\& Returns : Bio::Ontology::RelationshipType
\& Args    :
.Ve
.Sh "get_child_terms"
.IX Subsection "get_child_terms"
.Vb 8
\& Title   : get_child_terms
\& Usage   : $engine->get_child_terms( $term_obj, @rel_types );
\&           $engine->get_child_terms( $term_id, @rel_types );
\& Function: Returns the children of this term
\& Returns : Bio::Ontology::TermI
\& Args    : Bio::Ontology::TermI, Bio::Ontology::RelationshipType
\&           or
\&           term id, Bio::Ontology::RelationshipType
.Ve
.PP
.Vb 2
\&           if NO Bio::Ontology::RelationshipType is indicated: children
\&           of ALL types are returned
.Ve
.Sh "get_descendant_terms"
.IX Subsection "get_descendant_terms"
.Vb 8
\& Title   : get_descendant_terms
\& Usage   : $engine->get_descendant_terms( $term_obj, @rel_types );
\&           $engine->get_descendant_terms( $term_id, @rel_types );
\& Function: Returns the descendants of this term
\& Returns : Bio::Ontology::TermI
\& Args    : Bio::Ontology::TermI, Bio::Ontology::RelationshipType
\&           or
\&           term id, Bio::Ontology::RelationshipType
.Ve
.PP
.Vb 2
\&           if NO Bio::Ontology::RelationshipType is indicated:
\&           descendants of ALL types are returned
.Ve
.Sh "get_parent_terms"
.IX Subsection "get_parent_terms"
.Vb 8
\& Title   : get_parent_terms
\& Usage   : $engine->get_parent_terms( $term_obj, @rel_types );
\&           $engine->get_parent_terms( $term_id, @rel_types );
\& Function: Returns the parents of this term
\& Returns : Bio::Ontology::TermI
\& Args    : Bio::Ontology::TermI, Bio::Ontology::RelationshipType
\&           or
\&           term id, Bio::Ontology::RelationshipType
.Ve
.PP
.Vb 2
\&           if NO Bio::Ontology::RelationshipType is indicated:
\&           parents of ALL types are returned
.Ve
.Sh "get_ancestor_terms"
.IX Subsection "get_ancestor_terms"
.Vb 8
\& Title   : get_ancestor_terms
\& Usage   : $engine->get_ancestor_terms( $term_obj, @rel_types );
\&           $engine->get_ancestor_terms( $term_id, @rel_types );
\& Function: Returns the ancestors of this term
\& Returns : Bio::Ontology::TermI
\& Args    : Bio::Ontology::TermI, Bio::Ontology::RelationshipType
\&           or
\&           term id, Bio::Ontology::RelationshipType
.Ve
.PP
.Vb 2
\&           if NO Bio::Ontology::RelationshipType is indicated:
\&           ancestors of ALL types are returned
.Ve
.Sh "get_leaf_terms"
.IX Subsection "get_leaf_terms"
.Vb 5
\& Title   : get_leaf_terms
\& Usage   : $engine->get_leaf_terms();
\& Function: Returns the leaf terms
\& Returns : Bio::Ontology::TermI
\& Args    :
.Ve
.Sh "\fIget_root_terms()\fP"
.IX Subsection "get_root_terms()"
.Vb 5
\& Title   : get_root_terms
\& Usage   : $engine->get_root_terms();
\& Function: Returns the root terms
\& Returns : Bio::Ontology::TermI
\& Args    :
.Ve
.Sh "get_terms"
.IX Subsection "get_terms"
.Vb 6
\& Title   : get_terms
\& Usage   : @terms = $engine->get_terms( "GO:1234567", "GO:2234567" );
\& Function: Returns term objects with given identifiers
\& Returns : Bio::Ontology::TermI, or the term corresponding to the
\&           first identifier if called in scalar context
\& Args    : term ids
.Ve
.Sh "get_all_terms"
.IX Subsection "get_all_terms"
.Vb 5
\& Title   : get_all_terms
\& Usage   : $engine->get_all_terms();
\& Function: Returns all terms in this engine
\& Returns : Bio::Ontology::TermI
\& Args    :
.Ve
.Sh "find_terms"
.IX Subsection "find_terms"
.Vb 3
\& Title   : find_terms
\& Usage   : ($term) = $oe->find_terms(-identifier => "SO:0000263");
\& Function: Find term instances matching queries for their attributes.
.Ve
.PP
.Vb 2
\&           This implementation can efficiently resolve queries by
\&           identifier.
.Ve
.PP
.Vb 4
\& Example :
\& Returns : an array of zero or more Bio::Ontology::TermI objects
\& Args    : Named parameters. The following parameters should be recognized
\&           by any implementations:
.Ve
.PP
.Vb 2
\&              -identifier    query by the given identifier
\&              -name          query by the given name
.Ve
.Sh "find_identically_named_terms"
.IX Subsection "find_identically_named_terms"
.Vb 7
\& Title   : find_identically_named_terms
\& Usage   : ($term) = $oe->find_identically_named_terms($term0);
\& Function: Find term instances where names match the query term
\&           name exactly
\& Example :
\& Returns : an array of zero or more Bio::Ontology::TermI objects
\& Args    : a Bio::Ontology::TermI object
.Ve
.Sh "find_identical_terms"
.IX Subsection "find_identical_terms"
.Vb 7
\& Title   : find_identical_terms
\& Usage   : ($term) = $oe->find_identical_terms($term0);
\& Function: Find term instances where name or synonym
\&           matches the query exactly
\& Example :
\& Returns : an array of zero or more Bio::Ontology::TermI objects
\& Args    : a Bio::Ontology::TermI object
.Ve
.Sh "find_similar_terms"
.IX Subsection "find_similar_terms"
.Vb 7
\& Title   : find_similar_terms
\& Usage   : ($term) = $oe->find_similar_terms($term0);
\& Function: Find term instances where name or synonym, or part of one,
\&           matches the query.
\& Example :
\& Returns : an array of zero or more Bio::Ontology::TermI objects
\& Args    : a Bio::Ontology::TermI object
.Ve
.Sh "relationship_factory"
.IX Subsection "relationship_factory"
.Vb 4
\& Title   : relationship_factory
\& Usage   : $fact = $obj->relationship_factory()
\& Function: Get/set the object factory to be used when relationship
\&           objects are created by the implementation on-the-fly.
.Ve
.PP
.Vb 4
\& Example :
\& Returns : value of relationship_factory (a Bio::Factory::ObjectFactoryI
\&           compliant object)
\& Args    : on set, a Bio::Factory::ObjectFactoryI compliant object
.Ve
.Sh "term_factory"
.IX Subsection "term_factory"
.Vb 4
\& Title   : term_factory
\& Usage   : $fact = $obj->term_factory()
\& Function: Get/set the object factory to be used when term objects are
\&           created by the implementation on-the-fly.
.Ve
.PP
.Vb 3
\&           Note that this ontology engine implementation does not
\&           create term objects on the fly, and therefore setting this
\&           attribute is meaningless.
.Ve
.PP
.Vb 4
\& Example :
\& Returns : value of term_factory (a Bio::Factory::ObjectFactoryI
\&           compliant object)
\& Args    : on set, a Bio::Factory::ObjectFactoryI compliant object
.Ve
.Sh "graph"
.IX Subsection "graph"
.Vb 5
\& Title   : graph()
\& Usage   : $engine->graph();
\& Function: Returns the Graph this engine is based on
\& Returns : Graph
\& Args    :
.Ve
