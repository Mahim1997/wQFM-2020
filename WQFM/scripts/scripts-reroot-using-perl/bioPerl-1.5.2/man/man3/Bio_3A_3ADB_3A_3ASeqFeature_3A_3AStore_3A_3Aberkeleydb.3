.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::SeqFeature::Store::berkeleydb 3"
.TH Bio::DB::SeqFeature::Store::berkeleydb 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::DB::SeqFeature::Store::berkeleydb \-\- Storage and retrieval of sequence annotation data in Berkeleydb files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Bio::DB::SeqFeature::Store;
.Ve
.PP
.Vb 4
\&  # Create a database from the feature files located in /home/fly4.3 and store
\&  # the database index in the same directory:
\&  $db =  Bio::DB::SeqFeature::Store->new( -adaptor => 'berkeleydb',
\&                                          -dir     => '/home/fly4.3');
.Ve
.PP
.Vb 5
\&  # Create a database that will monitor the files in /home/fly4.3, but store
\&  # the indexes in /var/databases/fly4.3
\&  $db      = Bio::DB::SeqFeature::Store->new( -adaptor    => 'berkeleydb',
\&                                              -dsn        => '/var/databases/fly4.3',
\&                                              -dir        => '/home/fly4.3');
.Ve
.PP
.Vb 4
\&  # Create a feature database from scratch
\&  $db     = Bio::DB::SeqFeature::Store->new( -adaptor => 'berkeleydb',
\&                                             -dsn     => '/var/databases/fly4.3',
\&                                             -create  => 1);
.Ve
.PP
.Vb 2
\&  # get a feature from somewhere
\&  my $feature = Bio::SeqFeature::Generic->new(...);
.Ve
.PP
.Vb 2
\&  # store it
\&  $db->store($feature) or die "Couldn't store!";
.Ve
.PP
.Vb 3
\&  # primary ID of the feature is changed to indicate its primary ID
\&  # in the database...
\&  my $id = $feature->primary_id;
.Ve
.PP
.Vb 2
\&  # get the feature back out
\&  my $f  = $db->fetch($id);
.Ve
.PP
.Vb 3
\&  # change the feature and update it
\&  $f->start(100);
\&  $db->update($f) or $self->throw("Couldn't update!");
.Ve
.PP
.Vb 5
\&  # use the GFF3 loader to do a bulk write:
\&  my $loader = Bio::DB::SeqFeature::Store::GFF3Loader->new(-store   => $db,
\&                                                           -verbose => 1,
\&                                                           -fast    => 1);
\&  $loader->load('/home/fly4.3/dmel-all.gff');
.Ve
.PP
.Vb 3
\&  # searching...
\&  # ...by id
\&  my @features = $db->fetch_many(@list_of_ids);
.Ve
.PP
.Vb 2
\&  # ...by name
\&  @features = $db->get_features_by_name('ZK909');
.Ve
.PP
.Vb 2
\&  # ...by alias
\&  @features = $db->get_features_by_alias('sma-3');
.Ve
.PP
.Vb 2
\&  # ...by type
\&  @features = $db->get_features_by_type('gene');
.Ve
.PP
.Vb 2
\&  # ...by location
\&  @features = $db->get_features_by_location(-seq_id=>'Chr1',-start=>4000,-end=>600000);
.Ve
.PP
.Vb 2
\&  # ...by attribute
\&  @features = $db->get_features_by_attribute({description => 'protein kinase'})
.Ve
.PP
.Vb 2
\&  # ...by the GFF "Note" field
\&  @result_list = $db->search_notes('kinase');
.Ve
.PP
.Vb 7
\&  # ...by arbitrary combinations of selectors
\&  @features = $db->features(-name => $name,
\&                            -type => $types,
\&                            -seq_id => $seqid,
\&                            -start  => $start,
\&                            -end    => $end,
\&                            -attributes => $attributes);
.Ve
.PP
.Vb 7
\&  # ...using an iterator
\&  my $iterator = $db->get_seq_stream(-name => $name,
\&                                     -type => $types,
\&                                     -seq_id => $seqid,
\&                                     -start  => $start,
\&                                     -end    => $end,
\&                                     -attributes => $attributes);
.Ve
.PP
.Vb 3
\&  while (my $feature = $iterator->next_seq) {
\&    # do something with the feature
\&  }
.Ve
.PP
.Vb 3
\&  # ...limiting the search to a particular region
\&  my $segment  = $db->segment('Chr1',5000=>6000);
\&  my @features = $segment->features(-type=>['mRNA','match']);
.Ve
.PP
.Vb 4
\&  # getting & storing sequence information
\&  # Warning: this returns a string, and not a PrimarySeq object
\&  $db->insert_sequence('Chr1','GATCCCCCGGGATTCCAAAA...');
\&  my $sequence = $db->fetch_sequence('Chr1',5000=>6000);
.Ve
.PP
.Vb 5
\&  # create a new feature in the database
\&  my $feature = $db->new_feature(-primary_tag => 'mRNA',
\&                                 -seq_id      => 'chr3',
\&                                 -start      => 10000,
\&                                 -end        => 11000);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::DB::SeqFeature::Store::berkeleydb is the Berkeleydb adaptor for
Bio::DB::SeqFeature::Store. You will not create it directly, but
instead use Bio::DB::SeqFeature::Store\->\fInew()\fR to do so.
.PP
See Bio::DB::SeqFeature::Store for complete usage instructions.
.Sh "Using the berkeleydb adaptor"
.IX Subsection "Using the berkeleydb adaptor"
The Berkeley database consists of a series of Berkeleydb index files,
and a couple of special purpose indexes. You can create the index
files from scratch by creating a new database and calling
\&\fInew_feature()\fR repeatedly, you can create the database and then bulk
populate it using the \s-1GFF3\s0 loader, or you can monitor a directory of
preexisting \s-1GFF3\s0 and \s-1FASTA\s0 files and rebuild the indexes whenever one
or more of the fiels changes. The last mode is probably the most
convenient.
.IP "The \fInew()\fR constructor" 4
.IX Item "The new() constructor"
The \fInew()\fR constructor method all the arguments recognized by
Bio::DB::SeqFeature::Store, and a few additional ones. 
.Sp
Standard arguments:
.Sp
.Vb 2
\& Name               Value
\& ----               -----
.Ve
.Sp
.Vb 1
\& -adaptor           The name of the Adaptor class (default DBI::mysql)
.Ve
.Sp
.Vb 1
\& -serializer        The name of the serializer class (default Storable)
.Ve
.Sp
.Vb 2
\& -index_subfeatures Whether or not to make subfeatures searchable
\&                    (default true)
.Ve
.Sp
.Vb 1
\& -cache             Activate LRU caching feature -- size of cache
.Ve
.Sp
.Vb 2
\& -compress          Compresses features before storing them in database
\&                    using Compress::Zlib
.Ve
.Sp
Adaptor-specific arguments
.Sp
.Vb 2
\& Name               Value
\& ----               -----
.Ve
.Sp
.Vb 1
\& -dsn               Where the index files are stored
.Ve
.Sp
.Vb 1
\& -dir               Where the source (GFF3, FASTA) files are stored
.Ve
.Sp
.Vb 1
\& -autoindex         An alias for -dir.
.Ve
.Sp
.Vb 1
\& -write             Pass true to open the index files for writing.
.Ve
.Sp
.Vb 2
\& -create            Pass true to create the index files if they don't exist
\&                    (implies -write=>1)
.Ve
.Sp
.Vb 2
\& -temp              Pass true to create temporary index files that will
\&                    be deleted once the script exits.
.Ve
.Sp
Examples:
.Sp
To create an empty database which will be populated using calls to
\&\fIstore()\fR or \fInew_feature()\fR, or which will be bulk-loaded using the \s-1GFF3\s0
loader:
.Sp
.Vb 3
\&  $db     = Bio::DB::SeqFeature::Store->new( -adaptor => 'berkeleydb',
\&                                             -dsn     => '/var/databases/fly4.3',
\&                                             -create  => 1);
.Ve
.Sp
To open a preexisting database in read-only mode:
.Sp
.Vb 2
\&  $db     = Bio::DB::SeqFeature::Store->new( -adaptor => 'berkeleydb',
\&                                             -dsn     => '/var/databases/fly4.3');
.Ve
.Sp
To open a preexisting database in read/write (update) mode:
.Sp
.Vb 3
\&  $db     = Bio::DB::SeqFeature::Store->new( -adaptor => 'berkeleydb',
\&                                             -dsn     => '/var/databases/fly4.3',
\&                                             -write   => 1);
.Ve
.Sp
To monitor a set of \s-1GFF3\s0 and \s-1FASTA\s0 files located in a directory and
create/update the database indexes as needed. The indexes will be
stored in a new subdirectory named \*(L"indexes\*(R":
.Sp
.Vb 2
\&  $db     = Bio::DB::SeqFeature::Store->new( -adaptor => 'berkeleydb',
\&                                             -dir     => '/var/databases/fly4.3');
.Ve
.Sp
As above, but store the source files and index files in separate directories:
.Sp
.Vb 3
\&  $db     = Bio::DB::SeqFeature::Store->new( -adaptor => 'berkeleydb',
\&                                             -dsn     => '/var/databases/fly4.3',
\&                                             -dir     => '/home/gff3_files/fly4.3');
.Ve
.Sp
\&\fB\-autoindex\fR is an alias for \fB\-dir\fR.
.PP
See Bio::DB::SeqFeature::Store for all the access methods supported
by this adaptor. The various methods for storing and updating features
and sequences into the database are supported, but there is no
locking. If two processes try to update the same database
simultaneously, the database will likely become corrupted.
.SH "BUGS"
.IX Header "BUGS"
This is an early version, so there are certainly some bugs. Please
use the BioPerl bug tracking system to report bugs.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
bioperl,
Bio::DB::SeqFeature,
Bio::DB::SeqFeature::Store,
Bio::DB::SeqFeature::GFF3Loader,
Bio::DB::SeqFeature::Segment,
Bio::DB::SeqFeature::Store::memory,
Bio::DB::SeqFeature::Store::DBI::mysql,
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln Stein <lstein@cshl.org>.
.PP
Copyright (c) 2006 Cold Spring Harbor Laboratory.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
