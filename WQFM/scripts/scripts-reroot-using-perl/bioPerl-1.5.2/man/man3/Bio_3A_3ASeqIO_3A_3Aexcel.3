.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::SeqIO::excel 3"
.TH Bio::SeqIO::excel 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::SeqIO::excel \- sequence input/output stream from a
                    MSExcel\-formatted table
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  #It is probably best not to use this object directly, but
\&  #rather go through the SeqIO handler system. Go:
.Ve
.PP
.Vb 1
\&  $stream = Bio::SeqIO->new(-file => $filename, -format => 'excel');
.Ve
.PP
.Vb 3
\&  while ( my $seq = $stream->next_seq() ) {
\&        # do something with $seq
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class transforms records in a \s-1MS\s0 Excel workbook file into
Bio::Seq objects. It is derived from the table format module and
merely defines additional properties and overrides the way to get data
from the file and advance to the next record.
.PP
The module permits specifying which columns hold which type of
annotation. The semantics of certain attributes, if present, are
pre\-defined, e.g., accession number and sequence. Additional
attributes may be added to the annotation bundle. See
Bio::SeqIO::table for a complete list of parameters and
capabilities.
.PP
You may also specify the worksheet from which to obtain the data, and
after finishing one worksheet you may change the name to keep reading
from another worksheet (in the same file).
.PP
This module depends on Spreadsheet::ParseExcel to parse the underlying
Excel file.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.
.PP
Bug reports can be submitted via email or the web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Hilmar Lapp"
.IX Header "AUTHOR - Hilmar Lapp"
Email hlapp at gmx.net
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.Sh "new"
.IX Subsection "new"
.Vb 4
\& Title   : new
\& Usage   : $stream = Bio::SeqIO->new(-file => $filename, -format => 'excel')
\& Function: Returns a new seqstream
\& Returns : A Bio::SeqIO stream for a MS Excel format
.Ve
.PP
.Vb 3
\& Args    : Supports the same named parameters as Bio::SeqIO::table,
\&           except -delim, which obviously does not apply to a binary
\&           format. In addition, the following parameters are supported.
.Ve
.PP
.Vb 3
\&             -worksheet the name of the worksheet holding the table;
\&                        if unspecified the first worksheet will be
\&                        used
.Ve
.Sh "worksheet"
.IX Subsection "worksheet"
.Vb 4
\& Title   : worksheet
\& Usage   : $obj->worksheet($newval)
\& Function: Get/set the name of the worksheet holding the table. The
\&           worksheet name may also be a numeric index.
.Ve
.PP
.Vb 3
\&           You may change the value during parsing at any time in
\&           order to start reading from a different worksheet (in the
\&           same file).
.Ve
.PP
.Vb 3
\& Example :
\& Returns : value of worksheet (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.Sh "close"
.IX Subsection "close"
.Vb 3
\& Title   : close
\& Usage   :
\& Function: Close and/or release the resources used by this parser instance.
.Ve
.PP
.Vb 2
\&           We override this here in order to free up the worksheet and
\&           other related objects.
.Ve
.PP
.Vb 3
\& Example :
\& Returns :
\& Args    :
.Ve
.SH "Internal methods"
.IX Header "Internal methods"
All methods with a leading underscore are not meant to be part of the
\&'official' \s-1API\s0. They are for use by this module only, consider them
private unless you are a developer trying to modify this module.
.Sh "_worksheet"
.IX Subsection "_worksheet"
.Vb 7
\& Title   : _worksheet
\& Usage   : $obj->_worksheet($newval)
\& Function: Get/set the worksheet object to be used for accessing cells.
\& Example :
\& Returns : value of _worksheet (a Spreadsheet::ParseExcel::Worksheet object)
\& Args    : on set, new value (a Spreadsheet::ParseExcel::Worksheet
\&           object or undef, optional)
.Ve
.Sh "_next_record"
.IX Subsection "_next_record"
.Vb 3
\& Title   : _next_record
\& Usage   :
\& Function: Navigates the underlying file to the next record.
.Ve
.PP
.Vb 2
\&           We override this here in order to adapt navigation to data
\&           in an Excel worksheet.
.Ve
.PP
.Vb 5
\& Example :
\& Returns : TRUE if the navigation was successful and FALSE
\&           otherwise. Unsuccessful navigation will usually be treated
\&           as an end-of-file condition.
\& Args    :
.Ve
.Sh "_get_row_values"
.IX Subsection "_get_row_values"
.Vb 4
\& Title   : _get_row_values
\& Usage   :
\& Function: Get the values for the current line (or row) as an array in
\&           the order of columns.
.Ve
.PP
.Vb 2
\&           We override this here in order to adapt access to column
\&           values to data contained in an Excel worksheet.
.Ve
.PP
.Vb 3
\& Example :
\& Returns : An array of column values for the current row.
\& Args    :
.Ve
