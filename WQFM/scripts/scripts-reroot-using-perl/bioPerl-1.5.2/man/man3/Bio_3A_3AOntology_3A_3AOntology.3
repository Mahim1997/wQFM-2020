.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Ontology::Ontology 3"
.TH Bio::Ontology::Ontology 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Ontology::Ontology \- standard implementation of an Ontology
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Bio::Ontology::Ontology;
\&    use Bio::Ontology::Term;
.Ve
.PP
.Vb 2
\&    # create ontology object
\&    my $ont = Bio::Ontology::Ontology->new(-name => "OBF");
.Ve
.PP
.Vb 7
\&    # add terms, relationships ...
\&    my $bp = Bio::Ontology::Term->new(-identifier => '02', -name => "Bioperl");
\&    my $obf = Bio::Ontology::Term->new(-identifier => '01', -name => "OBF");
\&    my $partof = Bio::Ontology::RelationshipType->get_instance("PART_OF");
\&    $ont->add_term($bp);
\&    $ont->add_term($obf);
\&    $ont->add_relationship($bp, $obf, $partof);
.Ve
.PP
.Vb 4
\&    # then query
\&    my @terms = $ont->get_root_terms(); # "OBF"
\&    my @desc = $ont->get_descendant_terms($terms[0], $partof); # "Bioperl"
\&    # ... see methods for other ways to query
.Ve
.PP
.Vb 4
\&    # for advanced users, you can re-use the query engine outside of an
\&    # ontology to let one instance manage multiple ontologies
\&    my $ont2 = Bio::Ontology::Ontology->new(-name => "Foundations",
\&                                            -engine => $ont->engine());
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a no-frills implementation of Bio::Ontology::OntologyI.
.PP
The query functions are implemented by delegation to an
OntologyEngineI implementation.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via
the web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Hilmar Lapp"
.IX Header "AUTHOR - Hilmar Lapp"
Email hlapp at gmx.net
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.Sh "new"
.IX Subsection "new"
.Vb 6
\& Title   : new
\& Usage   : my $obj = new Bio::Ontology::Ontology();
\& Function: Builds a new Bio::Ontology::Ontology object
\& Returns : an instance of Bio::Ontology::Ontology
\& Args    : any number of named arguments. The following names will be
\&           recognized by this module:
.Ve
.PP
.Vb 6
\&            -name         the name of the ontology
\&            -authority    the name of the authority for the ontology
\&            -identifier   an identifier for the ontology, if any
\&            -engine       the Bio::Ontology::OntologyEngineI
\&                          implementation that this instance should use;
\&                          default is Bio::Ontology::SimpleOntologyEngine
.Ve
.PP
.Vb 2
\&            See the corresponding get/set methods for further documentation
\&            on individual properties.
.Ve
.SH "Methods from Bio::Ontology::OntologyI"
.IX Header "Methods from Bio::Ontology::OntologyI"
.Sh "name"
.IX Subsection "name"
.Vb 6
\& Title   : name
\& Usage   : $obj->name($newval)
\& Function: Get/set the name of the ontology.
\& Example :
\& Returns : value of name (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.Sh "authority"
.IX Subsection "authority"
.Vb 5
\& Title   : authority
\& Usage   : $obj->authority($newval)
\& Function: Get/set the authority for this ontology, for instance the
\&           DNS base for the organization granting the name of the
\&           ontology and identifiers for the terms.
.Ve
.PP
.Vb 4
\&           This attribute is optional and should not generally
\&           expected by applications to have been set. It is here to
\&           follow the rules for namespaces, which ontologies serve as
\&           for terms.
.Ve
.PP
.Vb 3
\& Example :
\& Returns : value of authority (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.Sh "definition"
.IX Subsection "definition"
.Vb 6
\& Title   : definition
\& Usage   : $obj->definition($newval)
\& Function: Get/set a descriptive definition of the ontology.
\& Example :
\& Returns : value of definition (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.Sh "identifier"
.IX Subsection "identifier"
.Vb 3
\& Title   : identifier
\& Usage   : $id = $obj->identifier()
\& Function: Get an identifier for this ontology.
.Ve
.PP
.Vb 5
\&           This is primarily intended for look-up purposes. The value
\&           is not modifiable and is determined automatically by the
\&           implementation.  Also, the identifier's uniqueness will only
\&           hold within the scope of a particular application's run
\&           time since it is derived from a memory location.
.Ve
.PP
.Vb 3
\& Example :
\& Returns : value of identifier (a scalar)
\& Args    :
.Ve
.Sh "close"
.IX Subsection "close"
.Vb 6
\& Title   : close
\& Usage   :
\& Function: Release any resources this ontology may occupy. In order
\&           to efficiently release unused memory or file handles, you
\&           should call this method once you are finished with an
\&           ontology.
.Ve
.PP
.Vb 3
\& Example :
\& Returns : TRUE on success and FALSE otherwise
\& Args    : none
.Ve
.SH "Implementation-specific public methods"
.IX Header "Implementation-specific public methods"
.Sh "engine"
.IX Subsection "engine"
.Vb 8
\& Title   : engine
\& Usage   : $engine = $obj->engine()
\& Function: Get/set the ontology engine to which all the query methods
\&           delegate.
\& Example :
\& Returns : an object implementing Bio::Ontology::OntologyEngineI
\& Args    : on set, new value (an object implementing
\&           Bio::Ontology::OntologyEngineI, or  undef)
.Ve
.PP
See Bio::Ontology::OntologyEngineI.
.SH "Methods defined in Bio::Ontology::OntologyEngineI"
.IX Header "Methods defined in Bio::Ontology::OntologyEngineI"
.Sh "add_term"
.IX Subsection "add_term"
.Vb 3
\& Title   : add_term
\& Usage   : add_term(TermI term): TermI
\& Function: Adds TermI object to the ontology engine term store
.Ve
.PP
.Vb 3
\&           If the ontology property of the term object was not set,
\&           this implementation will set it to itself upon adding the
\&           term.
.Ve
.PP
.Vb 3
\& Example : $oe->add_term($term)
\& Returns : its argument.
\& Args    : object of class TermI.
.Ve
.Sh "add_relationship"
.IX Subsection "add_relationship"
.Vb 7
\& Title   : add_relationship
\& Usage   : add_relationship(RelationshipI relationship): RelationshipI
\&           add_relatioship(TermI subject, TermI predicate, TermI object)
\& Function: Adds a relationship object to the ontology engine.
\& Example :
\& Returns : Its argument.
\& Args    : A RelationshipI object.
.Ve
.Sh "get_relationship_type"
.IX Subsection "get_relationship_type"
.Vb 6
\& Title   : get_relationship_type
\& Usage   : get_relationship_type(scalar): RelationshipTypeI
\& Function: Get a relationshiptype object from the ontology engine.
\& Example :
\& Returns : A RelationshipTypeI object.
\& Args    : The name (scalar) of the RelationshipTypeI object desired.
.Ve
.Sh "get_relationships"
.IX Subsection "get_relationships"
.Vb 7
\& Title   : get_relationships
\& Usage   : get_relationships(TermI term): RelationshipI[]
\& Function: Retrieves all relationship objects in the ontology, or all
\&           relationships of a given term.
\& Example :
\& Returns : Array of Bio::Ontology::RelationshipI objects
\& Args    : Optionally, a Bio::Ontology::TermI compliant object
.Ve
.Sh "get_predicate_terms"
.IX Subsection "get_predicate_terms"
.Vb 6
\& Title   : get_predicate_terms
\& Usage   : get_predicate_terms(): TermI
\& Function: Retrieves all relationship types.
\& Example :
\& Returns : Array of TermI objects
\& Args    :
.Ve
.Sh "get_child_terms"
.IX Subsection "get_child_terms"
.Vb 7
\& Title   : get_child_terms
\& Usage   : get_child_terms(TermI term, TermI predicate_terms): TermI
\& Function: Retrieves all child terms of a given term, that satisfy a
\&           relationship among those that are specified in the second
\&           argument or undef otherwise. get_child_terms is a special
\&           case of get_descendant_terms, limiting the search to the
\&           direct descendants.
.Ve
.PP
.Vb 5
\&           Note that a returned term may possibly be in another
\&           ontology than this one, because the underlying engine may
\&           manage multiple ontologies and the relationships of terms
\&           between them. If you only want descendants within this
\&           ontology, you need to filter the returned array.
.Ve
.PP
.Vb 4
\& Example :
\& Returns : Array of TermI objects.
\& Args    : First argument is the term of interest, second is the list
\&           of relationship type terms.
.Ve
.Sh "get_descendant_terms"
.IX Subsection "get_descendant_terms"
.Vb 5
\& Title   : get_descendant_terms
\& Usage   : get_descendant_terms(TermI term, TermI rel_types): TermI
\& Function: Retrieves all descendant terms of a given term, that
\&           satisfy a relationship among those that are specified in
\&           the second argument or undef otherwise.
.Ve
.PP
.Vb 5
\&           Note that a returned term may possibly be in another
\&           ontology than this one, because the underlying engine may
\&           manage multiple ontologies and the relationships of terms
\&           between them. If you only want descendants within this
\&           ontology, you need to filter the returned array.
.Ve
.PP
.Vb 4
\& Example :
\& Returns : Array of TermI objects.
\& Args    : First argument is the term of interest, second is the list
\&           of relationship type terms.
.Ve
.Sh "get_parent_terms"
.IX Subsection "get_parent_terms"
.Vb 7
\& Title   : get_parent_terms
\& Usage   : get_parent_terms(TermI term, TermI predicate_terms): TermI
\& Function: Retrieves all parent terms of a given term, that satisfy a
\&           relationship among those that are specified in the second
\&           argument or undef otherwise. get_parent_terms is a special
\&           case of get_ancestor_terms, limiting the search to the
\&           direct ancestors.
.Ve
.PP
.Vb 5
\&           Note that a returned term may possibly be in another
\&           ontology than this one, because the underlying engine may
\&           manage multiple ontologies and the relationships of terms
\&           between them. If you only want descendants within this
\&           ontology, you need to filter the returned array.
.Ve
.PP
.Vb 4
\& Example :
\& Returns : Array of TermI objects.
\& Args    : First argument is the term of interest, second is the list
\&           of relationship type terms.
.Ve
.Sh "get_ancestor_terms"
.IX Subsection "get_ancestor_terms"
.Vb 5
\& Title   : get_ancestor_terms
\& Usage   : get_ancestor_terms(TermI term, TermI predicate_terms): TermI
\& Function: Retrieves all ancestor terms of a given term, that satisfy
\&           a relationship among those that are specified in the second
\&           argument or undef otherwise.
.Ve
.PP
.Vb 5
\&           Note that a returned term may possibly be in another
\&           ontology than this one, because the underlying engine may
\&           manage multiple ontologies and the relationships of terms
\&           between them. If you only want descendants within this
\&           ontology, you need to filter the returned array.
.Ve
.PP
.Vb 4
\& Example :
\& Returns : Array of TermI objects.
\& Args    : First argument is the term of interest, second is the list
\&           of relationship type terms.
.Ve
.Sh "get_leaf_terms"
.IX Subsection "get_leaf_terms"
.Vb 4
\& Title   : get_leaf_terms
\& Usage   : get_leaf_terms(): TermI
\& Function: Retrieves all leaf terms from the ontology. Leaf term is a
\&           term w/o descendants.
.Ve
.PP
.Vb 3
\& Example : @leaf_terms = $obj->get_leaf_terms()
\& Returns : Array of TermI objects.
\& Args    :
.Ve
.Sh "\fIget_root_terms()\fP"
.IX Subsection "get_root_terms()"
.Vb 4
\& Title   : get_root_terms
\& Usage   : get_root_terms(): TermI
\& Function: Retrieves all root terms from the ontology. Root term is a
\&           term w/o parents.
.Ve
.PP
.Vb 3
\& Example : @root_terms = $obj->get_root_terms()
\& Returns : Array of TermI objects.
\& Args    :
.Ve
.Sh "get_all_terms"
.IX Subsection "get_all_terms"
.Vb 3
\& Title   : get_all_terms
\& Usage   : get_all_terms: TermI
\& Function: Retrieves all terms from the ontology.
.Ve
.PP
.Vb 3
\&           We do not mandate an order here in which the terms are
\&           returned. In fact, the default implementation will return
\&           them in unpredictable order.
.Ve
.PP
.Vb 3
\& Example : @terms = $obj->get_all_terms()
\& Returns : Array of TermI objects.
\& Args    :
.Ve
.Sh "find_terms"
.IX Subsection "find_terms"
.Vb 3
\& Title   : find_terms
\& Usage   : ($term) = $oe->find_terms(-identifier => "SO:0000263");
\& Function: Find term instances matching queries for their attributes.
.Ve
.PP
.Vb 4
\&           An implementation may not support querying for arbitrary
\&           attributes, but can generally be expected to accept
\&           -identifier and -name as queries. If both are provided,
\&           they are implicitly intersected.
.Ve
.PP
.Vb 4
\& Example :
\& Returns : an array of zero or more Bio::Ontology::TermI objects
\& Args    : Named parameters. The following parameters should be recognized
\&           by any implementations:
.Ve
.PP
.Vb 2
\&              -identifier    query by the given identifier
\&              -name          query by the given name
.Ve
.Sh "find_identical_terms"
.IX Subsection "find_identical_terms"
.Vb 7
\& Title   : find_identical_terms
\& Usage   : ($term) = $oe->find_identical_terms($term0);
\& Function: Find term instances where name or synonym
\&           matches the query exactly
\& Example :
\& Returns : an array of zero or more Bio::Ontology::TermI objects
\& Args    : a Bio::Ontology::TermI object
.Ve
.Sh "find_similar_terms"
.IX Subsection "find_similar_terms"
.Vb 7
\& Title   : find_similar_terms
\& Usage   : ($term) = $oe->find_similar_terms($term0);
\& Function: Find term instances where name or synonym, or part of one,
\&           matches the query.
\& Example :
\& Returns : an array of zero or more Bio::Ontology::TermI objects
\& Args    : a Bio::Ontology::TermI object
.Ve
.Sh "find_identically_named_terms"
.IX Subsection "find_identically_named_terms"
.Vb 7
\& Title   : find_identically_named_terms
\& Usage   : ($term) = $oe->find_identically_named_terms($term0);
\& Function: Find term instances where names match the query term
\&           name exactly
\& Example :
\& Returns : an array of zero or more Bio::Ontology::TermI objects
\& Args    : a Bio::Ontology::TermI object
.Ve
.SH "Factory for relationships and terms"
.IX Header "Factory for relationships and terms"
.Sh "relationship_factory"
.IX Subsection "relationship_factory"
.Vb 5
\& Title   : relationship_factory
\& Usage   : $fact = $obj->relationship_factory()
\& Function: Get (and set, if the engine supports it) the object
\&           factory to be used when relationship objects are created by
\&           the implementation on-the-fly.
.Ve
.PP
.Vb 4
\& Example :
\& Returns : value of relationship_factory (a Bio::Factory::ObjectFactoryI
\&           compliant object)
\& Args    :
.Ve
.Sh "term_factory"
.IX Subsection "term_factory"
.Vb 5
\& Title   : term_factory
\& Usage   : $fact = $obj->term_factory()
\& Function: Get (and set, if the engine supports it) the object
\&           factory to be used when term objects are created by
\&           the implementation on-the-fly.
.Ve
.PP
.Vb 4
\& Example :
\& Returns : value of term_factory (a Bio::Factory::ObjectFactoryI
\&           compliant object)
\& Args    :
.Ve
.Sh "annotation"
.IX Subsection "annotation"
.Vb 7
\& Title   : annotation
\& Usage   : $annos = $obj->annotation()
\& Function: Get/Set the Bio::Annotation::Collection object
\&           The collection contains Bio::Annotation::SimpleValue
\&           objects to store header information like the version
\&           and date present in the header section of an Ontology
\&           file.
.Ve
.PP
.Vb 4
\& Example :
\& Returns : value of annotation (a Bio::Annotation::Collection
\&           compliant object)
\& Args    : A Bio::Annotation::Collection object (Optional)
.Ve
