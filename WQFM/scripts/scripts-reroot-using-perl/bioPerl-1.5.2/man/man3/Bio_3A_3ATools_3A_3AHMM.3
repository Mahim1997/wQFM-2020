.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Tools::HMM 3"
.TH Bio::Tools::HMM 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Tools::HMM \- Perl extension to perform Hidden Markov Model calculations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use Bio::Tools::HMM;
\&  use Bio::SeqIO;
\&  use Bio::Matrix::Scoring;
.Ve
.PP
.Vb 3
\&  # create a HMM object
\&  # ACGT are the bases NC mean non-coding and coding
\&  $hmm = new Bio::Tools::HMM('-symbols' => "ACGT", '-states' => "NC");
.Ve
.PP
.Vb 4
\&  # initialize some training observation sequences
\&  $seq1 = new Bio::SeqIO(-file => $ARGV[0], -format => 'fasta');
\&  $seq2 = new Bio::SeqIO(-file => $ARGV[1], -format => 'fasta');
\&  @seqs = ($seq1, $seq2);
.Ve
.PP
.Vb 2
\&  # train the HMM with the observation sequences
\&  $hmm->baum_welch_training(\e@seqs);
.Ve
.PP
.Vb 4
\&  # get parameters
\&  $init = $hmm->init_prob; # returns an array reference
\&  $matrix1 = $hmm->transition_prob; # returns Bio::Matrix::Scoring
\&  $matrix2 = $hmm->emission_prob; # returns Bio::Matrix::Scoring
.Ve
.PP
.Vb 4
\&  # initialize training hidden state sequences
\&  $hs1 = "NCNCNNNNNCCCCNNCCCNNNNC";
\&  $hs2 = "NCNNCNNNNNNCNCNCNNNCNCN";
\&  @hss = ($hs1, $hs2);
.Ve
.PP
.Vb 3
\&  # train the HMM with both observation sequences and hidden state
\&  # sequences
\&  $hmm->statistical_training(\e@seqs, \e@hss);
.Ve
.PP
.Vb 4
\&  # with the newly calibrated HMM, we can use viterbi algorithm
\&  # to obtain the hidden state sequence underlying an observation 
\&  # sequence
\&  $hss = $hmm->viterbi($seq); # returns a string of hidden states
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Hidden Markov Model (\s-1HMM\s0) was first introduced by Baum and his colleagues
in a series of classic papers in the late 1960s and 1970s. It was first
applied to the field of speech recognition with great success in the 1970s.
.PP
Explosion in the amount sequencing data in the 1990s opened the field
of Biological Sequence Analysis. Seeing \s-1HMM\s0's effectiveness in detecing
signals in biological sequences, Krogh, Mian and Haussler used \s-1HMM\s0 to find
genes in E. coli \s-1DNA\s0 in a classical paper in 1994. Since then, there have
been extensive application of \s-1HMM\s0 to other area of Biology, for example,
multiple sequence alignment, CpG island detection and so on.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
This package comes with the main bioperl distribution. You also need
to install the lastest bioperl-ext package which contains the \s-1XS\s0 code
that implements the algorithms. This package won't work if you haven't
compiled the bioperl-ext package.
.SH "TO-DO"
.IX Header "TO-DO"
.IP "1." 3
Allow people to set and get the tolerance level in the \s-1EM\s0 algorithm.
.IP "2." 3
Allow people to set and get the maximum number of iterations 
to run in the \s-1EM\s0 algorithm.
.IP "3." 3
A function to calculate the probability of an observation sequence
.IP "4." 3
A function to do posterior decoding, ie to find the probabilty of
seeing a certain observation symbol at position i.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules.  Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 5
\&        This implementation was written by Yee Man Chan (ymc@yahoo.com).
\&        Copyright (c) 2005 Yee Man Chan. All rights reserved. This program
\&        is free software; you can redistribute it and/or modify it under
\&        the same terms as Perl itself. All the code are written by Yee
\&        Man Chan without borrowing any code from anywhere.
.Ve
.Sh "likelihood"
.IX Subsection "likelihood"
.Vb 8
\& Title   : likelihood
\& Usage   : $prob = $hmm->likelihood($seq)
\& Function: Calculate the probability of an observation sequence given an HMM
\& Returns : An floating point number that is the logarithm of the probability
\&           of an observation sequence given an HMM
\& Args    : The only argument is a string that is the observation sequence
\&           you are interested in. Note that the sequence must not contain
\&           any character that is not in the alphabet of observation symbols.
.Ve
.Sh "statistical_training"
.IX Subsection "statistical_training"
.Vb 11
\& Title   : statistical_training
\& Usage   : $hmm->statistical_training(\e@seqs, \e@hss)
\& Function: Estimate the parameters of an HMM given an array of observation 
\&           sequence and an array of the corresponding hidden state 
\&           sequences
\& Returns : Returns nothing. The parameters of the HMM will be set to the 
\&           estimated values
\& Args    : The first argument is a reference to an array of observation 
\&           sequences. The second argument is a reference to an array of
\&           hidden state sequences. Note that the lengths of an observation
\&           sequence and a hidden state sequence must be the same.
.Ve
.Sh "baum_welch_training"
.IX Subsection "baum_welch_training"
.Vb 8
\& Title   : baum_welch_training
\& Usage   : $hmm->baum_welch_training(\e@seqs)
\& Function: Estimate the parameters of an HMM given an array of observation 
\&           sequence
\& Returns : Returns nothing. The parameters of the HMM will be set to the 
\&           estimated values
\& Args    : The only argument is a reference to an array of observation 
\&           sequences.
.Ve
.Sh "viterbi"
.IX Subsection "viterbi"
.Vb 7
\& Title   : viterbi
\& Usage   : $hss = $hmm->viterbi($seq)
\& Function: Find out the hidden state sequence that can maximize the 
\&           probability of seeing observation sequence $seq.
\& Returns : Returns a string that is the hidden state sequence that maximizes
\&           the probability of seeing $seq.
\& Args    : The only argument is an observation sequence.
.Ve
.Sh "symbols"
.IX Subsection "symbols"
.Vb 7
\& Title     : symbols 
\& Usage     : $symbols = $hmm->symbols() #get
\&           : $hmm->symbols($value) #set
\& Function  : the set get for the observation symbols
\& Example   :
\& Returns   : symbols string
\& Arguments : new value
.Ve
.Sh "states"
.IX Subsection "states"
.Vb 7
\& Title     : states
\& Usage     : $states = $hmm->states() #get
\&           : $hmm->states($value) #set
\& Function  : the set get for the hidden states
\& Example   :
\& Returns   : states string
\& Arguments : new value
.Ve
.Sh "init_prob"
.IX Subsection "init_prob"
.Vb 7
\& Title     : init_prob
\& Usage     : $init = $hmm->init_prob() #get
\&           : $hmm->transition_prob(\e@init) #set
\& Function  : the set get for the initial probability array
\& Example   :
\& Returns   : reference to double array
\& Arguments : new value
.Ve
.Sh "transition_prob"
.IX Subsection "transition_prob"
.Vb 7
\& Title     : transition_prob
\& Usage     : $transition_matrix = $hmm->transition_prob() #get
\&           : $hmm->transition_prob($matrix) #set
\& Function  : the set get for the transition probability mairix
\& Example   :
\& Returns   : Bio::Matrix::Scoring 
\& Arguments : new value
.Ve
.Sh "emission_prob"
.IX Subsection "emission_prob"
.Vb 7
\& Title     : emission_prob
\& Usage     : $emission_matrix = $hmm->emission_prob() #get
\&           : $hmm->emission_prob($matrix) #set
\& Function  : the set get for the emission probability mairix
\& Example   :
\& Returns   : Bio::Matrix::Scoring 
\& Arguments : new value
.Ve
