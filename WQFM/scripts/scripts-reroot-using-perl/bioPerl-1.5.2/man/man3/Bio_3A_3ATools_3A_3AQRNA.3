.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Tools::QRNA 3"
.TH Bio::Tools::QRNA 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Tools::QRNA \- A Parser for qrna output
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  use Bio::Tools::QRNA;
\&  my $parser = new Bio::Tools::QRNA(-file => $qrnaoutput);
\&  while( my $feature = $parser->next_feature ) {
\&    # do something here
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Parses \s-1QRNA\s0 output (E.Rivas;
http://www.genetics.wustl.edu/eddy/software/#qrna).
.PP
This module is not complete, but currently it packs information from
each \s-1QRNA\s0 alignment into a single Bio::SeqFeature::Generic object.
.PP
Not all options for \s-1QRNA\s0 output have been tested or tried.  It has
been tested on sliding window output (\-w \-x) and shuffled output (\-b
or \-B).
.PP
See t/QRNA.t for example usage.
.PP
At some point we may have more complicated feature object which will
support this data rather than forcing most of the information into
tag/value pairs in a SeqFeature::Generic.
.PP
Running with \-verbose => 1 will store extra data in the feature.  The
entire unparsed entry for a particular feature will be stored as a
string in the tag 'entry' it is accessible via:
.PP
.Vb 1
\&  my ($entry) = $f->each_tag_value('entry');
.Ve
.PP
The winning model for any given alignment test will be the name stored
in the primary_tag field of feature.  The bit score will stored in the
score field.  The logoddpost is availble via the a tag/value pair.
This example code will show how to print out the score and log odds
post for each model.
.PP
.Vb 7
\&  # assuming you got a feature already
\&  print "model score logoddspost\en";
\&  foreach my $model ( qw(OTH COD RNA) ) {
\&    my ($score)       = $f->get_tag_values("$model\e_score");
\&    my ($logoddspost) = $f->get_tag_values("$model\e_logoddspost");
\&    print "$model $score $logoddspost\en";
\&  }
.Ve
.PP
The start and end of the alignment for both the query and hit sequence
are available through the Bio::SeqFeature::FeaturePair interface,
specifically Bio::SeqFeature::FeaturePair::feature1 and
Bio::SeqFeature::FeaturePair::feature2.  Additionally if you have
run \s-1QRNA\s0 with an input file which has the location of the alignment
stored in the \s-1FASTA\s0 filename as in (\s-1ID/START\-END\s0) which is the default
output format from Bio::AlignIO::fasta produced alignment output,
this module will re-number start/end for the two sequences so they are
in the actual coordinates of the sequence rather than the relative
coordinates of the alignment.  You may find the bioperl utillity
script search2alnblocks useful in creating your input files for \s-1QRNA\s0.
.PP
Some other words of warning, \s-1QRNA\s0 uses a 0 based numbering system for
sequence locations, Bioperl uses a 1 based system.  You'll notice that
locations will be +1 they are reported in the raw \s-1QRNA\s0 output.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via
the web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Jason Stajich"
.IX Header "AUTHOR - Jason Stajich"
Email jason-at-bioperl-dot-org
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.Sh "new"
.IX Subsection "new"
.Vb 6
\& Title   : new
\& Usage   : my $obj = new Bio::Tools::QRNA();
\& Function: Builds a new Bio::Tools::QRNA object 
\& Returns : an instance of Bio::Tools::QRNA
\& Args    : -fh/-file filehandle/filename standard input for 
\&                     Bio::Root:IO objects
.Ve
.Sh "next_feature"
.IX Subsection "next_feature"
.Vb 5
\& Title   : next_feature
\& Usage   : my $feature = $parser->next_feature
\& Function: Get the next QRNA feature
\& Returns : 
\& Args    :
.Ve
.Sh "PAM_model"
.IX Subsection "PAM_model"
.Vb 6
\& Title   : PAM_model
\& Usage   : $obj->PAM_model($newval)
\& Function: 
\& Example : 
\& Returns : value of PAM_model (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.Sh "RNA_model"
.IX Subsection "RNA_model"
.Vb 6
\& Title   : RNA_model
\& Usage   : $obj->RNA_model($newval)
\& Function: 
\& Example : 
\& Returns : value of RNA_model (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.Sh "seq_file"
.IX Subsection "seq_file"
.Vb 6
\& Title   : seq_file
\& Usage   : $obj->seq_file($newval)
\& Function: 
\& Example : 
\& Returns : value of seq_file (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.Sh "program_name"
.IX Subsection "program_name"
.Vb 6
\& Title   : program_name
\& Usage   : $obj->program_name($newval)
\& Function: 
\& Example : 
\& Returns : value of program_name (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.Sh "program_version"
.IX Subsection "program_version"
.Vb 6
\& Title   : program_version
\& Usage   : $obj->program_version($newval)
\& Function: 
\& Example : 
\& Returns : value of program_version (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.Sh "program_date"
.IX Subsection "program_date"
.Vb 6
\& Title   : program_date
\& Usage   : $obj->program_date($newval)
\& Function: 
\& Example : 
\& Returns : value of program_date (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
