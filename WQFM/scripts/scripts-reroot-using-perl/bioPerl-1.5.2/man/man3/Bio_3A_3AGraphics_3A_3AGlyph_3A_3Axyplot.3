.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Graphics::Glyph::xyplot 3"
.TH Bio::Graphics::Glyph::xyplot 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Graphics::Glyph::xyplot \- The xyplot glyph
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  See L<Bio::Graphics::Panel> and L<Bio::Graphics::Glyph>.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This glyph is used for drawing features that have a position on the
genome and a numeric value.  It can be used to represent gene
prediction scores, motif-calling scores, percent similarity,
microarray intensities, or other features that require a line plot.
.PP
The X axis represents the position on the genome, as per all other
glyphs.  The Y axis represents the score.  Options allow you to set
the height of the glyph, the maximum and minimum scores, the color of
the line and axis, and the symbol to draw.
.PP
The plot is designed to work on a single feature group that contains
subfeatures.  It is the subfeatures that carry the score
information. The best way to arrange for this is to create an
aggregator for the feature.  We'll take as an example a histogram of
repeat density in which interval are spaced every megabase and the
score indicates the number of repeats in the interval; we'll assume
that the database has been loaded in in such a way that each interval
is a distinct feature with the method name \*(L"density\*(R" and the source
name \*(L"repeat\*(R".  Furthermore, all the repeat features are grouped
together into a single group (the name of the group is irrelevant).
If you are using Bio::DB::GFF and Bio::Graphics directly, the sequence
of events would look like this:
.PP
.Vb 6
\&  my $agg = Bio::DB::GFF::Aggregator->new(-method    => 'repeat_density',
\&                                          -sub_parts => 'density:repeat');
\&  my $db  = Bio::DB::GFF->new(-dsn=>'my_database',
\&                              -aggregators => $agg);
\&  my $segment  = $db->segment('Chr1');
\&  my @features = $segment->features('repeat_density');
.Ve
.PP
.Vb 9
\&  my $panel = Bio::Graphics::Panel->new(-pad_left=>40,-pad_right=>40);
\&  $panel->add_track(\e@features,
\&                    -glyph => 'xyplot',
\&                    -graph_type=>'points',
\&                    -point_symbol=>'disc',
\&                    -point_radius=>4,
\&                    -scale=>'both',
\&                    -height=>200,
\&  );
.Ve
.PP
If you are using Generic Genome Browser, you will add this to the
configuration file:
.PP
.Vb 2
\&  aggregators = repeat_density{density:repeat}
\&                clone alignment etc
.Ve
.PP
Note that it is a good idea to add some padding to the left and right
of the panel; otherwise the scale will be partially cut off by the
edge of the image.
.Sh "\s-1OPTIONS\s0"
.IX Subsection "OPTIONS"
The following options are standard among all Glyphs.  See
Bio::Graphics::Glyph for a full explanation.
.PP
.Vb 2
\&  Option      Description                      Default
\&  ------      -----------                      -------
.Ve
.PP
.Vb 1
\&  -fgcolor      Foreground color               black
.Ve
.PP
.Vb 1
\&  -outlinecolor Synonym for -fgcolor
.Ve
.PP
.Vb 1
\&  -bgcolor      Background color               turquoise
.Ve
.PP
.Vb 1
\&  -fillcolor    Synonym for -bgcolor
.Ve
.PP
.Vb 1
\&  -linewidth    Line width                     1
.Ve
.PP
.Vb 1
\&  -height       Height of glyph                10
.Ve
.PP
.Vb 1
\&  -font         Glyph font                     gdSmallFont
.Ve
.PP
.Vb 1
\&  -label        Whether to draw a label        0 (false)
.Ve
.PP
.Vb 1
\&  -description  Whether to draw a description  0 (false)
.Ve
.PP
.Vb 1
\&  -hilite       Highlight color                undef (no color)
.Ve
.PP
In addition, the alignment glyph recognizes the following
glyph-specific options:
.PP
.Vb 2
\&  Option         Description                  Default
\&  ------         -----------                  -------
.Ve
.PP
.Vb 2
\&  -max_score   Maximum value of the           Calculated
\&               feature's "score" attribute
.Ve
.PP
.Vb 2
\&  -min_score   Minimum value of the           Calculated
\&               feature's "score" attribute
.Ve
.PP
.Vb 4
\&  -graph_type  Type of graph to generate.     Histogram
\&               Options are: "histogram",
\&               "boxes", "line", "points",
\&               or "linepoints".
.Ve
.PP
.Vb 3
\&  -point_symbol Symbol to use. Options are    none
\&                "triangle", "square", "disc",
\&                "point", and "none".
.Ve
.PP
.Vb 3
\&  -point_radius Radius of the symbol, in      4
\&                pixels (does not apply
\&                to "point")
.Ve
.PP
.Vb 4
\&  -scale        Position where the Y axis     none
\&                scale is drawn if any.
\&                It should be one of
\&                "left", "right", "both" or "none"
.Ve
.PP
.Vb 2
\&  -graph_height Specify height of the graph   Same as the
\&                                              "height" option.
.Ve
.PP
.Vb 2
\&  -neg_color   For boxes only, bgcolor for    Same as bgcolor
\&               points with negative scores
.Ve
.PP
.Vb 4
\&  -part_color  For boxes & points only,       none
\&               bgcolor of each part (should
\&               be a callback). Supersedes
\&               -neg_color.
.Ve
.PP
.Vb 5
\&  -clip        If min_score and/or max_score  false
\&               are manually specified, then
\&               setting this to true will
\&               cause values outside the
\&               range to be clipped.
.Ve
.PP
Note that when drawing scales on the left or right that the scale is
actually drawn a few pixels \fBoutside\fR the boundaries of the glyph.
You may wish to add some padding to the image using \-pad_left and
\&\-pad_right when you create the panel.
.PP
The \fB\-part_color\fR option can be used to color each part of the
graph. Only the \*(L"boxes\*(R", \*(L"points\*(R" and \*(L"linepoints\*(R" styles are
affected by this.  Here's a simple example:
.PP
.Vb 10
\&  $panel->add_track->(\e@affymetrix_data,
\&                      -glyph      => 'xyplot',
\&                      -graph_type => 'boxes',
\&                      -part_color => sub {
\&                                   my $score = shift->score;
\&                                   return 'red' if $score < 0;
\&                                   return 'lightblue' if $score < 500;
\&                                   return 'blue'      if $score >= 500;
\&                                  }
\&                      );
.Ve
.Sh "\s-1METHODS\s0"
.IX Subsection "METHODS"
For those developers wishing to derive new modules based on this
glyph, the main method to override is:
.ie n .IP "'method_name' = $glyph\->lookup_draw_method($type)" 4
.el .IP "'method_name' = \f(CW$glyph\fR\->lookup_draw_method($type)" 4
.IX Item "'method_name' = $glyph->lookup_draw_method($type)"
This method accepts the name of a graph type (such as 'histogram') and
returns the name of a method that will be called to draw the contents
of the graph, for example '_draw_histogram'. This method will be
called with three arguments:
.Sp
.Vb 1
\&   $self->$draw_method($gd,$left,$top,$y_origin)
.Ve
.Sp
where \f(CW$gd\fR is the \s-1GD\s0 object, \f(CW$left\fR and \f(CW$top\fR are the left and right
positions of the whole glyph (which includes the scale and label), and
\&\f(CW$y_origin\fR is the position of the zero value on the y axis (in
pixels). By the time this method is called, the y axis and labels will
already have been drawn, and the scale of the drawing (in pixels per
unit score) will have been calculated and stored in
\&\f(CW$self\fR\->{_scale}. The y position (in pixels) of each point to graph
will have been stored into the part, as \f(CW$part\fR\->{_y_position}. Hence
you could draw a simple scatter plot with this code:
.Sp
.Vb 9
\& sub lookup_draw_method {
\&    my $self = shift;
\&    my $type = shift;
\&    if ($type eq 'simple_scatterplot') {
\&      return 'draw_points';
\&    } else {
\&      return $self->SUPER::lookup_draw_method($type);
\&    }
\& }
.Ve
.Sp
.Vb 5
\& sub draw_points {
\&  my $self = shift;
\&  my ($gd,$left,$top) = @_;
\&  my @parts   = $self->parts;
\&  my $bgcolor = $self->bgcolor;
.Ve
.Sp
.Vb 6
\&  for my $part (@parts) {
\&    my ($x1,$y1,$x2,$y2) = $part->calculate_boundaries($left,$top);
\&    my $x = ($x1+$x2)/2;  # take center
\&    my $y = $part->{_y_position};
\&    $gd->setPixel($x,$y,$bgcolor);
\& }
.Ve
.ie n .IP "$y_position = $self\->score2position($score)" 4
.el .IP "$y_position = \f(CW$self\fR\->score2position($score)" 4
.IX Item "$y_position = $self->score2position($score)"
Translate a score into a y pixel position, obeying clipping rules and
min and max values.
.SH "BUGS"
.IX Header "BUGS"
Please report them.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Bio::Graphics::Panel,
Bio::Graphics::Track,
Bio::Graphics::Glyph::transcript2,
Bio::Graphics::Glyph::anchored_arrow,
Bio::Graphics::Glyph::arrow,
Bio::Graphics::Glyph::box,
Bio::Graphics::Glyph::primers,
Bio::Graphics::Glyph::segments,
Bio::Graphics::Glyph::toomany,
Bio::Graphics::Glyph::transcript,
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln Stein <lstein@cshl.org>
.PP
Copyright (c) 2001 Cold Spring Harbor Laboratory
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.  See \s-1DISCLAIMER\s0.txt for
disclaimers of warranty.
