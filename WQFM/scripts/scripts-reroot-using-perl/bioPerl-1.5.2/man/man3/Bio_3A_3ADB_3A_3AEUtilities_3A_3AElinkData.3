.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::EUtilities::ElinkData 3"
.TH Bio::DB::EUtilities::ElinkData 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::DB::EUtilities::ElinkData 
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
*** Give standard usage here
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
*** Describe the object here
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the
evolution of this and other Bioperl modules. Send
your comments and suggestions preferably to one
of the Bioperl mailing lists. Your participation
is much appreciated.
.PP
.Vb 2
\&  bioperl-l@lists.open-bio.org               - General discussion
\&  http://www.bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to
help us keep track the bugs and their resolution.
Bug reports can be submitted via the web.
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Email cjfields at uiuc dot edu
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the
object methods. Internal methods are usually
preceded with a _
.Sh "elink_dbfrom"
.IX Subsection "elink_dbfrom"
.Vb 5
\& Title   : elink_dbfrom
\& Usage   : $dbfrom = $linkset->elink_dbfrom;
\& Function: gets/sets dbfrom value
\& Returns : originating database
\& Args    : originating database
.Ve
.Sh "elink_queryids"
.IX Subsection "elink_queryids"
.Vb 5
\& Title   : elink_queryids
\& Usage   : @ids = $linkset->elink_queryids;
\& Function: gets/sets original query ID values (ref to array)
\& Returns : array or array ref of IDs (based on wantarray)
\& Args    : array ref of IDs
.Ve
.Sh "elink_command"
.IX Subsection "elink_command"
.Vb 5
\& Title   : elink_command
\& Usage   : $cmd = $linkset->elink_command;
\& Function: gets/sets cmd used for elink query
\& Returns : string (cmd parameter)
\& Args    : string (cmd parameter)
.Ve
.Sh "get_LinkIds_by_db"
.IX Subsection "get_LinkIds_by_db"
.Vb 5
\& Title   : get_LinkIds_by_db
\& Usage   : @ids = $linkset->get_LinkIds_by_db('protein');
\& Function: retrieves primary ID list based on the database for the object
\& Returns : array or array ref of IDs (based on wantarray)
\& Args    : None
.Ve
.Sh "next_linkdb"
.IX Subsection "next_linkdb"
.Vb 5
\& Title   : next_linkdb
\& Usage   : while (my $db = $linkset->next_linkdb) {
\& Function: iterates through list of database names in internal queue
\& Returns : String (name of database)
\& Args    : None
.Ve
.Sh "get_all_linkdbs"
.IX Subsection "get_all_linkdbs"
.Vb 5
\& Title   : get_all_linkdbs
\& Usage   : @dbs = $linkset->get_all_linkdbs;
\& Function: returns all database names which contain IDs
\& Returns : array or array ref of databases (based on wantarray)
\& Args    : None
.Ve
.Sh "next_scoredb"
.IX Subsection "next_scoredb"
.Vb 5
\& Title   : next_scoredb
\& Usage   : while (my $db = $linkset->next_scoredb) {
\& Function: iterates through list of database with score values
\& Returns : String (name of database)
\& Args    : None
.Ve
.Sh "get_all_scoredbs"
.IX Subsection "get_all_scoredbs"
.Vb 5
\& Title   : get_all_scoredbs
\& Usage   : @dbs = $linkset->get_all_scoredbs;
\& Function: returns database names which contain scores
\& Returns : array or array ref of databases (based on wantarray)
\& Args    : None
.Ve
.Sh "get_score"
.IX Subsection "get_score"
.Vb 8
\& Title   : get_score
\& Usage   : $score = $linkset->get_score($id);
\& Function: returns score value for ID
\& Returns : score value
\& Args    : ID
\& Note    : if multiple databases are returned with scores (rare but possible),
\&         : you must set the default score database using set_scoredb.  If you
\&         : use next_scoredb to iterate through the databases, this is done for you
.Ve
.Sh "get_score_hash"
.IX Subsection "get_score_hash"
.Vb 6
\& Title   : get_score_hash
\& Usage   : %scores = $linkset->get_score_hash($database);
\& Function: returns ID(key)-score(value) hash based on database name
\& Returns : score value
\& Args    : OPTIONAL : database name.  If there is only one score hash, returns
\&         : that hash, otherwise throws an exception
.Ve
.Sh "set_scoredb"
.IX Subsection "set_scoredb"
.Vb 5
\& Title   : set_scoredb
\& Usage   : $linkset->set_scoredb('protein');
\& Function: sets the database to retrieve scores from
\& Returns : None
\& Args    : database name
.Ve
.Sh "rewind_linkdbs"
.IX Subsection "rewind_linkdbs"
.Vb 5
\& Title   : rewind_linkdbs
\& Usage   : $linkset->rewind_linkdbs;
\& Function: resets the iterator for next_database
\& Returns : None
\& Args    : None
.Ve
.Sh "rewind_scoredbs"
.IX Subsection "rewind_scoredbs"
.Vb 5
\& Title   : rewind_scoredbs
\& Usage   : $linkset->rewind_scoredbs;
\& Function: resets the iterator, current database for next_scoredb
\& Returns : None
\& Args    : None
.Ve
