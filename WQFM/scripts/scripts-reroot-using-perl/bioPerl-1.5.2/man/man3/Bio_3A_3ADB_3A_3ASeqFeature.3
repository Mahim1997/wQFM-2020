.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::SeqFeature 3"
.TH Bio::DB::SeqFeature 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::DB::SeqFeature \-\- Normalized feature for use with Bio::DB::SeqFeature::Store
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\& use Bio::DB::SeqFeature::Store;
\& # Open the sequence database
\& my $db      = Bio::DB::SeqFeature::Store->new( -adaptor => 'DBI::mysql',
\&                                                -dsn     => 'dbi:mysql:test');
\& my ($feature)   = $db->get_features_by_name('ZK909');
\& my @subfeatures = $feature->get_SeqFeatures();
\& my @exons_only  = $feature->get_SeqFeatures('exon');
.Ve
.PP
.Vb 5
\& # create a new object
\& my $new = $db->new_feature(-primary_tag=>'gene',
\&                            -seq_id     => 'chr3',
\&                            -start      => 10000,
\&                            -end        => 11000);
.Ve
.PP
.Vb 5
\& # add a new exon
\& $feature->add_SeqFeature($db->new_feature(-primary_tag=>'exon',
\&                                           -seq_id     => 'chr3',
\&                                           -start      => 5000,
\&                                           -end        => 5551));
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Bio::DB::SeqFeature object is the default SeqFeature class stored
in Bio::DB::SeqFeature databases. It implements both the
Bio::DB::SeqFeature::NormalizedFeatureI and
Bio::DB::SeqFeature::TableFeatureI interfaces, which means that its
subfeatures, if any, are stored in the database in a normalized
fashion, and that the parent/child hierarchy of features and
subfeatures are also stored in the database as set of tuples. This
provides efficiencies in both storage and retrieval speed.
.PP
Typically you will not create Bio::DB::SeqFeature directly, but will
ask the database to do so on your behalf, as described in
Bio::DB::SeqFeature::Store.
.Sh "new"
.IX Subsection "new"
.Vb 6
\& Title   : new
\& Usage   : $feature = Bio::DB::SeqFeature::NormalizedFeature->new(@args)
\& Function: create a new feature
\& Returns : the new seqfeature
\& Args    : see below
\& Status  : public
.Ve
.PP
This method creates and, if possible stores into a database, a new
Bio::DB::SeqFeature::NormalizedFeature object using the specialized
Bio::DB::SeqFeature class.
.PP
The arguments are the same to Bio::SeqFeature::Generic\->\fInew()\fR and
Bio::Graphics::Feature\->\fInew()\fR. The most important difference is the
\&\fB\-store\fR option, which if present creates the object in a
Bio::DB::SeqFeature::Store database, and he \fB\-index\fR option, which
controls whether the feature will be indexed for retrieval (default is
true). Ordinarily, you would only want to turn indexing on when
creating top level features, and off only when storing
subfeatures. The default is on.
.PP
Arguments are as follows:
.PP
.Vb 17
\&  -seq_id       the reference sequence
\&  -start        the start position of the feature
\&  -end          the stop position of the feature
\&  -display_name the feature name (returned by seqname)
\&  -primary_tag  the feature type (returned by primary_tag)
\&  -source       the source tag
\&  -score        the feature score (for GFF compatibility)
\&  -desc         a description of the feature
\&  -segments     a list of subfeatures (see Bio::Graphics::Feature)
\&  -subtype      the type to use when creating subfeatures
\&  -strand       the strand of the feature (one of -1, 0 or +1)
\&  -phase        the phase of the feature (0..2)
\&  -url          a URL to link to when rendered with Bio::Graphics
\&  -attributes   a hashref of tag value attributes, in which the key is the tag
\&                  and the value is an array reference of values
\&  -store        a previously-opened Bio::DB::SeqFeature::Store object
\&  -index        index this feature if true
.Ve
.PP
Aliases:
.PP
.Vb 6
\&  -id           an alias for -display_name
\&  -seqname      an alias for -display_name
\&  -display_id   an alias for -display_name
\&  -name         an alias for -display_name
\&  -stop         an alias for end
\&  -type         an alias for primary_tag
.Ve
.Sh "Bio::SeqFeatureI methods"
.IX Subsection "Bio::SeqFeatureI methods"
The following Bio::SeqFeatureI methods are supported:
.PP
.Vb 5
\& seq_id(), start(), end(), strand(), get_SeqFeatures(),
\& display_name(), primary_tag(), source_tag(), seq(),
\& location(), primary_id(), overlaps(), contains(), equals(),
\& intersection(), union(), has_tag(), remove_tag(),
\& add_tag_value(), get_tag_values(), get_all_tags()
.Ve
.PP
Some methods that do not make sense in the context of a genome
annotation database system, such as \fIattach_seq()\fR, are not supported.
.PP
Please see Bio::SeqFeatureI for more details.
.Sh "add_SeqFeature"
.IX Subsection "add_SeqFeature"
.Vb 6
\& Title   : add_SeqFeature
\& Usage   : $flag = $feature->add_SeqFeature(@features)
\& Function: Add subfeatures to the feature
\& Returns : true if successful
\& Args    : list of Bio::SeqFeatureI objects
\& Status  : public
.Ve
.PP
Add one or more subfeatures to the feature. For best results,
subfeatures should be of the same class as the parent feature
(i.e. don't try mixing Bio::DB::SeqFeature::NormalizedFeature with
other feature types).
.PP
An alias for this method is \fIadd_segment()\fR.
.Sh "update"
.IX Subsection "update"
.Vb 6
\& Title   : update
\& Usage   : $flag = $feature->update()
\& Function: Update feature in the database
\& Returns : true if successful
\& Args    : none
\& Status  : public
.Ve
.PP
After changing any fields in the feature, call \fIupdate()\fR to write it to
the database. This is not needed for \fIadd_SeqFeature()\fR as \fIupdate()\fR is
invoked automatically.
.Sh "get_SeqFeatures"
.IX Subsection "get_SeqFeatures"
.Vb 6
\& Title   : get_SeqFeature
\& Usage   : @subfeatures = $feature->get_SeqFeatures([@types])
\& Function: return subfeatures of this feature
\& Returns : list of subfeatures
\& Args    : list of subfeature primary_tags (optional)
\& Status  : public
.Ve
.PP
This method extends the Bio::SeqFeatureI \fIget_SeqFeatures()\fR slightly by
allowing you to pass a list of primary_tags, in which case only
subfeatures whose primary_tag is contained on the list will be
returned. Without any types passed all subfeatures are returned.
.Sh "object_store"
.IX Subsection "object_store"
.Vb 6
\& Title   : object_store
\& Usage   : $store = $feature->object_store([$new_store])
\& Function: get or set the database handle
\& Returns : current database handle
\& Args    : new database handle (optional)
\& Status  : public
.Ve
.PP
This method will get or set the Bio::DB::SeqFeature::Store object that
is associated with the feature. After changing the store, you should
probably unset the feature's \fIprimary_id()\fR and call \fIupdate()\fR to ensure
that the object is written into the database as a new feature.
.Sh "overloaded_names"
.IX Subsection "overloaded_names"
.Vb 6
\& Title   : overloaded_names
\& Usage   : $overload = $feature->overloaded_names([$new_overload])
\& Function: get or set overloading of object strings
\& Returns : current flag
\& Args    : new flag (optional)
\& Status  : public
.Ve
.PP
For convenience, when objects of this class are stringified, they are
represented in the form \*(L"primary_tag(display_name)\*(R". To turn this
feature off, call \fIoverloaded_names()\fR with a false value. You can
invoke this on an individual feature object or on the class:
.PP
.Vb 1
\&  Bio::DB::SeqFeature::NormalizedFeature->overloaded_names(0);
.Ve
.Sh "segment"
.IX Subsection "segment"
.Vb 6
\& Title   : segment
\& Usage   : $segment = $feature->segment
\& Function: return a Segment object corresponding to feature
\& Returns : a Bio::DB::SeqFeature::Segment
\& Args    : none
\& Status  : public
.Ve
.PP
This turns the feature into a Bio::DB::SeqFeature::Segment object,
which you can then use to query for overlapping features. See
Bio::DB::SeqFeature::Segment.
.Sh "\s-1AUTOLOADED\s0 methods"
.IX Subsection "AUTOLOADED methods"
.Vb 1
\& @subfeatures = $feature->Exon;
.Ve
.PP
If you use an unknown method that begins with a capital letter, then
the feature autogenerates a call to \fIget_SeqFeatures()\fR using the
lower-cased method name as the primary_tag. In other words
\&\f(CW$feature\fR\->Exon is equivalent to:
.PP
.Vb 1
\& @subfeature s= $feature->get_SeqFeatures('exon')
.Ve
.Sh "load_id"
.IX Subsection "load_id"
.Vb 6
\& Title   : load_id
\& Usage   : $id = $feature->load_id
\& Function: get the GFF3 load ID
\& Returns : the GFF3 load ID (string)
\& Args    : none
\& Status  : public
.Ve
.PP
For features that were originally loaded by the \s-1GFF3\s0 loader, this
method returns the \s-1GFF3\s0 load \s-1ID\s0. This method may not be supported in
future versions of the module.
.Sh "primary_id"
.IX Subsection "primary_id"
.Vb 6
\& Title   : primary_id
\& Usage   : $id = $feature->primary_id([$new_id])
\& Function: get/set the feature's database ID
\& Returns : the current primary ID
\& Args    : none
\& Status  : public
.Ve
.PP
This method gets or sets the primary \s-1ID\s0 of the feature in the
underlying Bio::DB::SeqFeature::Store database. If you change this
field and then call \fIupdate()\fR, it will have the effect of making a copy
of the feature in the database under a new \s-1ID\s0.
.Sh "target"
.IX Subsection "target"
.Vb 6
\& Title   : target
\& Usage   : $segment = $feature->target
\& Function: return the segment correspondent to the "Target" attribute
\& Returns : a Bio::DB::SeqFeature::Segment object
\& Args    : none
\& Status  : public
.Ve
.PP
For features that are aligned with others via the \s-1GFF3\s0 Target
attribute, this returns a segment corresponding to the aligned
region. The \s-1CIGAR\s0 gap string is not yet supported.
.Sh "Internal methods"
.IX Subsection "Internal methods"
.IP "$feature\->\fIas_string()\fR" 4
.IX Item "$feature->as_string()"
Internal method used to implement overloaded stringification.
.ie n .IP "$boolean = $feature\->type_match(@list_of_types)" 4
.el .IP "$boolean = \f(CW$feature\fR\->type_match(@list_of_types)" 4
.IX Item "$boolean = $feature->type_match(@list_of_types)"
Internal method that will return true if the feature's primary_tag and
source_tag match any of the list of types (in primary_tag:source_tag
format) provided.
.SH "BUGS"
.IX Header "BUGS"
This is an early version, so there are certainly some bugs. Please
use the BioPerl bug tracking system to report bugs.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
bioperl,
Bio::DB::SeqFeature::Store,
Bio::DB::SeqFeature::Segment,
Bio::DB::SeqFeature::NormalizedFeature,
Bio::DB::SeqFeature::GFF3Loader,
Bio::DB::SeqFeature::Store::DBI::mysql,
Bio::DB::SeqFeature::Store::bdb
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln Stein <lstein@cshl.org>.
.PP
Copyright (c) 2006 Cold Spring Harbor Laboratory.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
