.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::SeqFeature::Store::GFF3Loader 3"
.TH Bio::DB::SeqFeature::Store::GFF3Loader 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::DB::SeqFeature::Store::GFF3Loader \-\- GFF3 file loader for Bio::DB::SeqFeature::Store
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Bio::DB::SeqFeature::Store;
.Ve
.PP
.Vb 4
\&  # Open the sequence database
\&  my $db      = Bio::DB::SeqFeature::Store->new( -adaptor => 'DBI::mysql',
\&                                                 -dsn     => 'dbi:mysql:test',
\&                                                 -write   => 1 );
.Ve
.PP
.Vb 3
\&  my $loader = Bio::DB::SeqFeature::Store::GFF3Loader->new(-store    => $db,
\&                                                           -verbose  => 1,
\&                                                           -fast     => 1);
.Ve
.PP
.Vb 1
\&  $loader->load('./my_genome.gff3');
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Bio::DB::SeqFeature::Store::GFF3Loader object parsers GFF3\-format
sequence annotation files and loads Bio::DB::SeqFeature::Store
databases. For certain combinations of SeqFeature classes and
SeqFeature::Store databases it features a \*(L"fast load\*(R" mode which will
greatly accelerate the loading of \s-1GFF3\s0 databases by a factor of 5\-10.
.PP
The \s-1GFF3\s0 file format has been extended very slightly to accomodate
Bio::DB::SeqFeature::Store. First, the loader recognizes is a new
directive:
.PP
.Vb 1
\&  # #index-subfeatures [0|1]
.Ve
.PP
Note that you can place a space between the two #'s in order to
prevent \s-1GFF3\s0 validators from complaining.
.PP
If this is true, then subfeatures are indexed (the default) so that
they can be retrieved with a query. See Bio::DB::SeqFeature::Store
for an explanation of this. If false, then subfeatures can only be
accessed through their parent feature. The default is to index all
subfeatures.
.PP
Second, the loader recognizes a new attribute tag called index, which
if present, controls indexing of the current feature. Example:
.PP
.Vb 1
\& ctg123 . TF_binding_site 1000 1012 . + . ID=tfbs00001;index=1
.Ve
.PP
You can use this to turn indexing on and off, overriding the default
for a particular feature.
.Sh "new"
.IX Subsection "new"
.Vb 6
\& Title   : new
\& Usage   : $loader = Bio::DB::SeqFeature::Store::GFF3Loader->new(@options)
\& Function: create a new parser
\& Returns : a Bio::DB::SeqFeature::Store::GFF3Loader gff3 parser and loader
\& Args    : several - see below
\& Status  : public
.Ve
.PP
This method creates a new \s-1GFF3\s0 loader and establishes its connection
with a Bio::DB::SeqFeature::Store database. Arguments are \-name=>$value
pairs as described in this table:
.PP
.Vb 2
\& Name               Value
\& ----               -----
.Ve
.PP
.Vb 1
\& -store             A writeable Bio::DB::SeqFeature::Store database handle.
.Ve
.PP
.Vb 2
\& -seqfeature_class  The name of the type of Bio::SeqFeatureI object to create
\&                      and store in the database (Bio::DB::SeqFeature by default)
.Ve
.PP
.Vb 1
\& -sf_class          A shorter alias for -seqfeature_class
.Ve
.PP
.Vb 1
\& -verbose           Send progress information to standard error.
.Ve
.PP
.Vb 1
\& -fast              If true, activate fast loading (see below)
.Ve
.PP
.Vb 2
\& -chunk_size        Set the storage chunk size for nucleotide/protein sequences
\&                       (default 2000 bytes)
.Ve
.PP
.Vb 2
\& -tmp               Indicate a temporary directory to use when loading non-normalized
\&                       features.
.Ve
.PP
When you call \fInew()\fR, a connection to a Bio::DB::SeqFeature::Store
database should already have been established and the database
initialized (if appropriate).
.PP
Some combinations of Bio::SeqFeatures and Bio::DB::SeqFeature::Store
databases support a fast loading mode. Currently the only reliable
implementation of fast loading is the combination of DBI::mysql with
Bio::DB::SeqFeature. The other important restriction on fast loading
is the requirement that a feature that contains subfeatures must occur
in the \s-1GFF3\s0 file before any of its subfeatures. Otherwise the
subfeatures that occurred before the parent feature will not be
attached to the parent correctly. This restriction does not apply to
normal (slow) loading.
.PP
If you use an unnormalized feature class, such as
Bio::SeqFeature::Generic, then the loader needs to create a temporary
database in which to cache features until all their parts and subparts
have been seen. This temporary databases uses the \*(L"bdb\*(R" adaptor. The
\&\-tmp option specifies the directory in which that database will be
created. If not present, it defaults to the system default tmp
directory specified by File::Spec\->\fItmpdir()\fR.
.PP
The \-chunk_size option allows you to tune the representation of
DNA/Protein sequence in the Store database. By default, sequences are
split into 2000 base/residue chunks and then reassembled as
needed. This avoids the problem of pulling a whole chromosome into
memory in order to fetch a short subsequence from somewhere in the
middle. Depending on your usage patterns, you may wish to tune this
parameter using a chunk size that is larger or smaller than the
default.
.Sh "load"
.IX Subsection "load"
.Vb 6
\& Title   : load
\& Usage   : $count = $loader->load(@ARGV)
\& Function: load the indicated files or filehandles
\& Returns : number of feature lines loaded
\& Args    : list of files or filehandles
\& Status  : public
.Ve
.PP
Once the loader is created, invoke its \fIload()\fR method with a list of
\&\s-1GFF3\s0 or \s-1FASTA\s0 file paths or previously-opened filehandles in order to
load them into the database. Compressed files ending with .gz, .Z and
\&.bz2 are automatically recognized and uncompressed on the fly. Paths
beginning with http: or ftp: are treated as URLs and opened using the
\&\s-1LWP\s0 \s-1GET\s0 program (which must be on your path).
.PP
\&\s-1FASTA\s0 files are recognized by their initial ">" character. Do not feed
the loader a file that is neither \s-1GFF3\s0 nor \s-1FASTA\s0; I don't know what
will happen, but it will probably not be what you expect.
.Sh "accessors"
.IX Subsection "accessors"
The following read-only accessors return values passed or created during \fInew()\fR:
.PP
.Vb 1
\& store()          the long-term Bio::DB::SeqFeature::Store object
.Ve
.PP
.Vb 2
\& tmp_store()      the temporary Bio::DB::SeqFeature::Store object used
\&                    during loading
.Ve
.PP
.Vb 1
\& sfclass()        the Bio::SeqFeatureI class
.Ve
.PP
.Vb 1
\& fast()           whether fast loading is active
.Ve
.PP
.Vb 1
\& seq_chunk_size() the sequence chunk size
.Ve
.PP
.Vb 1
\& verbose()        verbose progress messages
.Ve
.Sh "Internal Methods"
.IX Subsection "Internal Methods"
The following methods are used internally and may be overidden by
subclasses.
.IP "default_seqfeature_class" 4
.IX Item "default_seqfeature_class"
.Vb 1
\&  $class = $loader->default_seqfeature_class
.Ve
.Sp
Return the default SeqFeatureI class (Bio::DB::SeqFeature).
.IP "subfeatures_normalized" 4
.IX Item "subfeatures_normalized"
.Vb 1
\&  $flag = $loader->subfeatures_normalized([$new_flag])
.Ve
.Sp
Get or set a flag that indicates that the subfeatures are
normalized. This is deduced from the SeqFeature class information.
.IP "subfeatures_in_table" 4
.IX Item "subfeatures_in_table"
.Vb 1
\&  $flag = $loader->subfeatures_in_table([$new_flag])
.Ve
.Sp
Get or set a flag that indicates that feature/subfeature relationships
are stored in a table. This is deduced from the SeqFeature class and
Store information.
.IP "load_fh" 4
.IX Item "load_fh"
.Vb 1
\&  $count = $loader->load_fh($filehandle)
.Ve
.Sp
Load the \s-1GFF3\s0 data at the other end of the filehandle and return true
if successful. Internally, \fIload_fh()\fR invokes:
.Sp
.Vb 3
\&  start_load();
\&  do_load($filehandle);
\&  finish_load();
.Ve
.IP "start_load, finish_load" 4
.IX Item "start_load, finish_load"
These methods are called at the start and end of a filehandle load.
.IP "do_load" 4
.IX Item "do_load"
.Vb 1
\&  $count = $loader->do_load($fh)
.Ve
.Sp
This is called by \fIload_fh()\fR to load the \s-1GFF3\s0 file's filehandle and
return the number of lines loaded.
.IP "handle_meta" 4
.IX Item "handle_meta"
.Vb 1
\&  $loader->handle_meta($meta_directive)
.Ve
.Sp
This method is called to handle meta-directives such as
##sequence\-region. The method will receive the directive with the
initial ## stripped off.
.IP "handle_feature" 4
.IX Item "handle_feature"
.Vb 1
\&  $loader->handle_feature($gff3_line)
.Ve
.Sp
This method is called to process a single \s-1GFF3\s0 line. It manipulates
information stored a data structure called \f(CW$self\fR\->{load_data}.
.IP "store_current_feature" 4
.IX Item "store_current_feature"
.Vb 1
\&  $loader->store_current_feature()
.Ve
.Sp
This method is called to store the currently active feature in the
database. It uses a data structure stored in \f(CW$self\fR\->{load_data}.
.IP "build_object_tree" 4
.IX Item "build_object_tree"
.Vb 1
\& $loader->build_object_tree()
.Ve
.Sp
This method gathers together features and subfeatures and builds the graph that connects them.
.IP "build_object_tree_in_tables" 4
.IX Item "build_object_tree_in_tables"
.Vb 1
\& $loader->build_object_tree_in_tables()
.Ve
.Sp
This method gathers together features and subfeatures and builds the
graph that connects them, assuming that parent/child relationships
will be stored in a database table.
.IP "build_object_tree_in_features" 4
.IX Item "build_object_tree_in_features"
.Vb 1
\& $loader->build_object_tree_in_features()
.Ve
.Sp
This method gathers together features and subfeatures and builds the
graph that connects them, assuming that parent/child relationships are
stored in the seqfeature objects themselves.
.IP "attach_children" 4
.IX Item "attach_children"
.Vb 1
\& $loader->attach_children($store,$load_data,$load_id,$feature)
.Ve
.Sp
This recursively adds children to features and their subfeatures. It
is called when subfeatures are directly contained within other
features, rather than stored in a relational table.
.IP "fetch" 4
.IX Item "fetch"
.Vb 1
\& my $feature = $loader->fetch($load_id)
.Ve
.Sp
Given a load \s-1ID\s0 (from the ID= attribute) this method returns the
feature from the temporary database or the permanent one, depending on
where it is stored.
.IP "add_segment" 4
.IX Item "add_segment"
.Vb 1
\& $loader->add_segment($parent,$child)
.Ve
.Sp
This method is used to add a split location to the parent.
.IP "parse_attributes" 4
.IX Item "parse_attributes"
.Vb 1
\& ($reserved,$unreserved) = $loader->parse_attributes($attribute_line)
.Ve
.Sp
This method parses the information contained in the \f(CW$attribute_line\fR
into two hashrefs, one containing the values of reserved attribute
tags (e.g. \s-1ID\s0) and the other containing the values of unreserved ones.
.IP "start_or_finish_sequence" 4
.IX Item "start_or_finish_sequence"
.Vb 1
\&  $loader->start_or_finish_sequence('Chr9')
.Ve
.Sp
This method is called at the beginning and end of a fasta section.
.IP "load_sequence" 4
.IX Item "load_sequence"
.Vb 1
\&  $loader->load_sequence('gatttcccaaa')
.Ve
.Sp
This method is called to load some amount of sequence after
\&\fIstart_or_finish_sequence()\fR is first called.
.IP "open_fh" 4
.IX Item "open_fh"
.Vb 1
\& my $io_file = $loader->open_fh($filehandle_or_path)
.Ve
.Sp
This method opens up the indicated file or pipe, using some intelligence to recognized compressed files and URLs and doing 
the right thing.
.IP "time" 4
.IX Item "time"
.Vb 1
\& my $time = $loader->time
.Ve
.Sp
This method returns the current time in seconds, using Time::HiRes if available.
.IP "escape" 4
.IX Item "escape"
.Vb 1
\& my $unescaped = GFF3Loader::unescape($escaped)
.Ve
.Sp
This is an internal utility.  It is the same as CGI::Util::unescape,
but don't change pluses into spaces and ignores unicode escapes.
.SH "BUGS"
.IX Header "BUGS"
This is an early version, so there are certainly some bugs. Please
use the BioPerl bug tracking system to report bugs.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
bioperl,
Bio::DB::SeqFeature::Store,
Bio::DB::SeqFeature::Segment,
Bio::DB::SeqFeature::NormalizedFeature,
Bio::DB::SeqFeature::GFF3Loader,
Bio::DB::SeqFeature::Store::DBI::mysql,
Bio::DB::SeqFeature::Store::bdb
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln Stein <lstein@cshl.org>.
.PP
Copyright (c) 2006 Cold Spring Harbor Laboratory.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
