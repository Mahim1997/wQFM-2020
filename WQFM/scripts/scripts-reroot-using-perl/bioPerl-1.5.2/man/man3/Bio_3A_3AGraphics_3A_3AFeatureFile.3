.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Graphics::FeatureFile 3"
.TH Bio::Graphics::FeatureFile 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Graphics::FeatureFile \-\- A set of Bio::Graphics features, stored in a file
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& use Bio::Graphics::FeatureFile;
\& my $data  = Bio::Graphics::FeatureFile->new(-file => 'features.txt');
.Ve
.PP
.Vb 3
\& # create a new panel and render contents of the file onto it
\& my $panel = $data->new_panel;
\& my $tracks_rendered = $data->render($panel);
.Ve
.PP
.Vb 2
\& # or do it all in one step
\& my ($tracks_rendered,$panel) = $data->render;
.Ve
.PP
.Vb 7
\& # for more control, render tracks individually
\& my @feature_types = $data->types;
\& for my $type (@feature_types) {
\&    my $features = $data->features($type);
\&    my %options  = $data->style($type);
\&    $panel->add_track($features,%options);  # assuming we have a Bio::Graphics::Panel
\& }
.Ve
.PP
.Vb 2
\& # get individual settings
\& my $est_fg_color = $data->setting(EST => 'fgcolor');
.Ve
.PP
.Vb 1
\& # or create the FeatureFile by hand
.Ve
.PP
.Vb 2
\& # add a type
\& $data->add_type(EST => {fgcolor=>'blue',height=>12});
.Ve
.PP
.Vb 5
\& # add a feature
\& my $feature = Bio::Graphics::Feature->new(
\&                                             # params
\&                                          ); # or some other SeqI
\& $data->add_feature($feature=>'EST');
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Bio::Graphics::FeatureFile module reads and parses files that
describe sequence features and their renderings.  It accepts both \s-1GFF\s0
format and a more human-friendly file format described below.  Once a
FeatureFile object has been initialized, you can interrogate it for
its consistuent features and their settings, or render the entire file
onto a Bio::Graphics::Panel.
.PP
This module is a precursor of Jason Stajich's
Bio::Annotation::Collection class, and fulfills a similar function of
storing a collection of sequence features.  However, it also stores
rendering information about the features, and does not currently
follow the CollectionI interface.
.Sh "The File Format"
.IX Subsection "The File Format"
There are two types of entry in the file format: feature entries, and
formatting entries.  They can occur in any order.  See the Appendix
for a full example.
.PP
Feature entries can take several forms.  At their simplest, they look
like this:
.PP
.Vb 1
\& Gene   B0511.1 516-11208
.Ve
.PP
This means that a feature of type \*(L"Gene\*(R" and name \*(L"B0511.1\*(R" occupies
the range between bases 516 and 11208.  A range can be specified
equally well using a hyphen, or two dots as in 516..11208.  Negative
coordinates are allowed, such as \-187..1000.
.PP
A discontinuous range (\*(L"split location\*(R") uses commas to separate the
ranges.  For example:
.PP
.Vb 1
\& Gene B0511.1  516-619,3185-3294,10946-11208
.Ve
.PP
Alternatively, the locations can be split by repeating the features
type and name on multiple adjacent lines:
.PP
.Vb 3
\& Gene   B0511.1 516-619
\& Gene   B0511.1 3185-3294
\& Gene   B0511.1 10946-11208
.Ve
.PP
A comment can be added to features by adding a fourth column.  These
comments will be rendered as under-the-glyph descriptions by those
glyphs that honor descriptions:
.PP
.Vb 1
\& Gene  B0511.1  516-619,3185-3294,10946-11208 "Putative primase"
.Ve
.PP
Columns are separated using whitespace, not (necessarily) tabs.
Embedded whitespace can be escaped using quote marks or backslashes in
the same way as in the shell:
.PP
.Vb 1
\& 'Putative Gene' my\e favorite\e gene 516-11208
.Ve
.PP
Features can be grouped so that they are rendered by the \*(L"group\*(R" glyph
(so far this has only been used to relate 5' and 3' ESTs).  To start a
group, create a two-column feature entry showing the group type and a
name for the group.  Follow this with a list of feature entries with a
blank type.  For example:
.PP
.Vb 3
\& EST    yk53c10
\&        yk53c10.3       15000-15500,15700-15800
\&        yk53c10.5       18892-19154
.Ve
.PP
This example is declaring that the ESTs named yk53c10.3 and yk53c10.5
belong to the same group named yk53c10.  
.Sh "\s-1METHODS\s0"
.IX Subsection "METHODS"
.IP "$features = Bio::Graphics::FeatureFile\->new(@args)" 4
.IX Item "$features = Bio::Graphics::FeatureFile->new(@args)"
Create a new Bio::Graphics::FeatureFile using \f(CW@args\fR to initialize the
object.  Arguments are \-name=>value pairs:
.Sp
.Vb 2
\&  Argument         Value
\&  --------         -----
.Ve
.Sp
.Vb 2
\&   -file           Read data from a file path or filehandle.  Use
\&                   "-" to read from standard input.
.Ve
.Sp
.Vb 1
\&   -text           Read data from a text scalar.
.Ve
.Sp
.Vb 2
\&   -map_coords     Coderef containing a subroutine to use for remapping
\&                   all coordinates.
.Ve
.Sp
.Vb 3
\&   -smart_features Flag indicating that the features created by this
\&                   module should be made aware of the FeatureFile
\&                   object by calling their configurator() method.
.Ve
.Sp
.Vb 3
\&   -safe           Indicates that the contents of this file is trusted.
\&                   Any option value that begins with the string "sub {"
\&                   or \e&subname will be evaluated as a code reference.
.Ve
.Sp
The \-file and \-text arguments are mutually exclusive, and \-file will
supersede the other if both are present.
.Sp
\&\-map_coords points to a coderef with the following signature:
.Sp
.Vb 2
\&  ($newref,[$start1,$end1],[$start2,$end2]....)
\&            = coderef($ref,[$start1,$end1],[$start2,$end2]...)
.Ve
.Sp
See the Bio::Graphics::Browser (part of the generic genome browser
package) for an illustration of how to use this to do wonderful stuff.
.Sp
The \-smart_features flag is used by the generic genome browser to
provide features with a way to access the link-generation code.  See
gbrowse for how this works.
.Sp
If the file is trusted, and there is an option named \*(L"init_code\*(R" in
the [\s-1GENERAL\s0] section of the file, it will be evaluated as perl code
immediately after parsing.  You can use this to declare global
variables and subroutines for use in option values.
.ie n .IP "($rendered,$panel) = $features\fR\->render([$panel, \f(CW$position_to_insert\fR, \f(CW$options\fR, \f(CW$max_bump\fR, \f(CW$max_label\fR, \f(CW$selector])" 4
.el .IP "($rendered,$panel) = \f(CW$features\fR\->render([$panel, \f(CW$position_to_insert\fR, \f(CW$options\fR, \f(CW$max_bump\fR, \f(CW$max_label\fR, \f(CW$selector\fR])" 4
.IX Item "($rendered,$panel) = $features->render([$panel, $position_to_insert, $options, $max_bump, $max_label, $selector])"
Render features in the data set onto the indicated
Bio::Graphics::Panel.  If no panel is specified, creates one.
.Sp
All arguments are optional.
.Sp
$panel is a Bio::Graphics::Panel that has previously been created and
configured.
.Sp
$position_to_insert indicates the position at which to start inserting
new tracks. The last current track on the panel is assumed.
.Sp
$options is a scalar used to control automatic expansion of the
tracks. 0=auto, 1=compact, 2=expanded, 3=expand and label,
4=hyperexpand, 5=hyperexpand and label.
.Sp
$max_bump and \f(CW$max_label\fR indicate the maximum number of features
before bumping and labeling are turned off.
.Sp
$selector is a code ref that can be used to filter which features to
render. It receives a feature and should return true to include the
feature and false to exclude it.
.Sp
In a scalar context returns the number of tracks rendered.  In a list
context, returns a three-element list containing the number of
features rendered, the created panel, and a list of all the track
objects created.
.ie n .IP "$error = $features\->error([$error])" 4
.el .IP "$error = \f(CW$features\fR\->error([$error])" 4
.IX Item "$error = $features->error([$error])"
Get/set the current error message.
.ie n .IP "$smart_features = $features\->smart_features([$flag]" 4
.el .IP "$smart_features = \f(CW$features\fR\->smart_features([$flag]" 4
.IX Item "$smart_features = $features->smart_features([$flag]"
Get/set the \*(L"smart_features\*(R" flag.  If this is set, then any features
added to the featurefile object will have their \fIconfigurator()\fR method
called using the featurefile object as the argument.
.IP "$features\->add_feature($feature [=>$type])" 4
.IX Item "$features->add_feature($feature [=>$type])"
Add a new Bio::FeatureI object to the set.  If \f(CW$type\fR is specified, the
object will be added with the indicated type.  Otherwise, the
feature's \fIprimary_tag()\fR method will be invoked to get the type.
.IP "$features\->add_type($type=>$hashref)" 4
.IX Item "$features->add_type($type=>$hashref)"
Add a new feature type to the set.  The type is a string, such as
\&\*(L"\s-1EST\s0\*(R".  The hashref is a set of key=>value pairs indicating options to
set on the type.  Example:
.Sp
.Vb 1
\&  $features->add_type(EST => { glyph => 'generic', fgcolor => 'blue'})
.Ve
.Sp
When a feature of type \*(L"\s-1EST\s0\*(R" is rendered, it will use the generic
glyph and have a foreground color of blue.
.IP "$features\->set($type,$tag,$value)" 4
.IX Item "$features->set($type,$tag,$value)"
Change an individual option for a particular type.  For example, this
will change the foreground color of \s-1EST\s0 features to my favorite color:
.Sp
.Vb 1
\&  $features->set('EST',fgcolor=>'chartreuse')
.Ve
.ie n .IP "$value = $features\fR\->setting($stanza => \f(CW$option)" 4
.el .IP "$value = \f(CW$features\fR\->setting($stanza => \f(CW$option\fR)" 4
.IX Item "$value = $features->setting($stanza => $option)"
In the two-element form, the \fIsetting()\fR method returns the value of an
option in the configuration stanza indicated by \f(CW$stanza\fR.  For example:
.Sp
.Vb 1
\&  $value = $features->setting(general => 'height')
.Ve
.Sp
will return the value of the \*(L"height\*(R" option in the [general] stanza.
.Sp
Call with one element to retrieve all the option names in a stanza:
.Sp
.Vb 1
\&  @options = $features->setting('general');
.Ve
.Sp
Call with no elements to retrieve all stanza names:
.Sp
.Vb 1
\&  @stanzas = $features->setting;
.Ve
.ie n .IP "$value = $features\->code_setting($stanza=>$option);" 4
.el .IP "$value = \f(CW$features\fR\->code_setting($stanza=>$option);" 4
.IX Item "$value = $features->code_setting($stanza=>$option);"
This works like \fIsetting()\fR except that it is also able to evaluate code
references.  These are options whose values begin with the characters
\&\*(L"sub {\*(R".  In this case the value will be passed to an \fIeval()\fR and the
resulting codereference returned.  Use this with care!
.ie n .IP "$flag = $features\->safe([$flag]);" 4
.el .IP "$flag = \f(CW$features\fR\->safe([$flag]);" 4
.IX Item "$flag = $features->safe([$flag]);"
This gets or sets and \*(L"safe\*(R" flag.  If the safe flag is set, then
calls to \fIsetting()\fR will invoke \fIcode_setting()\fR, allowing values that
begin with the string \*(L"sub {\*(R" to be interpreted as anonymous
subroutines.  This is a potential security risk when used with
untrusted files of features, so use it with care.
.ie n .IP "@args = $features\->style($type)" 4
.el .IP "@args = \f(CW$features\fR\->style($type)" 4
.IX Item "@args = $features->style($type)"
Given a feature type, returns a list of track configuration arguments
suitable for suitable for passing to the
Bio::Graphics::Panel\->\fIadd_track()\fR method.
.ie n .IP "$glyph = $features\->glyph($type);" 4
.el .IP "$glyph = \f(CW$features\fR\->glyph($type);" 4
.IX Item "$glyph = $features->glyph($type);"
Return the name of the glyph corresponding to the given type (same as
\&\f(CW$features\fR\->setting($type=>'glyph')).
.ie n .IP "@types = $features\fR\->\fIconfigured_types()" 4
.el .IP "@types = \f(CW$features\fR\->\fIconfigured_types()\fR" 4
.IX Item "@types = $features->configured_types()"
Return a list of all the feature types currently known to the feature
file set.  Roughly equivalent to:
.Sp
.Vb 1
\&  @types = grep {$_ ne 'general'} $features->setting;
.Ve
.ie n .IP "@types = $features\fR\->\fItypes()" 4
.el .IP "@types = \f(CW$features\fR\->\fItypes()\fR" 4
.IX Item "@types = $features->types()"
This is similar to the previous method, but will return *all* feature
types, including those that are not configured with a stanza.
.ie n .IP "$features = $features\->features($type)" 4
.el .IP "$features = \f(CW$features\fR\->features($type)" 4
.IX Item "$features = $features->features($type)"
Return a list of all the feature types of type \*(L"$type\*(R".  If the
featurefile object was created by parsing a file or text scalar, then
the features will be of type Bio::Graphics::Feature (which follow the
Bio::FeatureI interface).  Otherwise the list will contain objects of
whatever type you added with calls to \fIadd_feature()\fR.
.Sp
Two APIs:
.Sp
.Vb 1
\&  1) original API:
.Ve
.Sp
.Vb 2
\&      # Reference to an array of all features of type "$type"
\&      $features = $features-E<gt>features($type)
.Ve
.Sp
.Vb 2
\&      # Reference to an array of all features of all types
\&      $features = $features-E<gt>features()
.Ve
.Sp
.Vb 2
\&      # A list when called in a list context
\&      @features = $features-E<gt>features()
.Ve
.Sp
.Vb 1
\&   2) Bio::Das::SegmentI API:
.Ve
.Sp
.Vb 1
\&       @features = $features-E<gt>features(-type=>['list','of','types']);
.Ve
.Sp
.Vb 4
\&       # variants
\&       $features = $features-E<gt>features(-type=>['list','of','types']);
\&       $features = $features-E<gt>features(-type=>'a type');
\&       $iterator = $features-E<gt>features(-type=>'a type',-iterator=>1);
.Ve
.ie n .IP "@features = $features\->features($type)" 4
.el .IP "@features = \f(CW$features\fR\->features($type)" 4
.IX Item "@features = $features->features($type)"
Return a list of all the feature types of type \*(L"$type\*(R".  If the
featurefile object was created by parsing a file or text scalar, then
the features will be of type Bio::Graphics::Feature (which follow the
Bio::FeatureI interface).  Otherwise the list will contain objects of
whatever type you added with calls to \fIadd_feature()\fR.
.Sh "get_seq_stream"
.IX Subsection "get_seq_stream"
.Vb 6
\& Title   : get_seq_stream
\& Usage   : $stream = $s->get_seq_stream(@args)
\& Function: get a stream of features that overlap this segment
\& Returns : a Bio::SeqIO::Stream-compliant stream
\& Args    : see below
\& Status  : Public
.Ve
.PP
This is the same as \fIfeature_stream()\fR, and is provided for Bioperl
compatibility.  Use like this:
.PP
.Vb 4
\& $stream = $s->get_seq_stream('exon');
\& while (my $exon = $stream->next_seq) {
\&    print $exon->start,"\en";
\& }
.Ve
.Sh "get_feature_by_name"
.IX Subsection "get_feature_by_name"
.Vb 5
\& Usage   : $db->get_feature_by_name(-name => $name)
\& Function: fetch features by their name
\& Returns : a list of Bio::DB::GFF::Feature objects
\& Args    : the name of the desired feature
\& Status  : public
.Ve
.PP
This method can be used to fetch a named feature from the file.
.PP
The full syntax is as follows.  Features can be filtered by
their reference, start and end positions
.PP
.Vb 4
\&  @f = $db->get_feature_by_name(-name  => $name,
\&                                -ref   => $sequence_name,
\&                                -start => $start,
\&                                -end   => $end);
.Ve
.PP
This method may return zero, one, or several Bio::Graphics::Feature
objects.
.Sh "search_notes"
.IX Subsection "search_notes"
.Vb 6
\& Title   : search_notes
\& Usage   : @search_results = $db->search_notes("full text search string",$limit)
\& Function: Search the notes for a text string
\& Returns : array of results
\& Args    : full text search string, and an optional row limit
\& Status  : public
.Ve
.PP
Each row of the returned array is a arrayref containing the following fields:
.PP
.Vb 3
\&  column 1     Display name of the feature
\&  column 2     The text of the note
\&  column 3     A relevance score.
.Ve
.Sh "\fIget_feature_stream()\fP, \fItop_SeqFeatures()\fP, \fIall_SeqFeatures()\fP"
.IX Subsection "get_feature_stream(), top_SeqFeatures(), all_SeqFeatures()"
Provided for compatibility with older BioPerl and/or Bio::DB::GFF
APIs.
.ie n .IP "@refs = $features\->refs" 4
.el .IP "@refs = \f(CW$features\fR\->refs" 4
.IX Item "@refs = $features->refs"
Return the list of reference sequences referred to by this data file.
.ie n .IP "$min = $features\->min" 4
.el .IP "$min = \f(CW$features\fR\->min" 4
.IX Item "$min = $features->min"
Return the minimum coordinate of the leftmost feature in the data set.
.ie n .IP "$max = $features\->max" 4
.el .IP "$max = \f(CW$features\fR\->max" 4
.IX Item "$max = $features->max"
Return the maximum coordinate of the rightmost feature in the data set.
.ie n .IP "$mtime = $features\->mtime" 4
.el .IP "$mtime = \f(CW$features\fR\->mtime" 4
.IX Item "$mtime = $features->mtime"
.PD 0
.ie n .IP "$atime = $features\->atime" 4
.el .IP "$atime = \f(CW$features\fR\->atime" 4
.IX Item "$atime = $features->atime"
.ie n .IP "$ctime = $features\->ctime" 4
.el .IP "$ctime = \f(CW$features\fR\->ctime" 4
.IX Item "$ctime = $features->ctime"
.ie n .IP "$size = $features\->size" 4
.el .IP "$size = \f(CW$features\fR\->size" 4
.IX Item "$size = $features->size"
.PD
Returns \fIstat()\fR information about the data file, for featurefile
objects created using the \-file option.  Size is in bytes.  mtime,
atime, and ctime are in seconds since the epoch.
.ie n .IP "$label = $features\->feature2label($feature)" 4
.el .IP "$label = \f(CW$features\fR\->feature2label($feature)" 4
.IX Item "$label = $features->feature2label($feature)"
Given a feature, determines the configuration stanza that bests
describes it.  Uses the feature's \fItype()\fR method if it has it (DasI
interface) or its \fIprimary_tag()\fR method otherwise.
.ie n .IP "$link = $features\->link_pattern($linkrule,$feature,$panel)" 4
.el .IP "$link = \f(CW$features\fR\->link_pattern($linkrule,$feature,$panel)" 4
.IX Item "$link = $features->link_pattern($linkrule,$feature,$panel)"
Given a feature, tries to generate a \s-1URL\s0 to link out from it.  This
uses the 'link' option, if one is present.  This method is a
convenience for the generic genome browser.
.ie n .IP "$citation = $features\->citation($feature)" 4
.el .IP "$citation = \f(CW$features\fR\->citation($feature)" 4
.IX Item "$citation = $features->citation($feature)"
Given a feature, tries to generate a citation for it, using the
\&\*(L"citation\*(R" option if one is present.  This method is a convenience for
the generic genome browser.
.ie n .IP "$name = $features\->name([$feature])" 4
.el .IP "$name = \f(CW$features\fR\->name([$feature])" 4
.IX Item "$name = $features->name([$feature])"
Get/set the name of this feature set.  This is a convenience method
useful for keeping track of multiple feature sets.
.SH "Appendix \*(-- Sample Feature File"
.IX Header "Appendix  Sample Feature File"
.Vb 6
\& # file begins
\& [general]
\& pixels = 1024
\& bases = 1-20000
\& reference = Contig41
\& height = 12
.Ve
.PP
.Vb 4
\& [Cosmid]
\& glyph = segments
\& fgcolor = blue
\& key = C. elegans conserved regions
.Ve
.PP
.Vb 5
\& [EST]
\& glyph = segments
\& bgcolor= yellow
\& connector = dashed
\& height = 5;
.Ve
.PP
.Vb 4
\& [FGENESH]
\& glyph = transcript2
\& bgcolor = green
\& description = 1
.Ve
.PP
.Vb 20
\& Cosmid B0511   516-619
\& Cosmid B0511   3185-3294
\& Cosmid B0511   10946-11208
\& Cosmid B0511   13126-13511
\& Cosmid B0511   11394-11539
\& EST    yk260e10.5      15569-15724
\& EST    yk672a12.5      537-618,3187-3294
\& EST    yk595e6.5       552-618
\& EST    yk595e6.5       3187-3294
\& EST    yk846e07.3      11015-11208
\& EST    yk53c10
\&        yk53c10.3       15000-15500,15700-15800
\&        yk53c10.5       18892-19154
\& EST    yk53c10.5       16032-16105
\& SwissProt      PECANEX 13153-13656     Swedish fish
\& FGENESH        Predicted gene 1        1-205,518-616,661-735,3187-3365,3436-3846       Pfam domain
\& FGENESH        Predicted gene 2        5513-6497,7968-8136,8278-8383,8651-8839,9462-9515,10032-10705,10949-11340,11387-11524,11765-12067,12876-13577,13882-14121,14169-14535,15006-15209,15259-15462,15513-15753,15853-16219   Mysterious
\& FGENESH        Predicted gene 3        16626-17396,17451-17597
\& FGENESH        Predicted gene 4        18459-18722,18882-19176,19221-19513,19572-19835 Transmembrane protein
\& # file ends
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Bio::Graphics::Panel,
Bio::Graphics::Glyph,
Bio::Graphics::Feature,
Bio::Graphics::FeatureFile
.SH "AUTHOR"
.IX Header "AUTHOR"
Lincoln Stein <lstein@cshl.org>.
.PP
Copyright (c) 2001 Cold Spring Harbor Laboratory
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.  See \s-1DISCLAIMER\s0.txt for
disclaimers of warranty.
