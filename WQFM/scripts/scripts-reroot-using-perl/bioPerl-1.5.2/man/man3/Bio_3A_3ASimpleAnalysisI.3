.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::SimpleAnalysisI 3"
.TH Bio::SimpleAnalysisI 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::SimpleAnalysisI \- A simple interface to any (local or remote) analysis tool
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This is an interface module \- you do not instantiate it.
Use other modules instead (those that implement this interface).
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This interface contains public methods for accessing and controlling
local and remote analysis tools. It is meant to be used on the client
side. The interface consists only of a necessary set of methods for
synchronous invocation of analysis tools. For more complex set,
including an asynchronous access, see interface \f(CW\*(C`Bio::AnalysisI\*(C'\fR
(which inherits from this one, by the way).
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Martin Senger (martin.senger@gmail.com)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003, Martin Senger and \s-1EMBL\-EBI\s0.
All Rights Reserved.
.PP
This module is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This software is provided \*(L"as is\*(R" without warranty of any kind.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
http://www.ebi.ac.uk/soaplab/Perl_Client.html
.SH "APPENDIX"
.IX Header "APPENDIX"
This is actually the main documentation...
.PP
If you try to call any of these methods directly on this
\&\f(CW\*(C`Bio::SimpleAnalysisI\*(C'\fR object you will get a \fInot implemented\fR error
message.
.Sh "analysis_name"
.IX Subsection "analysis_name"
.Vb 3
\& Usage   : $tool->analysis_name;
\& Returns : a name of this analysis
\& Args    : none
.Ve
.Sh "analysis_spec"
.IX Subsection "analysis_spec"
.Vb 3
\& Usage   : $tool->analysis_spec;
\& Returns : a hash reference describing this analysis
\& Args    : none
.Ve
.PP
The returned hash reference uses the following keys (not all of them always
present, perhaps others present as well): \f(CW\*(C`name\*(C'\fR, \f(CW\*(C`type\*(C'\fR, \f(CW\*(C`version\*(C'\fR,
\&\f(CW\*(C`supplier\*(C'\fR, \f(CW\*(C`installation\*(C'\fR, \f(CW\*(C`description\*(C'\fR.
.Sh "input_spec"
.IX Subsection "input_spec"
.Vb 3
\& Usage   : $tool->input_spec;
\& Returns : an array reference with hashes as elements
\& Args    : none
.Ve
.PP
The analysis input data are named, and can be also associated with a
default value, with allowed values and with few other attributes. The
names are important for feeding the analysis with the input data (the
inputs are given to methods \f(CW\*(C`run\*(C'\fR and \f(CW\*(C`wait_for\*(C'\fR as name/value
pairs).
.Sh "result_spec"
.IX Subsection "result_spec"
.Vb 4
\& Usage   : $tool->result_spec;
\& Returns : a hash reference with result names as keys
\&           and result types as values
\& Args    : none
.Ve
.PP
An analysis can produce several results, or the same result in several
different formats. All such results are named and can be retrieved
using their names by metod \f(CW\*(C`result\*(C'\fR.
.PP
Here is an example of the result specification:
.PP
.Vb 5
\&  $result_spec = {
\&          'outseq' => 'String',
\&          'report' => 'String',
\&          'detailed_status' => 'String'
\&        };
.Ve
.Sh "run"
.IX Subsection "run"
.Vb 4
\& Usage   : $tool->run ( ['sequence=@my.seq', 'osformat=embl'] )
\& Returns : $self
\& Args    : data and parameters for this execution
\&           (in various formats)
.Ve
.PP
Create a job, start it, and wait for its completion. The method is
identical to the method \f(CW\*(C`wait_for\*(C'\fR. Why there are two methods doing
the same? Because it is expected that the sub-classes may implement
them differently (an example is an interface \f(CW\*(C`Bio::AnalysisI\*(C'\fR which
uses method \f(CW\*(C`run\*(C'\fR for an asynchronous execution and method
\&\f(CW\*(C`wait_for\*(C'\fR for a synchronous one.
.PP
Usually, after this call, you ask for results of the finished job:
.PP
.Vb 1
\&    $analysis->run (...)->result;
.Ve
.PP
The input data and prameters for this execution can be specified in
various ways:
.IP "array reference" 4
.IX Item "array reference"
The array has scalar elements of the form
.Sp
.Vb 1
\&   name = [[@]value]
.Ve
.Sp
where \f(CW\*(C`name\*(C'\fR is the name of an input data or input parameter (see
method \f(CW\*(C`input_spec\*(C'\fR for finding what names are recognized by this
analysis) and \f(CW\*(C`value\*(C'\fR is a value for this data/parameter. If \f(CW\*(C`value\*(C'\fR
is missing a 1 is assumed (which is convenient for the boolean
options). If \f(CW\*(C`value\*(C'\fR starts with \f(CW\*(C`@\*(C'\fR it is treated as a local
filename, and its contents is used as the data/parameter value.
.IP "hash reference" 4
.IX Item "hash reference"
The same as with the array reference but now there is no need to use
an equal sign. The hash keys are input names and hash values their
data. The values can again start with a \f(CW\*(C`@\*(C'\fR sign indicating a local
filename.
.Sh "wait_for"
.IX Subsection "wait_for"
.Vb 3
\& Usage   : $tool->wait_for ( { 'sequence' => '@my,file' } )
\& Returns : $self
\& Args    : the same as for method 'run'
.Ve
.PP
Create a job, start it and wait for its completion. The method is
identical to the method \f(CW\*(C`run\*(C'\fR. See details in the \f(CW\*(C`run\*(C'\fR method.
.Sh "status"
.IX Subsection "status"
.Vb 3
\& Usage   : $tool->status
\& Returns : string describing a status of the execution
\& Args    : none
.Ve
.PP
It returns one of the following strings (and perhaps more if a server
implementation extended possible job states):
.PP
.Vb 3
\&   CREATED              (not run yet)
\&   COMPLETED            (run and finished normally)
\&   TERMINATED_BY_ERROR  (run and finished with an error or a signal)
.Ve
.Sh "result"
.IX Subsection "result"
.Vb 5
\& Usage   : $job->result (...)
\& Returns : a result created by running an analysis
\& Args    : none (but an implementation may choose
\&           to add arguments for instructions how to process
\&           the raw result)
.Ve
.PP
The method returns a scalar representing a result of an executed
job. If the job was terminated by an error the result may contain an
error message instead of the real data (or both, depending on the
implementation).
