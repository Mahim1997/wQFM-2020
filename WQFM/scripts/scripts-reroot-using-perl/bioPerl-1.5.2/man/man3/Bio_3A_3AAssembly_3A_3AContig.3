.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Assembly::Contig 3"
.TH Bio::Assembly::Contig 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Assembly::Contig \- Perl module to hold and manipulate
                     sequence assembly contigs.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    # Module loading
\&    use Bio::Assembly::IO;
.Ve
.PP
.Vb 3
\&    # Assembly loading methods
\&    $aio = new Bio::Assembly::IO(-file=>"test.ace.1",
\&                               -format=>'phrap');
.Ve
.PP
.Vb 4
\&    $assembly = $aio->next_assembly;
\&    foreach $contig ($assembly->all_contigs) {
\&      # do something
\&    }
.Ve
.PP
.Vb 1
\&    # OR, if you want to build the contig yourself,
.Ve
.PP
.Vb 2
\&    use Bio::Assembly::Contig;
\&    $c = Bio::Assembly::Contig->new(-id=>"1");
.Ve
.PP
.Vb 6
\&    $ls  = Bio::LocatableSeq->new(-seq=>"ACCG-T",
\&                                  -id=>"r1",
\&                                  -alphabet=>'dna');
\&    $ls2 = Bio::LocatableSeq->new(-seq=>"ACA-CG-T",
\&                                  -id=>"r2",
\&                                  -alphabet=>'dna');
.Ve
.PP
.Vb 10
\&    $ls_coord = Bio::SeqFeature::Generic->new(-start=>3,
\&                                              -end=>8,
\&                                              -strand=>1);
\&    $ls2_coord = Bio::SeqFeature::Generic->new(-start=>1,
\&                                               -end=>8,
\&                                               -strand=>1);
\&    $c->add_seq($ls);
\&    $c->add_seq($ls2);
\&    $c->set_seq_coord($ls_coord,$ls);
\&    $c->set_seq_coord($ls2_coord,$ls2);
.Ve
.PP
.Vb 3
\&    $con = Bio::LocatableSeq->new(-seq=>"ACACCG-T",
\&                                  -alphabet=>'dna');
\&    $c->set_consensus_sequence($con);
.Ve
.PP
.Vb 2
\&    $l = $c->change_coord('unaligned r2','ungapped consensus',6);
\&    print "6 in unaligned r2 => $l in ungapped consensus\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A contig is as a set of sequences, locally aligned to each other, so
that every sequence has overlapping regions with at least one sequence
in the contig, such that a continuous of overlapping sequences is
formed, allowing the deduction of a consensus sequence which may be
longer than any of the sequences from which it was deduced.
.PP
In this documentation we refer to the overlapping sequences used to
build the contig as \*(L"aligned sequences\*(R" and to the sequence deduced
from the overlap of aligned sequences as the \*(L"consensus\*(R". Methods to
deduce the consensus sequence from aligned sequences were not yet
implemented in this module, but its posssible to add a consensus
sequence deduced by other means, e.g, by the assembly program used to
build the alignment.
.PP
All aligned sequences in a Bio::Assembly::Contig must be Bio::Assembly::Locatable
objects and have a unique \s-1ID\s0. The unique \s-1ID\s0 restriction is due to the
nature of the module's internal data structures and is also a request
of some assembly programs. If two sequences with the same \s-1ID\s0 are added
to a contig, the first sequence added is replaced by the second one.
.Sh "Coordinate_systems"
.IX Subsection "Coordinate_systems"
There are four base coordinate systems in Bio::Assembly::Contig.  When
you need to access contig elements or data that exists on a certain
range or location, you may be specifying coordinates in relation to
different sequences, which may be either the contig consensus or one
of the aligned sequences that were used to do the assembly.
.PP
.Vb 8
\& =========================================================
\&          Name           | Referenced sequence
\& ---------------------------------------------------------
\&   "gapped consensus"    | Contig (with gaps)
\&   "ungapped consensus"  | Contig (without gaps)
\&   "aligned $seqID"      | sequence $seqID (with gaps)
\&   "unaligned $seqID"    | sequence $seqID (without gaps)
\& =========================================================
.Ve
.PP
\&\*(L"gapped consensus\*(R" refers to positions in the aligned consensus
sequence, which is the consensus sequence including the gaps inserted
to align it agains the aligned sequences that were used to assemble
the contig. So, its limits are [ 1, (consensus length + number of gaps
in consensus) ]
.PP
\&\*(L"ungapped consensus\*(R" is a coordinate system based on the consensus
sequence, but excluding consensus gaps. This is just the coordinate
system that you have when considering the consensus sequence alone,
instead of aligned to other sequences.
.PP
\&\*(L"aligned \f(CW$seqID\fR\*(R" refers to locations in the sequence \f(CW$seqID\fR after
alignment of \f(CW$seqID\fR against the consensus sequence (reverse
complementing the original sequence, if needed).  Coordinate 1 in
\&\*(L"aligned \f(CW$seqID\fR\*(R" is equivalent to the start location (first base) of
\&\f(CW$seqID\fR in the consensus sequence, just like if the aligned sequence
\&\f(CW$seqID\fR was a feature of the consensus sequence.
.PP
\&\*(L"unaligned \f(CW$seqID\fR\*(R" is equivalent to a location in the isolated
sequence, just like you would have when considering the sequence
alone, out of an alignment.  When changing coordinates from \*(L"aligned
\&\f(CW$seq2\fR\*(R" to \*(L"unaligned \f(CW$seq2\fR\*(R", if \f(CW$seq2\fR was reverse complemented when
included in the alignment, the output coordinates will be reversed to
fit that fact, i.e. 1 will be changed to length($seq2), 2 will be
length($seq)\-1 and so on.
.PP
An important note: when you change gap coordinates from a gapped
system (\*(L"gapped consensus\*(R" or \*(L"aligned \f(CW$seqID\fR\*(R") to a system that does
not include gaps (\*(L"ungapped consensus\*(R" or \*(L"unaligned \f(CW$seqID\fR\*(R"), the
position returned will be the first location before all gaps
neighboring the input location.
.Sh "Feature_collection"
.IX Subsection "Feature_collection"
Bio::Assembly::Contig stores much information about a contig in a
Bio::Assembly::SeqFeature::Collection object. Relevant information on the
alignment is accessed by selecting features based on their primary
tags (e.g. all features which have a primary tag of the form
\&'_aligned_coord:$seqID', where \f(CW$seqID\fR is an aligned sequence \s-1ID\s0, are
coordinates for sequences in the contig alignment) and, by using
methods from Bio::Assembly::SeqFeature::Collection, it's possible to select
features by overlap with other features.
.PP
We suggest that you use the primary tags of features as identifiers
for feature classes. By convention, features with primary tags
starting with a '_' are generated by modules that populate the contig
data structure and return the contig object, maybe as part of an
assembly object, e.g.  drivers from the Bio::Assembly::IO set.
.PP
Features in the features collection may be associated with particular
aligned sequences. To obtain this, you must attach the sequence to the
feature, using \fIattach()\fR seq from Bio::Assembly::SeqFeatureI, before you add the
feature to the feature collection. We also suggest to add the sequence
id to the primary tag, so that is easy to select feature for a
particular sequence.
.PP
There is only one feature class that some methods in
Bio::Assembly::Contig expect to find in the feature collection: features
with primary tags of the form '_aligned_coord:$seqID', where \f(CW$seqID\fR is
the aligned sequence id (like returned by \f(CW$seq\fR\->\fIid()\fR). These features
describe the position (in \*(L"gapped consensus\*(R" coordinates) of aligned
sequences, and the method \fIset_seq_coord()\fR automatically changes a
feature's primary tag to this form whenever the feature is added to
the collection by this method. Only two methods in Bio::Assembly::Contig
will not work unless there are features from this class:
\&\fIchange_coord()\fR and \fIget_seq_coord()\fR.
.PP
Other feature classes will be automatically available only when
Bio::Assembly::Contig objects are created by a specific module. Such
feature classes are (or should be) documented in the documentation of
the module which create them, to which the user should refer.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to the
Bioperl mailing lists  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Robson Francisco de Souza"
.IX Header "AUTHOR - Robson Francisco de Souza"
rfsouza@citri.iq.usp.br
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SH "Object creator"
.IX Header "Object creator"
.Sh "new"
.IX Subsection "new"
.Vb 8
\& Title     : new
\& Usage     : my $contig = new Bio::Assembly::Contig();
\& Function  : Creates a new contig object
\& Returns   : Bio::Assembly::Contig
\& Args      : -source => string representing the source
\&                        program where this contig came
\&                        from
\&             -id => contig unique ID
.Ve
.SH "Assembly related methods"
.IX Header "Assembly related methods"
These methods exist to enable adding information about possible
relations among contigs, e.g. when you already have a scaffold for
your assembly, describing the ordering of contigs in the final
assembly, but no sequences covering the gaps between neighboring
contigs.
.Sh "source"
.IX Subsection "source"
.Vb 5
\& Title     : source
\& Usage     : $contig->source($program);
\& Function  : Get/Set program used to build this contig
\& Returns   : string
\& Argument  : [optional] string
.Ve
.Sh "assembly"
.IX Subsection "assembly"
.Vb 5
\& Title     : assembly
\& Usage     : $contig->assembly($assembly);
\& Function  : Get/Set assembly object for this contig
\& Returns   : a Bio::Assembly::Scaffold object
\& Argument  : a Bio::Assembly::Scaffold object
.Ve
.Sh "strand"
.IX Subsection "strand"
.Vb 10
\& Title     : strand
\& Usage     : $contig->strand($num);
\& Function  : Get/Set contig orientation in a scaffold/assembly.
\&             Its equivalent to the strand property of sequence
\&             objects and sets whether the contig consensus should
\&             be reversed and complemented before being added to a
\&             scaffold or assembly.
\& Returns   : integer
\& Argument  : 1 if orientaion is forward, -1 if reverse and
\&             0 if none
.Ve
.Sh "upstream_neighbor"
.IX Subsection "upstream_neighbor"
.Vb 7
\& Title     : upstream_neighbor
\& Usage     : $contig->upstream_neighbor($contig);
\& Function  : Get/Set a contig neighbor for the current contig when
\&             building a scaffold. The upstream neighbor is
\&             located before $contig first base
\& Returns   : nothing
\& Argument  : Bio::Assembly::Contig
.Ve
.Sh "downstream_neighbor"
.IX Subsection "downstream_neighbor"
.Vb 7
\& Title     : downstream_neighbor
\& Usage     : $contig->downstream_neighbor($num);
\& Function  : Get/Set a contig neighbor for the current contig when
\&             building a scaffold. The downstream neighbor is
\&             located after $contig last base
\& Returns   : nothing
\& Argument  : Bio::Assembly::Contig
.Ve
.SH "Contig feature collection methods"
.IX Header "Contig feature collection methods"
.Sh "add_features"
.IX Subsection "add_features"
.Vb 3
\& Title     : add_features
\& Usage     : $contig->add_features($feat,$flag)
\& Function  :
.Ve
.PP
.Vb 9
\&             Add an array of features to the contig feature
\&             collection. The consensus sequence may be attached to the
\&             added feature, if $flag is set to 1. If $flag is 0 and
\&             the feature attached to one of the contig aligned
\&             sequences, the feature is registered as an aligned
\&             sequence feature. If $flag is 0 and the feature is not
\&             attched to any sequence in the contig, the feature is
\&             simply added to the feature collection and no attachment
\&             or registration is made.
.Ve
.PP
.Vb 4
\&             Note: You must attach aligned sequences to their features
\&             prior to calling add_features, otherwise you won't be
\&             able to access the feature through get_seq_feat_by_tag()
\&             method.
.Ve
.PP
.Vb 7
\& Returns   : number of features added.
\& Argument  :
\&             $feat : A reference to an array of Bio::SeqFeatureI
\&             $flag : boolean - true if consensus sequence object
\&                     should be attached to this feature, false if
\&                     no consensus attachment should be made.
\&                     Default: false.
.Ve
.Sh "remove_features"
.IX Subsection "remove_features"
.Vb 5
\& Title     : remove_features
\& Usage     : $contig->remove_features(@feat)
\& Function  : Remove an array of contig features
\& Returns   : number of features removed.
\& Argument  : An array of Bio::SeqFeatureI
.Ve
.Sh "get_features_collection"
.IX Subsection "get_features_collection"
.Vb 5
\& Title     : get_features_collection
\& Usage     : $contig->get_features_collection()
\& Function  : Get the collection of all contig features
\& Returns   : Bio::SeqFeature::Collection
\& Argument  : none
.Ve
.SH "Coordinate system's related methods"
.IX Header "Coordinate system's related methods"
See Coordinate_Systems above.
.Sh "change_coord"
.IX Subsection "change_coord"
.Vb 3
\& Title     : change_coord
\& Usage     : $contig->change_coord($in,$out,$query)
\& Function  :
.Ve
.PP
.Vb 3
\&             Change coordinate system for $query.  This method
\&             transforms locations between coordinate systems described
\&             in section "Coordinate Systems" of this document.
.Ve
.PP
.Vb 6
\&             Note: this method will throw an exception when changing
\&             coordinates between "ungapped consensus" and other
\&             systems if consensus sequence was not set. It will also
\&             throw exceptions when changing coordinates among aligned
\&             sequence, either with or without gaps, and other systems
\&             if sequence locations were not set with set_seq_coord().
.Ve
.PP
.Vb 5
\& Returns   : integer
\& Argument  :
\&             $in    : [string]  input coordinate system
\&             $out   : [string]  output coordinate system
\&             $query : [integer] a position in a sequence
.Ve
.Sh "get_seq_coord"
.IX Subsection "get_seq_coord"
.Vb 6
\& Title     : get_seq_coord
\& Usage     : $contig->get_seq_coord($seq);
\& Function  : Get "gapped consensus" location for aligned sequence
\& Returns   : Bio::SeqFeature::Generic for coordinates or undef.
\&             A warning is printed if sequence coordinates were not set.
\& Argument  : Bio::LocatabaleSeq object
.Ve
.Sh "set_seq_coord"
.IX Subsection "set_seq_coord"
.Vb 3
\& Title     : set_seq_coord
\& Usage     : $contig->set_seq_coord($feat,$seq);
\& Function  :
.Ve
.PP
.Vb 5
\&             Set "gapped consensus" location for an aligned
\&             sequence. If the sequence was previously added using
\&             add_seq, its coordinates are changed/set.  Otherwise,
\&             add_seq is called and the sequence is added to the
\&             contig.
.Ve
.PP
.Vb 6
\& Returns   : Bio::SeqFeature::Generic for old coordinates or undef.
\& Argument  :
\&             $feat  : a Bio::SeqFeature::Generic object
\&                      representing a location for the
\&                      aligned sequence, in "gapped
\&                      consensus" coordinates.
.Ve
.PP
.Vb 2
\&             Note: the original feature primary tag will
\&                   be lost.
.Ve
.PP
.Vb 1
\&             $seq   : a Bio::LocatabaleSeq object
.Ve
.SH "Bio::Assembly::Contig consensus methods"
.IX Header "Bio::Assembly::Contig consensus methods"
.Sh "set_consensus_sequence"
.IX Subsection "set_consensus_sequence"
.Vb 5
\& Title     : set_consensus_sequence
\& Usage     : $contig->set_consensus_sequence($seq)
\& Function  : Set the consensus sequence object for this contig
\& Returns   : consensus length
\& Argument  : Bio::LocatableSeq
.Ve
.Sh "set_consensus_quality"
.IX Subsection "set_consensus_quality"
.Vb 5
\& Title     : set_consensus_quality
\& Usage     : $contig->set_consensus_quality($qual)
\& Function  : Set the quality object for consensus sequence
\& Returns   : nothing
\& Argument  : Bio::Seq::QualI object
.Ve
.Sh "get_consensus_length"
.IX Subsection "get_consensus_length"
.Vb 5
\& Title     : get_consensus_length
\& Usage     : $contig->get_consensus_length()
\& Function  : Get consensus sequence length
\& Returns   : integer
\& Argument  : none
.Ve
.Sh "get_consensus_sequence"
.IX Subsection "get_consensus_sequence"
.Vb 6
\& Title     : get_consensus_sequence
\& Usage     : $contig->get_consensus_sequence()
\& Function  : Get a reference to the consensus sequence object
\&             for this contig
\& Returns   : Bio::SeqI object
\& Argument  : none
.Ve
.Sh "get_consensus_quality"
.IX Subsection "get_consensus_quality"
.Vb 6
\& Title     : get_consensus_quality
\& Usage     : $contig->get_consensus_quality()
\& Function  : Get a reference to the consensus quality object
\&             for this contig.
\& Returns   : A Bio::QualI object
\& Argument  : none
.Ve
.SH "Bio::Assembly::Contig aligned sequences methods"
.IX Header "Bio::Assembly::Contig aligned sequences methods"
.Sh "set_seq_qual"
.IX Subsection "set_seq_qual"
.Vb 6
\& Title     : set_seq_qual
\& Usage     : $contig->set_seq_qual($seq,$qual);
\& Function  : Adds quality to an aligned sequence.
\& Returns   : nothing
\& Argument  : a Bio::LocatableSeq object and
\&             a Bio::Seq::QualI object
.Ve
.PP
See Bio::LocatableSeq for more information.
.Sh "get_seq_ids"
.IX Subsection "get_seq_ids"
.Vb 17
\& Title     : get_seq_ids
\& Usage     : $contig->get_seq_ids(-start=>$start,
\&                                  -end=>$end,
\&                                  -type=>"gapped A0QR67B08.b");
\& Function  : Get list of sequence IDs overlapping inteval [$start, $end]
\&             The default interval is [1,$contig->length]
\&             Default coordinate system is "gapped contig"
\& Returns   : An array
\& Argument  : A hash with optional elements:
\&             -start : consensus subsequence start
\&             -end   : consensus subsequence end
\&             -type  : the coordinate system type for $start and $end arguments
\&                      Coordinate system avaliable are:
\&                      "gapped consensus"   : consensus coordinates with gaps
\&                      "ungapped consensus" : consensus coordinates without gaps
\&                      "aligned $ReadID"    : read $ReadID coordinates with gaps
\&                      "unaligned $ReadID"  : read $ReadID coordinates without gaps
.Ve
.Sh "get_seq_feat_by_tag"
.IX Subsection "get_seq_feat_by_tag"
.Vb 3
\& Title     : get_seq_feat_by_tag
\& Usage     : $seq = $contig->get_seq_feat_by_tag($seq,"_aligned_coord:$seqID")
\& Function  :
.Ve
.PP
.Vb 2
\&             Get a sequence feature based on its primary_tag.
\&             When you add
.Ve
.PP
.Vb 2
\& Returns   : a Bio::SeqFeature object
\& Argument  : a Bio::LocatableSeq and a string (feature primary tag)
.Ve
.Sh "get_seq_by_name"
.IX Subsection "get_seq_by_name"
.Vb 6
\& Title     : get_seq_by_name
\& Usage     : $seq = $contig->get_seq_by_name('Seq1')
\& Function  : Gets a sequence based on its id.
\& Returns   : a Bio::LocatableSeq object
\&             undef if name is not found
\& Argument  : string
.Ve
.Sh "get_qual_by_name"
.IX Subsection "get_qual_by_name"
.Vb 3
\& Title     : get_qual_by_name
\& Usage     : $seq = $contig->get_qual_by_name('Seq1')
\& Function  :
.Ve
.PP
.Vb 2
\&             Gets Bio::Seq::QualI object for a sequence
\&             through its id ( as given by $qual->id() ).
.Ve
.PP
.Vb 3
\& Returns   : a Bio::Seq::QualI object.
\&             undef if name is not found
\& Argument  : string
.Ve
.SH "Bio::Align::AlignI compatible methods"
.IX Header "Bio::Align::AlignI compatible methods"
.Sh "Modifier methods"
.IX Subsection "Modifier methods"
These methods modify the \s-1MSE\s0 by adding, removing or shuffling complete
sequences.
.Sh "add_seq"
.IX Subsection "add_seq"
.Vb 3
\& Title     : add_seq
\& Usage     : $contig->add_seq($newseq);
\& Function  :
.Ve
.PP
.Vb 3
\&             Adds a sequence to the contig. *Does*
\&             *not* align it - just adds it to the
\&             hashes.
.Ve
.PP
.Vb 2
\& Returns   : nothing
\& Argument  : a Bio::LocatableSeq object
.Ve
.PP
See Bio::LocatableSeq for more information.
.Sh "remove_seq"
.IX Subsection "remove_seq"
.Vb 5
\& Title     : remove_seq
\& Usage     : $contig->remove_seq($seq);
\& Function  : Removes a single sequence from an alignment
\& Returns   : 1 on success, 0 otherwise
\& Argument  : a Bio::LocatableSeq object
.Ve
.Sh "purge"
.IX Subsection "purge"
.Vb 3
\& Title   : purge
\& Usage   : $contig->purge(0.7);
\& Function:
.Ve
.PP
.Vb 1
\&           Removes sequences above whatever %id.
.Ve
.PP
.Vb 2
\&           This function will grind on large alignments. Beware!
\&           (perhaps not ideally implemented)
.Ve
.PP
.Vb 3
\& Example :
\& Returns : An array of the removed sequences
\& Argument:
.Ve
.Sh "sort_alphabetically"
.IX Subsection "sort_alphabetically"
.Vb 3
\& Title     : sort_alphabetically
\& Usage     : $contig->sort_alphabetically
\& Function  :
.Ve
.PP
.Vb 2
\&             Changes the order of the alignemnt to alphabetical on name
\&             followed by numerical by number.
.Ve
.PP
.Vb 2
\& Returns   :
\& Argument  :
.Ve
.Sh "Sequence selection methods"
.IX Subsection "Sequence selection methods"
Methods returning one or more sequences objects.
.Sh "each_seq"
.IX Subsection "each_seq"
.Vb 5
\& Title     : each_seq
\& Usage     : foreach $seq ( $contig->each_seq() )
\& Function  : Gets an array of Seq objects from the alignment
\& Returns   : an array
\& Argument  :
.Ve
.Sh "each_alphabetically"
.IX Subsection "each_alphabetically"
.Vb 3
\& Title     : each_alphabetically
\& Usage     : foreach $seq ( $contig->each_alphabetically() )
\& Function  :
.Ve
.PP
.Vb 3
\&             Returns an array of sequence object sorted alphabetically
\&             by name and then by start point.
\&             Does not change the order of the alignment
.Ve
.PP
.Vb 2
\& Returns   :
\& Argument  :
.Ve
.Sh "each_seq_with_id"
.IX Subsection "each_seq_with_id"
.Vb 3
\& Title     : each_seq_with_id
\& Usage     : foreach $seq ( $contig->each_seq_with_id() )
\& Function  :
.Ve
.PP
.Vb 3
\&             Gets an array of Seq objects from the
\&             alignment, the contents being those sequences
\&             with the given name (there may be more than one)
.Ve
.PP
.Vb 2
\& Returns   : an array
\& Argument  : a seq name
.Ve
.Sh "get_seq_by_pos"
.IX Subsection "get_seq_by_pos"
.Vb 3
\& Title     : get_seq_by_pos
\& Usage     : $seq = $contig->get_seq_by_pos(3)
\& Function  :
.Ve
.PP
.Vb 3
\&             Gets a sequence based on its position in the alignment.
\&             Numbering starts from 1.  Sequence positions larger than
\&             no_sequences() will thow an error.
.Ve
.PP
.Vb 2
\& Returns   : a Bio::LocatableSeq object
\& Argument  : positive integer for the sequence osition
.Ve
.Sh "Create new alignments"
.IX Subsection "Create new alignments"
The result of these methods are horizontal or vertical subsets of the
current \s-1MSE\s0.
.Sh "select"
.IX Subsection "select"
.Vb 3
\& Title     : select
\& Usage     : $contig2 = $contig->select(1, 3) # three first sequences
\& Function  :
.Ve
.PP
.Vb 3
\&             Creates a new alignment from a continuous subset of
\&             sequences.  Numbering starts from 1.  Sequence positions
\&             larger than no_sequences() will thow an error.
.Ve
.PP
.Vb 3
\& Returns   : a Bio::Assembly::Contig object
\& Argument  : positive integer for the first sequence
\&             positive integer for the last sequence to include (optional)
.Ve
.Sh "select_noncont"
.IX Subsection "select_noncont"
.Vb 3
\& Title     : select_noncont
\& Usage     : $contig2 = $contig->select_noncont(1, 3) # first and 3rd sequences
\& Function  :
.Ve
.PP
.Vb 3
\&             Creates a new alignment from a subset of
\&             sequences.  Numbering starts from 1.  Sequence positions
\&             larger than no_sequences() will thow an error.
.Ve
.PP
.Vb 2
\& Returns   : a Bio::Assembly::Contig object
\& Args      : array of integers for the sequences
.Ve
.Sh "slice"
.IX Subsection "slice"
.Vb 3
\& Title     : slice
\& Usage     : $contig2 = $contig->slice(20, 30)
\& Function  :
.Ve
.PP
.Vb 5
\&             Creates a slice from the alignment inclusive of start and
\&             end columns.  Sequences with no residues in the slice are
\&             excluded from the new alignment and a warning is printed.
\&             Slice beyond the length of the sequence does not do
\&             padding.
.Ve
.PP
.Vb 3
\& Returns   : a Bio::Assembly::Contig object
\& Argument  : positive integer for start column
\&             positive integer for end column
.Ve
.Sh "Change sequences within the \s-1MSE\s0"
.IX Subsection "Change sequences within the MSE"
These methods affect characters in all sequences without changeing the
alignment.
.Sh "map_chars"
.IX Subsection "map_chars"
.Vb 3
\& Title     : map_chars
\& Usage     : $contig->map_chars('\e.','-')
\& Function  :
.Ve
.PP
.Vb 2
\&             Does a s/$arg1/$arg2/ on the sequences. Useful for gap
\&             characters
.Ve
.PP
.Vb 3
\&             Notice that the from (arg1) is interpretted as a regex,
\&             so be careful about quoting meta characters (eg
\&             $contig->map_chars('.','-') wont do what you want)
.Ve
.PP
.Vb 3
\& Returns   :
\& Argument  : 'from' rexexp
\&             'to' string
.Ve
.Sh "uppercase"
.IX Subsection "uppercase"
.Vb 5
\& Title     : uppercase()
\& Usage     : $contig->uppercase()
\& Function  : Sets all the sequences to uppercase
\& Returns   :
\& Argument  :
.Ve
.Sh "match_line"
.IX Subsection "match_line"
.Vb 7
\& Title    : match_line()
\& Usage    : $contig->match_line()
\& Function : Generates a match line - much like consensus string
\&            except that a line indicating the '*' for a match.
\& Argument : (optional) Match line characters ('*' by default)
\&            (optional) Strong match char (':' by default)
\&            (optional) Weak match char ('.' by default)
.Ve
.Sh "match"
.IX Subsection "match"
.Vb 3
\& Title     : match()
\& Usage     : $contig->match()
\& Function  :
.Ve
.PP
.Vb 3
\&             Goes through all columns and changes residues that are
\&             identical to residue in first sequence to match '.'
\&             character. Sets match_char.
.Ve
.PP
.Vb 4
\&             USE WITH CARE: Most MSE formats do not support match
\&             characters in sequences, so this is mostly for output
\&             only. NEXUS format (Bio::AlignIO::nexus) can handle
\&             it.
.Ve
.PP
.Vb 2
\& Returns   : 1
\& Argument  : a match character, optional, defaults to '.'
.Ve
.Sh "unmatch"
.IX Subsection "unmatch"
.Vb 3
\& Title     : unmatch()
\& Usage     : $contig->unmatch()
\& Function  :
.Ve
.PP
.Vb 1
\&             Undoes the effect of method match. Unsets match_char.
.Ve
.PP
.Vb 2
\& Returns   : 1
\& Argument  : a match character, optional, defaults to '.'
.Ve
.Sh "\s-1MSE\s0 attibutes"
.IX Subsection "MSE attibutes"
Methods for setting and reading the \s-1MSE\s0 attributes.
.PP
Note that the methods defining character semantics depend on the user
to set them sensibly.  They are needed only by certain input/output
methods. Unset them by setting to an empty string ('').
.Sh "id"
.IX Subsection "id"
.Vb 5
\& Title     : id
\& Usage     : $contig->id("Ig")
\& Function  : Gets/sets the id field of the alignment
\& Returns   : An id string
\& Argument  : An id string (optional)
.Ve
.Sh "missing_char"
.IX Subsection "missing_char"
.Vb 7
\& Title     : missing_char
\& Usage     : $contig->missing_char("?")
\& Function  : Gets/sets the missing_char attribute of the alignment
\&             It is generally recommended to set it to 'n' or 'N'
\&             for nucleotides and to 'X' for protein.
\& Returns   : An missing_char string,
\& Argument  : An missing_char string (optional)
.Ve
.Sh "match_char"
.IX Subsection "match_char"
.Vb 5
\& Title     : match_char
\& Usage     : $contig->match_char('.')
\& Function  : Gets/sets the match_char attribute of the alignment
\& Returns   : An match_char string,
\& Argument  : An match_char string (optional)
.Ve
.Sh "gap_char"
.IX Subsection "gap_char"
.Vb 5
\& Title     : gap_char
\& Usage     : $contig->gap_char('-')
\& Function  : Gets/sets the gap_char attribute of the alignment
\& Returns   : An gap_char string, defaults to '-'
\& Argument  : An gap_char string (optional)
.Ve
.Sh "symbol_chars"
.IX Subsection "symbol_chars"
.Vb 5
\& Title   : symbol_chars
\& Usage   : my @symbolchars = $contig->symbol_chars;
\& Function: Returns all the seen symbols (other than gaps)
\& Returns : array of characters that are the seen symbols
\& Argument: boolean to include the gap/missing/match characters
.Ve
.Sh "Alignment descriptors"
.IX Subsection "Alignment descriptors"
These read only methods describe the \s-1MSE\s0 in various ways.
.Sh "consensus_string"
.IX Subsection "consensus_string"
.Vb 9
\& Title     : consensus_string
\& Usage     : $str = $contig->consensus_string($threshold_percent)
\& Function  : Makes a strict consensus
\& Returns   :
\& Argument  : Optional treshold ranging from 0 to 100.
\&             The consensus residue has to appear at least threshold %
\&             of the sequences at a given location, otherwise a '?'
\&             character will be placed at that location.
\&             (Default value = 0%)
.Ve
.Sh "consensus_iupac"
.IX Subsection "consensus_iupac"
.Vb 3
\& Title     : consensus_iupac
\& Usage     : $str = $contig->consensus_iupac()
\& Function  :
.Ve
.PP
.Vb 3
\&             Makes a consensus using IUPAC ambiguity codes from DNA
\&             and RNA. The output is in upper case except when gaps in
\&             a column force output to be in lower case.
.Ve
.PP
.Vb 4
\&             Note that if your alignment sequences contain a lot of
\&             IUPAC ambiquity codes you often have to manually set
\&             alphabet.  Bio::PrimarySeq::_guess_type thinks they
\&             indicate a protein sequence.
.Ve
.PP
.Vb 3
\& Returns   : consensus string
\& Argument  : none
\& Throws    : on protein sequences
.Ve
.Sh "is_flush"
.IX Subsection "is_flush"
.Vb 10
\& Title     : is_flush
\& Usage     : if( $contig->is_flush() )
\&           :
\&           :
\& Function  : Tells you whether the alignment
\&           : is flush, ie all of the same length
\&           :
\&           :
\& Returns   : 1 or 0
\& Argument  :
.Ve
.Sh "length"
.IX Subsection "length"
.Vb 6
\& Title     : length()
\& Usage     : $len = $contig->length()
\& Function  : Returns the maximum length of the alignment.
\&             To be sure the alignment is a block, use is_flush
\& Returns   :
\& Argument  :
.Ve
.Sh "maxdisplayname_length"
.IX Subsection "maxdisplayname_length"
.Vb 3
\& Title     : maxdisplayname_length
\& Usage     : $contig->maxdisplayname_length()
\& Function  :
.Ve
.PP
.Vb 2
\&             Gets the maximum length of the displayname in the
\&             alignment. Used in writing out various MSE formats.
.Ve
.PP
.Vb 2
\& Returns   : integer
\& Argument  :
.Ve
.Sh "no_residues"
.IX Subsection "no_residues"
.Vb 5
\& Title     : no_residues
\& Usage     : $no = $contig->no_residues
\& Function  : number of residues in total in the alignment
\& Returns   : integer
\& Argument  :
.Ve
.Sh "no_sequences"
.IX Subsection "no_sequences"
.Vb 5
\& Title     : no_sequences
\& Usage     : $depth = $contig->no_sequences
\& Function  : number of sequence in the sequence alignment
\& Returns   : integer
\& Argument  : None
.Ve
.Sh "percentage_identity"
.IX Subsection "percentage_identity"
.Vb 6
\& Title   : percentage_identity
\& Usage   : $id = $contig->percentage_identity
\& Function: The function calculates the percentage identity of the alignment
\& Returns : The percentage identity of the alignment (as defined by the
\&                                                     implementation)
\& Argument: None
.Ve
.Sh "overall_percentage_identity"
.IX Subsection "overall_percentage_identity"
.Vb 6
\& Title   : percentage_identity
\& Usage   : $id = $contig->percentage_identity
\& Function: The function calculates the percentage identity of
\&           the conserved columns
\& Returns : The percentage identity of the conserved columns
\& Args    : None
.Ve
.Sh "average_percentage_identity"
.IX Subsection "average_percentage_identity"
.Vb 6
\& Title   : average_percentage_identity
\& Usage   : $id = $contig->average_percentage_identity
\& Function: The function uses a fast method to calculate the average
\&           percentage identity of the alignment
\& Returns : The average percentage identity of the alignment
\& Args    : None
.Ve
.Sh "Alignment positions"
.IX Subsection "Alignment positions"
Methods to map a sequence position into an alignment column and back.
\&\fIcolumn_from_residue_number()\fR does the former. The latter is really a
property of the sequence object and can done using
Bio::LocatableSeq::location_from_column:
.PP
.Vb 4
\&    # select somehow a sequence from the alignment, e.g.
\&    my $seq = $contig->get_seq_by_pos(1);
\&    #$loc is undef or Bio::LocationI object
\&    my $loc = $seq->location_from_column(5);
.Ve
.Sh "column_from_residue_number"
.IX Subsection "column_from_residue_number"
.Vb 3
\& Title   : column_from_residue_number
\& Usage   : $col = $contig->column_from_residue_number( $seqname, $resnumber)
\& Function:
.Ve
.PP
.Vb 4
\&           This function gives the position in the alignment
\&           (i.e. column number) of the given residue number in the
\&           sequence with the given name. For example, for the
\&           alignment
.Ve
.PP
.Vb 3
\&             Seq1/91-97 AC..DEF.GH
\&             Seq2/24-30 ACGG.RTY..
\&             Seq3/43-51 AC.DDEFGHI
.Ve
.PP
.Vb 3
\&           column_from_residue_number( "Seq1", 94 ) returns 5.
\&           column_from_residue_number( "Seq2", 25 ) returns 2.
\&           column_from_residue_number( "Seq3", 50 ) returns 9.
.Ve
.PP
.Vb 3
\&           An exception is thrown if the residue number would lie
\&           outside the length of the aligment
\&           (e.g. column_from_residue_number( "Seq2", 22 )
.Ve
.PP
.Vb 3
\&          Note: If the the parent sequence is represented by more than
\&          one alignment sequence and the residue number is present in
\&          them, this method finds only the first one.
.Ve
.PP
.Vb 5
\& Returns : A column number for the position in the alignment of the
\&           given residue in the given sequence (1 = first column)
\& Args    : A sequence id/name (not a name/start-end)
\&           A residue number in the whole sequence (not just that
\&           segment of it in the alignment)
.Ve
.Sh "Sequence names"
.IX Subsection "Sequence names"
Methods to manipulate the display name. The default name based on the
sequence id and subsequence positions can be overridden in various
ways.
.Sh "displayname"
.IX Subsection "displayname"
.Vb 7
\& Title     : displayname
\& Usage     : $contig->displayname("Ig", "IgA")
\& Function  : Gets/sets the display name of a sequence in the alignment
\&           :
\& Returns   : A display name string
\& Argument  : name of the sequence
\&             displayname of the sequence (optional)
.Ve
.Sh "set_displayname_count"
.IX Subsection "set_displayname_count"
.Vb 3
\& Title     : set_displayname_count
\& Usage     : $contig->set_displayname_count
\& Function  :
.Ve
.PP
.Vb 2
\&             Sets the names to be name_# where # is the number of
\&             times this name has been used.
.Ve
.PP
.Vb 2
\& Returns   : None
\& Argument  : None
.Ve
.Sh "set_displayname_flat"
.IX Subsection "set_displayname_flat"
.Vb 6
\& Title     : set_displayname_flat
\& Usage     : $contig->set_displayname_flat()
\& Function  : Makes all the sequences be displayed as just their name,
\&             not name/start-end
\& Returns   : 1
\& Argument  : None
.Ve
.Sh "set_displayname_normal"
.IX Subsection "set_displayname_normal"
.Vb 5
\& Title     : set_displayname_normal
\& Usage     : $contig->set_displayname_normal()
\& Function  : Makes all the sequences be displayed as name/start-end
\& Returns   : None
\& Argument  : None
.Ve
.SH "Internal Methods"
.IX Header "Internal Methods"
.Sh "_binary_search"
.IX Subsection "_binary_search"
.Vb 3
\& Title     : _binary_search
\& Usage     : _binary_search($list,$query)
\& Function  :
.Ve
.PP
.Vb 7
\&             Find a number in a sorted list of numbers.  Return values
\&             may be on or two integers. One positive integer or zero
\&             (>=0) is the index of the element that stores the queried
\&             value.  Two positive integers (or zero and another
\&             number) are the indexes of elements among which the
\&             queried value should be placed. Negative single values
\&             mean:
.Ve
.PP
.Vb 2
\&             -1: $query is smaller than smallest element in list
\&             -2: $query is greater than greatest element in list
.Ve
.PP
.Vb 4
\& Returns   : array of integers
\& Argument  :
\&             $list  : array reference
\&             $query : integer
.Ve
.Sh "_compare"
.IX Subsection "_compare"
.Vb 5
\&    Title   : _compare
\&    Usage   : _compare($arg1,$arg2)
\&    Function: Perform numeric or string comparisons
\&    Returns : integer (0, 1 or -1)
\&    Args    : values to be compared
.Ve
.Sh "_nof_gaps"
.IX Subsection "_nof_gaps"
.Vb 7
\&    Title   : _nof_gaps
\&    Usage   : _nof_gaps($array_ref, $query)
\&    Function: number of gaps found before position $query
\&    Returns : integer
\&    Args    :
\&              $array_ref : gap registry reference
\&              $query     : [integer] a position in a sequence
.Ve
.Sh "_padded_unpadded"
.IX Subsection "_padded_unpadded"
.Vb 3
\&    Title   : _padded_unpadded
\&    Usage   : _padded_unpadded($array_ref, $query)
\&    Function:
.Ve
.PP
.Vb 3
\&              Returns a coordinate corresponding to
\&              position $query after gaps were
\&              removed from a sequence.
.Ve
.PP
.Vb 4
\&    Returns : integer
\&    Args    :
\&              $array_ref : reference to this gap registry
\&              $query     : [integer] coordionate to change
.Ve
.Sh "_unpadded_padded"
.IX Subsection "_unpadded_padded"
.Vb 3
\&    Title   : _unpadded_padded
\&    Usage   : _unpadded_padded($array_ref, $query)
\&    Function:
.Ve
.PP
.Vb 3
\&              Returns the value corresponding to
\&              ungapped position $query when gaps are
\&              counted as valid sites in a sequence
.Ve
.PP
.Vb 3
\&    Returns :
\&    Args    : $array_ref = a reference to this sequence's gap registry
\&              $query = [integer] location to change
.Ve
.Sh "_register_gaps"
.IX Subsection "_register_gaps"
.Vb 9
\&    Title   : _register_gaps
\&    Usage   : $self->_register_gaps($seq, $array_ref)
\&    Function: stores gap locations for a sequence
\&    Returns : number of gaps found
\&    Args    :
\&              $seq       : sequence string
\&              $array_ref : a reference to an array,
\&                           where gap locations will
\&                           be stored
.Ve
