.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Map::MappableI 3"
.TH Bio::Map::MappableI 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Map::MappableI \- An object that can be placed in a map
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    # do not use this module directly
\&    # See Bio::Map::Mappable for an example of
\&    # implementation.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object handles the generic notion of an element placed on a
(linear) Map. A Mappable can have multiple positions in multiple maps, such as
is the case of Restriction enzyme cut sites on sequence maps. For exact
information about a mappable's position in a map one must query the associate
PositionI objects which are accessible through the \fIget_positions()\fR method.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Jason Stajich"
.IX Header "AUTHOR - Jason Stajich"
Email jason@bioperl.org
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Heikki Lehvaslaiho heikki-at-bioperl-dot-org
Lincoln Stein      lstein@cshl.org
Sendu Bala         bix@sendu.me.uk
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.Sh "EntityI methods"
.IX Subsection "EntityI methods"
.Vb 2
\& These are fundamental to coordination of Mappables and other entities, so are
\& implemented at the interface level
.Ve
.Sh "get_position_handler"
.IX Subsection "get_position_handler"
.Vb 5
\& Title   : get_position_handler
\& Usage   : my $position_handler = $entity->get_position_handler();
\& Function: Gets a PositionHandlerI that $entity is registered with.
\& Returns : Bio::Map::PositionHandlerI object
\& Args    : none
.Ve
.Sh "PositionHandlerI-related methods"
.IX Subsection "PositionHandlerI-related methods"
.Vb 2
\& These are fundamental to coordination of Mappables and other entities, so are
\& implemented at the interface level
.Ve
.Sh "add_position"
.IX Subsection "add_position"
.Vb 5
\& Title   : add_position
\& Usage   : $mappable->add_position($position);
\& Function: Add a position to this mappable (defining where on which map it is).
\& Returns : n/a
\& Args    : L<Bio::Map::PositionI> object
.Ve
.Sh "get_positions"
.IX Subsection "get_positions"
.Vb 7
\& Title   : get_positions
\& Usage   : my @positions = $mappable->get_positions();
\& Function: Get all the Positions of this Mappable (sorted).
\& Returns : Array of L<Bio::Map::PositionI> objects
\& Args    : none for all, OR
\&           L<Bio::Map::MapI> object for positions on the given map, AND/OR some
\&           other true value to avoid sorting
.Ve
.Sh "each_position"
.IX Subsection "each_position"
.Vb 3
\& Title   : each_position
\& Function: Synonym of the get_positions() method.
\& Status  : deprecated, will be removed in next version
.Ve
.Sh "purge_positions"
.IX Subsection "purge_positions"
.Vb 8
\& Title   : purge_positions
\& Usage   : $mappable->purge_positions();
\& Function: Remove positions from this mappable.
\& Returns : n/a
\& Args    : none to remove all positions, OR
\&           L<Bio::Map::PositionI> object to remove just that Position, OR
\&                   L<Bio::Map::MapI> object to remove only those positions on the given
\&                   map
.Ve
.Sh "known_maps"
.IX Subsection "known_maps"
.Vb 5
\& Title   : known_maps
\& Usage   : my @maps = $marker->known_maps()
\& Function: Returns the maps that this mappable is found on
\& Returns : Array of L<Bio::Map::MapI> objects
\& Args    : none
.Ve
.Sh "MappableI-specific methods"
.IX Subsection "MappableI-specific methods"
.Sh "name"
.IX Subsection "name"
.Vb 7
\& Title   : name
\& Usage   : my $name = $marker->name();
\&           $marker->name($new_name);
\& Function: Get/Set the name for this Mappable.
\& Returns : A scalar representing the current name of this Mappable
\& Args    : none to get
\&           string to set
.Ve
.Sh "id"
.IX Subsection "id"
.Vb 7
\& Title   : id
\& Usage   : my $id = $marker->id();
\&           $marker->id($new_id);
\& Function: Get/Set the id for this Mappable.
\& Returns : A scalar representing the current id of this Mappable
\& Args    : none to get
\&           string to set
.Ve
.Sh "in_map"
.IX Subsection "in_map"
.Vb 5
\& Title   : in_map
\& Usage   : if ($marker->in_map($map)) {...}
\& Function: Tests if this mappable is found on a specific map
\& Returns : boolean
\& Args    : L<Bio::Map::MapI>
.Ve
.SH "RangeI-related Methods"
.IX Header "RangeI-related Methods"
They throw an error if start and end are not defined in the Positions of the
Mappables supplied.
.Sh "equals"
.IX Subsection "equals"
.Vb 15
\& Title   : equals
\& Usage   : if ($mappable->equals($other_mappable)) {...}
\&           my @equal_positions = $mappable->equals($other_mappable);
\& Function: Finds the positions in this mappable that are equal to any
\&           comparison positions.
\& Returns : array of L<Bio::Map::PositionI> objects
\& Args    : arg #1 = L<Bio::Map::MappableI> OR L<Bio::Map::PositionI> to compare
\&                    this one to (mandatory)
\&           arg #2 = optionally, the key => value pairs below
\&                   -map => Bio::Map::MapI           : optionally a Map to only consider
\&                                                      positions on the given map
\&                   -relative => Bio::Map::RelativeI : optionally a Relative to ask if
\&                                                                                          the Positions equal in terms of
\&                                                                                          their relative position to the
\&                                                                                          thing described by that Relative
.Ve
.Sh "overlaps"
.IX Subsection "overlaps"
.Vb 15
\& Title   : overlaps
\& Usage   : if ($mappable->overlaps($other_mappable)) {...}
\&           my @overlapping_positions = $mappable->overlaps($other_mappable);
\& Function: Finds the positions in this mappable that overlap with any
\&           comparison positions.
\& Returns : array of L<Bio::Map::PositionI> objects
\& Args    : arg #1 = L<Bio::Map::MappableI> OR L<Bio::Map::PositionI> to compare
\&                    this one to (mandatory)
\&           arg #2 = optionally, the key => value pairs below
\&                   -map => Bio::Map::MapI           : optionally a Map to only consider
\&                                                      positions on the given map
\&                   -relative => Bio::Map::RelativeI : optionally a Relative to ask if
\&                                              the Positions overlap in terms of
\&                                              their relative position to the
\&                                              thing described by that Relative
.Ve
.Sh "contains"
.IX Subsection "contains"
.Vb 15
\& Title   : contains
\& Usage   : if ($mappable->contains($other_mappable)) {...}
\&           my @container_positions = $mappable->contains($other_mappable);
\& Function: Finds the positions in this mappable that contain any comparison
\&           positions.
\& Returns : array of L<Bio::Map::PositionI> objects
\& Args    : arg #1 = L<Bio::Map::MappableI> OR L<Bio::Map::PositionI> to compare
\&                    this one to (mandatory)
\&           arg #2 = optionally, the key => value pairs below
\&                   -map => Bio::Map::MapI           : optionally a Map to only consider
\&                                                      positions on the given map
\&                   -relative => Bio::Map::RelativeI : optionally a Relative to ask if
\&                                              the Positions contains in terms of
\&                                              their relative position to the
\&                                              thing described by that Relative
.Ve
.Sh "intersection"
.IX Subsection "intersection"
.Vb 16
\& Title   : intersection
\& Usage   : my $position = $mappable->intersection($other_mappable);
\&           my $position = Bio::Map::Mappable->intersection(\e@mappables);
\& Function: Make the position that is at the intersection of all positions of all
\&           supplied mappables.
\& Returns : L<Bio::Map::PositionI> object or undef (if not all positions overlap)
\& Args    : arg #1 = L<Bio::Map::MappableI> OR L<Bio::Map::PositionI> to  compare
\&                    this one to, or an array ref of such objects (mandatory)
\&           arg #2 = optionally, the key => value pairs below
\&                   -map => Bio::Map::MapI           : optionally a Map to only consider
\&                                                      positions on the given map
\&                   -relative => Bio::Map::RelativeI : optionally a Relative to to ask
\&                                                                                          how the Positions intersect in
\&                                                                                          terms of their relative position
\&                                                                                          to the thing described by that
\&                                                                                          Relative
.Ve
.Sh "union"
.IX Subsection "union"
.Vb 16
\& Title   : union
\& Usage   : my $position = $mappable->union($other_mappable);
\&           my $position = Bio::Map::Mappable->union(@mappables);
\& Function: Make the minimal position that contains all of the positions of all
\&           supplied mappables.
\& Returns : L<Bio::Map::PositionI> object or undef (if not all positions overlap)
\& Args    : arg #1 = L<Bio::Map::MappableI> OR L<Bio::Map::PositionI> to  compare
\&                    this one to, or an array ref of such objects (mandatory)
\&           arg #2 = optionally, the key => value pairs below
\&                   -map => Bio::Map::MapI           : optionally a Map to only consider
\&                                                      positions on the given map
\&                   -relative => Bio::Map::RelativeI : optionally a Relative to to ask
\&                                                                                          if the union of the Positions in
\&                                                                                          terms of their relative position
\&                                                                                          to the thing described by that
\&                                                                                          Relative
.Ve
