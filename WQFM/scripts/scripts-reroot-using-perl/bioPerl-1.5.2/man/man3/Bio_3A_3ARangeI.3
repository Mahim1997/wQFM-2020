.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::RangeI 3"
.TH Bio::RangeI 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::RangeI \- Range interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #Do not run this module directly
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This provides a standard BioPerl range interface that should be
implemented by any object that wants to be treated as a range. This
serves purely as an abstract base class for implementers and can not
be instantiated.
.PP
Ranges are modeled as having (start, end, length, strand). They use
Bio-coordinates \- all points >= start and <= end are within the
range. End is always greater-than or equal-to start, and length is
greater than or equal to 1. The behaviour of a range is undefined if
ranges with negative numbers or zero are used.
.PP
So, in summary:
.PP
.Vb 3
\&  length = end - start + 1
\&  end >= start
\&  strand = (-1 | 0 | +1)
.Ve
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.bioperl.org/
.Ve
.SH "AUTHOR \- Heikki Lehvaslaiho"
.IX Header "AUTHOR - Heikki Lehvaslaiho"
Email:  heikki-at-bioperl-dot-org
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Juha Muilu (muilu@ebi.ac.uk)
Sendu Bala (bix@sendu.me.uk)
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SH "Abstract methods"
.IX Header "Abstract methods"
These methods must be implemented in all subclasses.
.Sh "start"
.IX Subsection "start"
.Vb 6
\&  Title   : start
\&  Usage   : $start = $range->start();
\&  Function: get/set the start of this range
\&  Returns : the start of this range
\&  Args    : optionally allows the start to be set
\&            using $range->start($start)
.Ve
.Sh "end"
.IX Subsection "end"
.Vb 6
\&  Title   : end
\&  Usage   : $end = $range->end();
\&  Function: get/set the end of this range
\&  Returns : the end of this range
\&  Args    : optionally allows the end to be set
\&            using $range->end($end)
.Ve
.Sh "length"
.IX Subsection "length"
.Vb 6
\&  Title   : length
\&  Usage   : $length = $range->length();
\&  Function: get/set the length of this range
\&  Returns : the length of this range
\&  Args    : optionally allows the length to be set
\&             using $range->length($length)
.Ve
.Sh "strand"
.IX Subsection "strand"
.Vb 6
\&  Title   : strand
\&  Usage   : $strand = $range->strand();
\&  Function: get/set the strand of this range
\&  Returns : the strandedness (-1, 0, +1)
\&  Args    : optionally allows the strand to be set
\&            using $range->strand($strand)
.Ve
.SH "Boolean Methods"
.IX Header "Boolean Methods"
These methods return true or false. They throw an error if start and
end are not defined.
.PP
.Vb 1
\&  $range->overlaps($otherRange) && print "Ranges overlap\en";
.Ve
.Sh "overlaps"
.IX Subsection "overlaps"
.Vb 6
\&  Title   : overlaps
\&  Usage   : if($r1->overlaps($r2)) { do stuff }
\&  Function: tests if $r2 overlaps $r1
\&  Args    : arg #1 = a range to compare this one to (mandatory)
\&            arg #2 = optional strand-testing arg ('strong', 'weak', 'ignore')
\&  Returns : true if the ranges overlap, false otherwise
.Ve
.Sh "contains"
.IX Subsection "contains"
.Vb 7
\&  Title   : contains
\&  Usage   : if($r1->contains($r2) { do stuff }
\&  Function: tests whether $r1 totally contains $r2
\&  Args    : arg #1 = a range to compare this one to (mandatory)
\&                     alternatively, integer scalar to test
\&            arg #2 = optional strand-testing arg ('strong', 'weak', 'ignore')
\&  Returns : true if the argument is totally contained within this range
.Ve
.Sh "equals"
.IX Subsection "equals"
.Vb 6
\&  Title   : equals
\&  Usage   : if($r1->equals($r2))
\&  Function: test whether $r1 has the same start, end, length as $r2
\&  Args    : arg #1 = a range to compare this one to (mandatory)
\&            arg #2 = optional strand-testing arg ('strong', 'weak', 'ignore')
\&  Returns : true if they are describing the same range
.Ve
.SH "Geometrical methods"
.IX Header "Geometrical methods"
These methods do things to the geometry of ranges, and return
Bio::RangeI compliant objects or triplets (start, stop, strand) from
which new ranges could be built.
.Sh "intersection"
.IX Subsection "intersection"
.Vb 12
\& Title   : intersection
\& Usage   : ($start, $stop, $strand) = $r1->intersection($r2); OR
\&           ($start, $stop, $strand) = Bio::Range->intersection(\e@ranges); OR
\&           my $containing_range = $r1->intersection($r2); OR
\&           my $containing_range = Bio::Range->intersection(\e@ranges);
\& Function: gives the range that is contained by all ranges
\& Returns : undef if they do not overlap, or
\&           the range that they do overlap (in the form of an object
\&            like the calling one, OR a three element array)
\& Args    : arg #1 = [REQUIRED] a range to compare this one to,
\&                    or an array ref of ranges
\&           arg #2 = optional strand-testing arg ('strong', 'weak', 'ignore')
.Ve
.Sh "union"
.IX Subsection "union"
.Vb 9
\&   Title   : union
\&    Usage   : ($start, $stop, $strand) = $r1->union($r2);
\&            : ($start, $stop, $strand) = Bio::Range->union(@ranges);
\&              my $newrange = Bio::Range->union(@ranges);
\&    Function: finds the minimal Range that contains all of the Ranges
\&    Args    : a Range or list of Range objects
\&    Returns : the range containing all of the range
\&              (in the form of an object like the calling one, OR
\&              a three element array)
.Ve
.Sh "overlap_extent"
.IX Subsection "overlap_extent"
.Vb 9
\& Title   : overlap_extent
\& Usage   : ($a_unique,$common,$b_unique) = $a->overlap_extent($b)
\& Function: Provides actual amount of overlap between two different
\&           ranges
\& Example :
\& Returns : array of values containing the length unique to the calling
\&           range, the length common to both, and the length unique to
\&           the argument range
\& Args    : a range
.Ve
.Sh "disconnected_ranges"
.IX Subsection "disconnected_ranges"
.Vb 8
\&    Title   : disconnected_ranges
\&    Usage   : my @disc_ranges = Bio::Range->disconnected_ranges(@ranges);
\&    Function: finds the minimal set of ranges such that each input range
\&              is fully contained by at least one output range, and none of
\&              the output ranges overlap
\&    Args    : a list of ranges
\&    Returns : a list of objects of the same type as the input
\&              (conforms to RangeI)
.Ve
