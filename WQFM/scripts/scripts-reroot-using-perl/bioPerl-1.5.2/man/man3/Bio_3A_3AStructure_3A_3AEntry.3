.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Structure::Entry 3"
.TH Bio::Structure::Entry 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Structure::Entry \- Bioperl structure Object, describes the whole entry
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #add synopsis here
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object stores a whole Bio::Structure entry. It can consist of one
or more models (Bio::Structure::Model), which in turn consist of one 
or more chains (Bio::Structure::Chain). A chain is composed of residues 
(Bio::Structure::Residue) and a residue consists of atoms 
(Bio::Structure::Atom). If no specific model or chain is chosen, the 
first one is chosen.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Kris Boulez"
.IX Header "AUTHOR - Kris Boulez"
Email kris.boulez@algonomics.com
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods. Internal 
methods are usually preceded with a _
.Sh "\fInew()\fP"
.IX Subsection "new()"
.Vb 4
\& Title   : new()
\& Usage   : $struc = Bio::Structure::Entry->new( 
\&                                           -id  => 'structure_id',
\&                                           );
.Ve
.PP
.Vb 3
\& Function: Returns a new Bio::Structure::Entry object from basic 
\&                constructors. Probably most called from Bio::Structure::IO.
\& Returns : a new Bio::Structure::Model object
.Ve
.Sh "\fImodel()\fP"
.IX Subsection "model()"
.Vb 6
\& Title   : model
\& Function: Connects a (or a list of) Model objects to a Bio::Structure::Entry.
\&                To add a Model (and keep the existing ones) use add_model()
\&                It returns a list of Model objects.
\& Returns : List of Bio::Structure::Model objects
\& Args    : One Model or a reference to an array of Model objects
.Ve
.Sh "\fIadd_model()\fP"
.IX Subsection "add_model()"
.Vb 5
\& Title   : add_model
\& Usage   : $structure->add_model($model);
\& Function: Adds a (or a list of) Model objects to a Bio::Structure::Entry.
\& Returns : 
\& Args    : One Model or a reference to an array of Model objects
.Ve
.Sh "\fIget_models()\fP"
.IX Subsection "get_models()"
.Vb 5
\& Title   : get_models
\& Usage   : $structure->get_models($structure);
\& Function: general get method for models attached to an Entry
\& Returns : a list of models attached to this entry
\& Args    : an Entry
.Ve
.Sh "\fIid()\fP"
.IX Subsection "id()"
.Vb 5
\& Title   : id
\& Usage   : $entry->id("identity");
\& Function: Gets/sets the ID 
\& Returns : The ID
\& Args    :
.Ve
.Sh "\fIchain()\fP"
.IX Subsection "chain()"
.Vb 5
\& Title   : chain
\& Usage   : @chains  = $structure->chain($chain);
\& Function: Connects a Chain or a list of Chain objects to a Bio::Structure::Entry.
\& Returns : List of Bio::Structure::Chain objects
\& Args    : A Chain or a reference to an array of Chain objects
.Ve
.Sh "\fIadd_chain()\fP"
.IX Subsection "add_chain()"
.Vb 6
\& Title   : add_chain
\& Usage   : @chains  = $structure->add_chain($model,$chain);
\& Function: Adds one or more Chain objects to a Bio::Structure::Entry.
\& Returns : List of Chain objects associated with the Model
\& Args    : A Model object and a Chain object or a reference to an array of 
\&           of Chain objects
.Ve
.Sh "\fIget_chains()\fP"
.IX Subsection "get_chains()"
.Vb 5
\& Title   : get_chains
\& Usage   : $entry->get_chains($model);
\& Function: General get method for Chains attached to a Model
\& Returns : A list of Chains attached to this model
\& Args    : A Model
.Ve
.Sh "\fIresidue()\fP"
.IX Subsection "residue()"
.Vb 5
\& Title   : residue
\& Usage   : @residues  = $structure->residue($residue);
\& Function: Connects a (or a list of) Residue objects to a Bio::Structure::Entry.
\& Returns : List of Bio::Structure::Residue objects
\& Args    : One Residue or a reference to an array of Residue objects
.Ve
.Sh "\fIadd_residue()\fP"
.IX Subsection "add_residue()"
.Vb 6
\& Title   : add_residue
\& Usage   : @residues  = $structure->add_residue($chain,$residue);
\& Function: Adds one or more Residue objects to a Bio::Structure::Entry.
\& Returns : List of Bio::Structure::Residue objects
\& Args    : A Chain object and a Residue object or a reference to an array of 
\&           Residue objects
.Ve
.Sh "\fIget_residues()\fP"
.IX Subsection "get_residues()"
.Vb 5
\& Title   : get_residues
\& Usage   : $structure->get_residues($chain);
\& Function: General get method for Residues attached to a Chain
\& Returns : A list of residues attached to this Chain
\& Args    : A Chain
.Ve
.Sh "\fIadd_atom()\fP"
.IX Subsection "add_atom()"
.Vb 5
\& Title   : add_atom
\& Usage   : @atoms  = $structure->add_atom($residue,$atom);
\& Function: Adds a (or a list of) Atom objects to a Bio::Structure::Residue.
\& Returns : List of Bio::Structure::Atom objects
\& Args    : A Residue and an Atom
.Ve
.Sh "\fIget_atoms()\fP"
.IX Subsection "get_atoms()"
.Vb 5
\& Title   : get_atoms
\& Usage   : $structure->get_atoms($residue);
\& Function: General get method for Atoms attached to a Residue
\& Returns : A list of Atoms attached to this Residue
\& Args    : A Residue
.Ve
.Sh "\fIparent()\fP"
.IX Subsection "parent()"
.Vb 5
\& Title   : parent
\& Usage   : $structure->parent($residue);
\& Function: Returns the parent of the argument
\& Returns : The parent of the argument
\& Args    : A Bio::Structure object
.Ve
.Sh "connect"
.IX Subsection "connect"
.Vb 5
\& Title   : connect
\& Usage   : 
\& Function: Alias to conect()
\& Returns : 
\& Args    :
.Ve
.Sh "\fIconect()\fP"
.IX Subsection "conect()"
.Vb 7
\& Title   : conect
\& Usage   : $structure->conect($source);
\& Function: Get/set method for conect
\& Returns : A list of serial numbers for Atoms connected to source
\&                (together with $entry->get_atom_by_serial($model, $serial),
\&           this should be OK for now)
\& Args    : The source, the serial number for the source Atom, and the type
.Ve
.Sh "get_all_connect_source"
.IX Subsection "get_all_connect_source"
.Vb 5
\& Title   : get_all_connect_source
\& Usage   : 
\& Function: Alias to get_all_conect_source()
\& Returns : 
\& Args    :
.Ve
.Sh "\fIget_all_conect_source()\fP"
.IX Subsection "get_all_conect_source()"
.Vb 9
\& Title   : get_all_conect_source
\& Usage   : @sources = $structure->get_all_conect_source;
\& Function: Get all the sources for the conect records
\& Returns : A list of serial numbers for atoms connected to source
\&                (together with $entry->get_atom_by_serial($model, $serial), 
\&           this should be OK for now)
\& Args    : 
\& Notes   : This is a bit of a kludge, but it is the best for now. Conect info might need
\&                to go in a separate object
.Ve
.Sh "\fImaster()\fP"
.IX Subsection "master()"
.Vb 5
\& Title   : master
\& Usage   : $structure->master($source);
\& Function: Get/set method for master
\& Returns : The master line
\& Args    : The master line for this entry
.Ve
.Sh "\fIseqres()\fP"
.IX Subsection "seqres()"
.Vb 7
\& Title   : seqres
\& Usage   : $seqobj = $structure->seqres("A");
\& Function: Gets a sequence object containing the sequence from the SEQRES record.
\&                if a chain-ID is given, the sequence for this chain is given, if none
\&                is provided the first chain is choosen
\& Returns : A Bio::PrimarySeq
\& Args    : The chain-ID of the chain you want the sequence from
.Ve
.Sh "\fIget_atom_by_serial()\fP"
.IX Subsection "get_atom_by_serial()"
.Vb 6
\& Title   : get_atom_by_serial
\& Usage   : $structure->get_atom_by_serial($model,$serial);
\& Function: Get the Atom by serial
\& Returns : The Atom object with this serial number in the model
\& Args    : Model on which to work, serial number for atom
\&                (if only a number is supplied, the first model is chosen)
.Ve
.Sh "annotation"
.IX Subsection "annotation"
.Vb 6
\& Title   : annotation
\& Usage   : $obj->annotation($seq_obj)
\& Function:
\& Example :
\& Returns : value of annotation
\& Args    : newvalue (optional)
.Ve
.Sh "\fI_remove_models()\fP"
.IX Subsection "_remove_models()"
.Vb 6
\& Title   : _remove_models
\& Usage   : 
\& Function: Removes the models attached to an Entry. Tells the models they
\&                do not belong to this Entry any more
\& Returns : 
\& Args    :
.Ve
.Sh "\fI_create_default_model()\fP"
.IX Subsection "_create_default_model()"
.Vb 6
\& Title   : _create_default_model
\& Usage   : 
\& Function: Creates a default Model for this Entry. Typical situation
\&                in an X-ray structure where there is only one model
\& Returns : 
\& Args    :
.Ve
.Sh "\fI_create_default_chain()\fP"
.IX Subsection "_create_default_chain()"
.Vb 6
\& Title   : _create_default_chain
\& Usage   : 
\& Function: Creates a default Chain for this Model. Typical situation
\&                in an X-ray structure where there is only one chain
\& Returns : 
\& Args    :
.Ve
.Sh "\fI_parent()\fP"
.IX Subsection "_parent()"
.Vb 12
\& Title   : _parent
\& Usage   : This is an internal function only. It is used to have one 
\&                place that keeps track of which object has which other object 
\&                as parent. Thus allowing the underlying modules (Atom, Residue,...)
\&                to have no knowledge about all this (and thus removing the possibility
\&                of reference cycles).
\&                This method hides the details of manipulating references to an anonymous
\&                hash.
\& Function: To get/set an objects parent 
\& Returns : A reference to the parent if it exist, undef otherwise. In the 
\&                current implementation each node should have a parent (except Entry).
\& Args    :
.Ve
.Sh "\fI_child()\fP"
.IX Subsection "_child()"
.Vb 12
\& Title   : _child
\& Usage   : This is an internal function only. It is used to have one 
\&                place that keeps track of which object has which other object 
\&                as child. Thus allowing the underlying modules (Atom, Residue,...)
\&                to have no knowledge about all this (and thus removing the possibility
\&                to have no knowledge about all this (and thus removing the possibility
\&                of reference cycles).
\&                This method hides the details of manipulating references to an anonymous
\&                hash.
\& Function: To get/set an the children of an object 
\& Returns : A reference to an array of child(ren) if they exist, undef otherwise. 
\& Args    :
.Ve
.Sh "\fI_remove_from_graph()\fP"
.IX Subsection "_remove_from_graph()"
.Vb 7
\& Title   : _remove_from_graph
\& Usage   : This is an internal function only. It is used to remove from
\&                the parent/child graph. We only remove the links from object to
\&                his parent. Not the ones from object to its children.
\& Function: To remove an object from the parent/child graph
\& Returns : 
\& Args    : The object to be orphaned
.Ve
