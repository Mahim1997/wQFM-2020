.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Root::RootI 3"
.TH Bio::Root::RootI 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Root::RootI \- Abstract interface to root object code
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # any bioperl or bioperl compliant object is a RootI 
\&  # compliant object
.Ve
.PP
.Vb 1
\&  $obj->throw("This is an exception");
.Ve
.PP
.Vb 3
\&  eval {
\&      $obj->throw("This is catching an exception");
\&  };
.Ve
.PP
.Vb 5
\&  if( $@ ) {
\&      print "Caught exception";
\&  } else {
\&      print "no exception";
\&  }
.Ve
.PP
.Vb 1
\&  # Using throw_not_implemented() within a RootI-based interface module:
.Ve
.PP
.Vb 2
\&  package Foo;
\&  use base qw(Bio::Root::RootI);
.Ve
.PP
.Vb 4
\&  sub foo {
\&      my $self = shift;
\&      $self->throw_not_implemented;
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is just a set of methods which do not assume \fBanything\fR about the object
they are on. The methods provide the ability to throw exceptions with nice
stack traces.
.PP
This is what should be inherited by all Bioperl compliant interfaces, even
if they are exotic XS/CORBA/Other perl systems.
.Sh "Using \fIthrow_not_implemented()\fP"
.IX Subsection "Using throw_not_implemented()"
The method \fIthrow_not_implemented()\fR should be
called by all methods within interface modules that extend RootI so
that if an implementation fails to override them, an exception will be
thrown.
.PP
For example, say there is an interface module called \f(CW\*(C`FooI\*(C'\fR that
provides a method called \f(CW\*(C`foo()\*(C'\fR. Since this method is considered
abstract within FooI and should be implemented by any module claiming to
implement \f(CW\*(C`FooI\*(C'\fR, the \f(CW\*(C`FooI::foo()\*(C'\fR method should consist of the
following:
.PP
.Vb 4
\&    sub foo {
\&        my $self = shift;
\&        $self->throw_not_implemented;
\&    }
.Ve
.PP
So, if an implementer of \f(CW\*(C`FooI\*(C'\fR forgets to implement \f(CW\*(C`foo()\*(C'\fR
and a user of the implementation calls \f(CW\*(C`foo()\*(C'\fR, a
Bio::Exception::NotImplemented exception will result.
.PP
Unfortunately, failure to implement a method can only be determined at
run time (i.e., you can't verify that an implementation is complete by
running \f(CW\*(C`perl \-wc\*(C'\fR on it). So it should be standard practice for a test
of an implementation to check each method and verify that it doesn't
throw a Bio::Exception::NotImplemented.
.SH "CONTACT"
.IX Header "CONTACT"
Functions originally from Steve Chervitz. Refactored by Ewan
Birney. Re-refactored by Lincoln Stein.
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.Sh "throw"
.IX Subsection "throw"
.Vb 6
\& Title   : throw
\& Usage   : $obj->throw("throwing exception message")
\& Function: Throws an exception, which, if not caught with an eval brace
\&           will provide a nice stack trace to STDERR with the message
\& Returns : nothing
\& Args    : A string giving a descriptive error message
.Ve
.Sh "warn"
.IX Subsection "warn"
.Vb 11
\& Title   : warn
\& Usage   : $object->warn("Warning message");
\& Function: Places a warning. What happens now is down to the
\&           verbosity of the object  (value of $obj->verbose) 
\&            verbosity 0 or not set => small warning
\&            verbosity -1 => no warning
\&            verbosity 1 => warning with stack trace
\&            verbosity 2 => converts warnings into throw
\& Example :
\& Returns : 
\& Args    :
.Ve
.Sh "deprecated"
.IX Subsection "deprecated"
.Vb 6
\& Title   : deprecated
\& Usage   : $obj->deprecated("Method X is deprecated");
\& Function: Prints a message about deprecation 
\&           unless verbose is < 0 (which means be quiet)
\& Returns : none
\& Args    : Message string to print to STDERR
.Ve
.Sh "stack_trace_dump"
.IX Subsection "stack_trace_dump"
.Vb 6
\& Title   : stack_trace_dump
\& Usage   :
\& Function:
\& Example :
\& Returns : 
\& Args    :
.Ve
.Sh "stack_trace"
.IX Subsection "stack_trace"
.Vb 6
\& Title   : stack_trace
\& Usage   : @stack_array_ref= $self->stack_trace
\& Function: gives an array to a reference of arrays with stack trace info
\&           each coming from the caller(stack_number) call
\& Returns : array containing a reference of arrays
\& Args    : none
.Ve
.Sh "_rearrange"
.IX Subsection "_rearrange"
.Vb 65
\& Usage     : $object->_rearrange( array_ref, list_of_arguments)
\& Purpose   : Rearranges named parameters to requested order.
\& Example   : $self->_rearrange([qw(SEQUENCE ID DESC)],@param);
\&           : Where @param = (-sequence => $s,
\&               :                 -desc     => $d,
\&               :                 -id       => $i);
\& Returns   : @params - an array of parameters in the requested order.
\&           : The above example would return ($s, $i, $d).
\&           : Unspecified parameters will return undef. For example, if
\&           :        @param = (-sequence => $s);
\&           : the above _rearrange call would return ($s, undef, undef)
\& Argument  : $order : a reference to an array which describes the desired
\&           :          order of the named parameters.
\&           : @param : an array of parameters, either as a list (in
\&           :          which case the function simply returns the list),
\&           :          or as an associative array with hyphenated tags
\&           :          (in which case the function sorts the values 
\&           :          according to @{$order} and returns that new array.)
\&               :              The tags can be upper, lower, or mixed case
\&           :          but they must start with a hyphen (at least the
\&           :          first one should be hyphenated.)
\& Source    : This function was taken from CGI.pm, written by Dr. Lincoln
\&           : Stein, and adapted for use in Bio::Seq by Richard Resnick and
\&           : then adapted for use in Bio::Root::Object.pm by Steve Chervitz,
\&           : then migrated into Bio::Root::RootI.pm by Ewan Birney.
\& Comments  :
\&           : Uppercase tags are the norm, 
\&           : (SAC)
\&           : This method may not be appropriate for method calls that are
\&           : within in an inner loop if efficiency is a concern.
\&           :
\&           : Parameters can be specified using any of these formats:
\&           :  @param = (-name=>'me', -color=>'blue');
\&           :  @param = (-NAME=>'me', -COLOR=>'blue');
\&           :  @param = (-Name=>'me', -Color=>'blue');
\&           :  @param = ('me', 'blue');
\&           : A leading hyphenated argument is used by this function to 
\&           : indicate that named parameters are being used.
\&           : Therefore, the ('me', 'blue') list will be returned as-is.
\&           :
\&               : Note that Perl will confuse unquoted, hyphenated tags as 
\&           : function calls if there is a function of the same name 
\&           : in the current namespace:
\&           :    -name => 'foo' is interpreted as -&name => 'foo'
\&               :
\&           : For ultimate safety, put single quotes around the tag:
\&               : ('-name'=>'me', '-color' =>'blue');
\&           : This can be a bit cumbersome and I find not as readable
\&           : as using all uppercase, which is also fairly safe:
\&               : (-NAME=>'me', -COLOR =>'blue');
\&               :
\&           : Personal note (SAC): I have found all uppercase tags to
\&           : be more managable: it involves less single-quoting,
\&           : the key names stand out better, and there are no method naming 
\&           : conflicts.
\&           : The drawbacks are that it's not as easy to type as lowercase,
\&           : and lots of uppercase can be hard to read.
\&           :
\&           : Regardless of the style, it greatly helps to line
\&               : the parameters up vertically for long/complex lists.
\&           :
\&           : Note that if @param is a single string that happens to start with
\&           : a dash, it will be treated as a hash key and probably fail to
\&           : match anything in the array_ref, so not be returned as normally
\&           : happens when @param is a simple list and not an associative array.
.Ve
.Sh "_register_for_cleanup"
.IX Subsection "_register_for_cleanup"
.Vb 7
\& Title   : _register_for_cleanup
\& Usage   : -- internal --
\& Function: Register a method to be called at DESTROY time. This is useful
\&           and sometimes essential in the case of multiple inheritance for
\&           classes coming second in the sequence of inheritance.
\& Returns : 
\& Args    : a code reference
.Ve
.PP
The code reference will be invoked with the object as the first
argument, as per a method.  You may register an unlimited number of
cleanup methods.
.Sh "_unregister_for_cleanup"
.IX Subsection "_unregister_for_cleanup"
.Vb 7
\& Title   : _unregister_for_cleanup
\& Usage   : -- internal --
\& Function: Remove a method that has previously been registered to be called
\&           at DESTROY time.  If called with a method to be called at DESTROY time.
\&           Has no effect if the code reference has not previously been registered.
\& Returns : nothing
\& Args    : a code reference
.Ve
.Sh "_cleanup_methods"
.IX Subsection "_cleanup_methods"
.Vb 5
\& Title   : _cleanup_methods
\& Usage   : -- internal --
\& Function: Return current list of registered cleanup methods.
\& Returns : list of coderefs
\& Args    : none
.Ve
.Sh "throw_not_implemented"
.IX Subsection "throw_not_implemented"
.Vb 16
\& Purpose : Throws a Bio::Root::NotImplemented exception.
\&           Intended for use in the method definitions of 
\&           abstract interface modules where methods are defined
\&           but are intended to be overridden by subclasses.
\& Usage   : $object->throw_not_implemented();
\& Example : sub method_foo { 
\&             $self = shift; 
\&             $self->throw_not_implemented();
\&           }
\& Returns : n/a
\& Args    : n/a
\& Throws  : A Bio::Root::NotImplemented exception.
\&           The message of the exception contains
\&             - the name of the method 
\&             - the name of the interface 
\&             - the name of the implementing class
.Ve
.PP
.Vb 3
\&           If this object has a throw() method, $self->throw will be used.
\&           If the object doesn't have a throw() method, 
\&           Carp::confess() will be used.
.Ve
.Sh "warn_not_implemented"
.IX Subsection "warn_not_implemented"
.Vb 14
\& Purpose : Generates a warning that a method has not been implemented.
\&           Intended for use in the method definitions of 
\&           abstract interface modules where methods are defined
\&           but are intended to be overridden by subclasses.
\&           Generally, throw_not_implemented() should be used,
\&           but warn_not_implemented() may be used if the method isn't
\&           considered essential and convenient no-op behavior can be 
\&           provided within the interface.
\& Usage   : $object->warn_not_implemented( method-name-string );
\& Example : $self->warn_not_implemented( "get_foobar" );
\& Returns : Calls $self->warn on this object, if available.
\&           If the object doesn't have a warn() method,
\&           Carp::carp() will be used.
\& Args    : n/a
.Ve
