.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Map::FPCMarker 3"
.TH Bio::Map::FPCMarker 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Map::FPCMarker \- An central map object representing a marker
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&   # get the marker object of $marker from the Bio::Map::FPCMarker
\&   my $markerobj = $physical->get_markerobj($marker);
.Ve
.PP
.Vb 4
\&   # acquire all the clones that hit this marker
\&   foreach my $clone ($markerobj->each_cloneid()) {
\&       print "   +++$clone\en";
\&   }
.Ve
.PP
.Vb 3
\&   # find the position of this marker in $contig
\&   print "Position in contig $contig"," = ",$markerobj->position($contig),
\&         "\en";
.Ve
.PP
.Vb 2
\&   # find the group of the marker
\&   print "Group : ",$markerobj->group();
.Ve
.PP
See Bio::Map::Position and Bio::Map::PositionI for more information.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object handles the notion of a marker.
This object is intended to be used by a map parser like fpc.pm.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Gaurav Gupta"
.IX Header "AUTHOR - Gaurav Gupta"
Email gaurav@genome.arizona.edu
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Sendu Bala  bix@sendu.me.uk
.SH "PROJECT LEADERS"
.IX Header "PROJECT LEADERS"
Jamie Hatfield      jamie@genome.arizona.edu
Dr. Cari Soderlund  cari@genome.arizona.edu
.SH "PROJECT DESCRIPTION"
.IX Header "PROJECT DESCRIPTION"
The project was done in Arizona Genomics Computational Laboratory (AGCoL)
at University of Arizona.
.PP
This work was funded by USDA-IFAFS grant #11180 titled \*(L"Web Resources for 
the Computation and Display of Physical Mapping Data\*(R".
.PP
For more information on this project, please refer: 
  http://www.genome.arizona.edu
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.Sh "new"
.IX Subsection "new"
.Vb 15
\& Title   : new
\& Usage   : my $clone = Bio::Map::FPCMarker->new
\&                      (
\&                       -name    => $marker,
\&                       -type    => $type,
\&                       -global  => $global,
\&                       -frame   => $frame,
\&                       -group   => $group,
\&                       -subgroup=> $subgroup,
\&                       -anchor  => $anchor,
\&                       -clones  => \e%clones,
\&                       -contigs => \e%contigs,
\&                       -position => \e%markerpos,
\&               -remark => $remark
\&                       );
.Ve
.PP
.Vb 15
\& Function: Initialize a new Bio::Map::FPCMarker object
\&           Most people will not use this directly but get Markers
\&           through L<Bio::MapIO::fpc>
\& Returns : L<Bio::Map::FPCMarker> object
\& Args    : -name     => marker name string,
\&               -type     => type string,
\&               -global   => global position for marker,
\&               -frame    => boolean if marker is framework or placement,
\&               -group    => group number for marker,
\&               -subgroup => subgroup number of marker,
\&               -anchor   => boolean if marker is anchored,
\&               -clones   => all the clone elements in map (hashref),
\&               -contigs  => all the contig elements (hasref),
\&               -position => mapping of marker names to map position (hasref),
\&           -remark   => remarks, separated by newlines
.Ve
.SH "Access Methods"
.IX Header "Access Methods"
These methods let you get and set the member variables
.Sh "name"
.IX Subsection "name"
.Vb 5
\& Title   : name
\& Usage   : my $name = $markerobj->name();
\& Function: Get/set the name for this marker
\& Returns : scalar representing the current name of this marker
\& Args    : none to get, OR string to set
.Ve
.Sh "type"
.IX Subsection "type"
.Vb 5
\& Title   : type
\& Usage   : my $type = $markerobj->type();
\& Function: Get/set the type for this marker
\& Returns : scalar representing the current type of this marker
\& Args    : none to get, OR string to set
.Ve
.Sh "global"
.IX Subsection "global"
.Vb 5
\& Title   : global
\& Usage   : my $type = $markerobj->global();
\& Function: Get/set the global position for this marker
\& Returns : scalar representing the current global position of this marker
\& Args    : none to get, OR string to set
.Ve
.Sh "anchor"
.IX Subsection "anchor"
.Vb 5
\& Title   : anchor
\& Usage   : my $anchor = $markerobj->anchor();
\& Function: indicate if the Marker is anchored or not (True | False)
\& Returns : scalar representing the anchor (1 | 0) for this marker
\& Args    : none to get, OR 1|0 to set
.Ve
.Sh "framework"
.IX Subsection "framework"
.Vb 6
\& Title   : framework
\& Usage   : $frame = $markerobj->framework();
\& Function: indicate if the Marker is framework or placement (1 | 0)
\& Returns : scalar representing if the marker is framework
\&           (1 if framework, 0 if placement)
\& Args    : none to get, OR 1|0 to set
.Ve
.Sh "group"
.IX Subsection "group"
.Vb 6
\& Title   : group
\& Usage   : $grpno = $markerobj->group();
\& Function: Get/set the group number for this marker. This is a generic term,
\&           used for Linkage-Groups as well as for Chromosomes.
\& Returns : scalar representing the group number of this marker
\& Args    : none to get, OR string to set
.Ve
.Sh "subgroup"
.IX Subsection "subgroup"
.Vb 8
\& Title   : subgroup
\& Usage   : $subgroup = $marker->subgroup();     
\& Function: Get/set the subgroup for this marker. This is a generic term:
\&           subgroup here could represent subgroup of a Chromosome or of a
\&           Linkage Group. The user must take care of which subgroup he/she is
\&           querying for.        
\& Returns : scalar representing the subgroup of this marker
\& Args    : none to get, OR string to set
.Ve
.Sh "position"
.IX Subsection "position"
.Vb 7
\& Title   : position
\& Usage   : $markerpos = $markerobj->position($ctg);
\& Function: get the position of the marker in the contig
\& Returns : scalar representing the position of the markernumber of
\&           the contig
\& Args    : $ctg is necessary to look for the position of the marker
\&           in that contig.
.Ve
.PP
.Vb 1
\& *** This has nothing to do with an actual Bio::Map::PositionI object ***
.Ve
.Sh "remark"
.IX Subsection "remark"
.Vb 5
\& Title   : remark
\& Usage   : $markerremark = $markerobj->remark();
\& Function: get the remarks for this marker
\& Returns : scalar of newline-separated markers
\& Args    : none
.Ve
.Sh "each_cloneid"
.IX Subsection "each_cloneid"
.Vb 5
\& Title   : each_cloneid
\& Usage   : my @clones  = $map->each_cloneid();
\& Function: retrieves all the clone ids in a map unordered
\& Returns : list of strings (ids)
\& Args    : none
.Ve
.PP
.Vb 2
\& *** This only supplies the ids set with the set_clones method ***
\& *** It has nothing to do with actual Bio::Map::MappableI objects ***
.Ve
.Sh "each_contigid"
.IX Subsection "each_contigid"
.Vb 5
\& Title   : each_contigid
\& Usage   : my @contigs = $map->each_contigid();
\& Function: retrieves all the contig ids in a map unordered
\& Returns : list of strings (ids)
\& Args    : none
.Ve
.PP
.Vb 2
\& *** This only supplies the ids set with the set_contigs method ***
\& *** It has nothing to do with actual Bio::Map::MapI objects ***
.Ve
.Sh "set_clones"
.IX Subsection "set_clones"
.Vb 5
\& Title   : set_clones
\& Usage   : $marker->set_clones(\e%clones)
\& Function: Set the clone ids hashref
\& Returns : None
\& Args    : Hashref of clone ids
.Ve
.PP
.Vb 2
\& *** This only sets a hash of ids ***
\& *** It has nothing to do with actual Bio::Map::MappableI objects ***
.Ve
.Sh "set_contigs"
.IX Subsection "set_contigs"
.Vb 5
\& Title   : set_contigs
\& Usage   : $marker->set_contigs(\e%contigs)
\& Function: Set the contig ids hashref
\& Returns : None
\& Args    : Hashref of contig ids
.Ve
.PP
.Vb 2
\& *** This only sets a hash of ids ***
\& *** It has nothing to do with actual Bio::Map::MapI objects ***
.Ve
.Sh "set_positions"
.IX Subsection "set_positions"
.Vb 5
\& Title   : set_positions
\& Usage   : $marker->set_positions(\e%markerpos)
\& Function: Set the positions hashref
\& Returns : None
\& Args    : Hashref of marker positions
.Ve
.PP
.Vb 2
\& *** This only sets a hash of numbers ***
\& *** It has nothing to do with actual Bio::Map::PositionI objects ***
.Ve
