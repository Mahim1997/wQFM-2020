.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Tools::RestrictionEnzyme 3"
.TH Bio::Tools::RestrictionEnzyme 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Tools::RestrictionEnzyme \- Bioperl object for a restriction endonuclease
(cuts DNA at specific locations)
.PP
DEPRECATED. Please use the Bio::Restriction modules instead.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Bio::Tools::RestrictionEnzyme;
.Ve
.PP
.Vb 1
\&  ## Create a new object by name.
.Ve
.PP
.Vb 1
\&  $re1 = Bio::Tools::RestrictionEnzyme->new(-NAME =>'EcoRI');
.Ve
.PP
.Vb 3
\&  ## Create a new object using special syntax
\&  ## which specifies the enzyme name, recognition site, and cut position.
\&  ## Used for enzymes not known to this module.
.Ve
.PP
.Vb 2
\&  $re2 = Bio::Tools::RestrictionEnzyme->new(-NAME =>'EcoRV--GAT^ATC', 
\&                                            -MAKE =>'custom');
.Ve
.PP
.Vb 2
\&  ## Get a list of the resulting fragments when a sequence is cut with
\&  ## the given enzyme. The method expects a Bio::Seq object.
.Ve
.PP
.Vb 1
\&  @fragments = $re2->cut_seq($seqobj);
.Ve
.PP
.Vb 2
\&  ## Get a list of names of all available restriction enzymes 
\&  ## known to this module.
.Ve
.PP
.Vb 1
\&  @all = $re->available_list();
.Ve
.PP
.Vb 2
\&  ## Get the names of restriction enzymes that have 6 bp 
\&  ## recognition sequences.
.Ve
.PP
.Vb 1
\&  @sixcutters = $re->available_list(6);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Bio::Tools::RestrictionEnzyme.pm module encapsulates generic data and 
methods for using restriction endonucleases for in silico restriction
analysis of \s-1DNA\s0 sequences.
.Sh "Considerations"
.IX Subsection "Considerations"
This module is a precursor for a more full featured version that may do such
things as download data from online databases such as REBase <http://rebase.neb.com/>.
Thus, there is currently no functionality for obtaining data regarding commercial
availability of a restriction enzyme.
.PP
At some point in the future, it may make sense to derive RestrictionEnzymes
from a class such as Bio::Enzyme or Bio::Prot::Protein (neither of which now
exist) so that more data about the enzyme and related information can be 
easily obtained.
.PP
This module is currently in use at <http://genome\-www.stanford.edu/Sacch3D/analysis/>.
.Sh "Digesting on Runs of N"
.IX Subsection "Digesting on Runs of N"
To digest a sequence on runs of N's in the sequence. Here's what you can do:
.PP
.Vb 2
\&    $re_n  = Bio::Tools::RestrictionEnzyme->new(-name=>'N--NNNNN',
\&                                                -make=>'custom');
.Ve
.PP
Specify the number of N's you want to match in the \-name parameter. 
So the above example will recognize and cut at runs of 5 Ns.
If you wanted to cut at runs of 10 N's, you would use 
.PP
.Vb 1
\&     -name => 'N--NNNNNNNNNN'
.Ve
.PP
Note that you must use a specific number of N's, you cannot use a regexp to
digest at N+ for example, because the actual number of N's at each site are
not recorded when the sequence is analyzed. So cut_locations( ) wouldn't be 
correct. 
.SH "EXAMPLES"
.IX Header "EXAMPLES"
See the script \f(CW\*(C`examples/restriction.pl\*(C'\fR in the Bioperl distribution.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
Bio::Tools::RestrictionEnzyme is a concrete class that inherits from 
Bio::Root::Root and uses by delegation Bio::PrimarySeq.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other Bioperl
modules. Send your comments and suggestions preferably to one of the Bioperl
mailing lists. Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Steve Chervitz, <sac\-at\-bioperl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1997\-2002 Steve A. Chervitz. All Rights Reserved.
This module is free software; you can redistribute it and/or 
modify it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Bio::Root::Root, 
Bio::PrimarySeq.
.SH "APPENDIX"
.IX Header "APPENDIX"
Methods beginning with a leading underscore are considered private
and are intended for internal use by this module. They are
\&\fBnot\fR considered part of the public interface and are described here
for documentation purposes only.
.SH "new"
.IX Header "new"
.Vb 7
\& Title     : new
\& Purpose   : Initializes the RestrictionEnzyme object and calls
\&           : superclass constructor last (Bio:Seq.pm).
\& Returns   : n/a
\& Argument  : Parameters passed to new()
\& Comments  : A RestrictionEnzyme object manages its recognition sequence
\&           : as a Bio::PrimarySeq object.
.Ve
.PP
See Also   : _make_custom(), _make_standard(), Bio::PrimarySeq.\fIpm::_initialize()\fR
.SH "cuts_after"
.IX Header "cuts_after"
.Vb 11
\& Title     : cuts_after
\& Usage     : $num = $re->cuts_after();
\& Purpose   : Sets/Gets an integer indicating the position of cleavage 
\&           : relative to the 5' end of the recognition sequence.
\& Returns   : Integer
\& Argument  : Integer (optional)
\& Throws    : Exception if argument is non-numeric.
\& Access    : Public
\& Comments  : This method is only needed to change the cuts at
\&           : position. This data is automatically set during
\&           : construction.
.Ve
.PP
See Also   : \fI_make_standard()\fR, \fI_make_custom()\fR
.SH "site"
.IX Header "site"
.Vb 10
\& Title     : site
\& Usage     : $re->site();
\& Purpose   : Gets the recognition sequence for the enzyme. 
\& Example   : $seq_string = $re->site();
\& Returns   : String containing recognition sequence indicating 
\&           : cleavage site as in  'G^AATTC'.
\& Argument  : n/a
\& Throws    : n/a
\& Comments  : If you want a simple string representing the site without 
\&             any '^', use the string() method.
.Ve
.PP
See Also   : \fIstring()\fR
.SH "seq"
.IX Header "seq"
.Vb 7
\& Title     : seq
\& Usage     : $re->seq();
\& Purpose   : Get the Bio::PrimarySeq.pm-derived object representing 
\&           : the recognition sequence
\& Returns   : String
\& Argument  : n/a
\& Throws    : n/a
.Ve
.PP
See Also   : \fIstring()\fR, \fIrevcom()\fR
.SH "string"
.IX Header "string"
.Vb 8
\& Title     : string
\& Usage     : $re->string();
\& Purpose   : Get a string representing the recognition sequence.
\& Returns   : String. Does NOT contain a  '^' representing the cut location
\&             as returned by the site() method
\& Argument  : n/a
\& Throws    : n/a
\& Comments  : Delegates to the Bio::PrimarySeq-derived object.
.Ve
.PP
See Also   : \fIseq()\fR, \fIsite()\fR, \fIrevcom()\fR
.SH "revcom"
.IX Header "revcom"
.Vb 10
\& Title     : revcom
\& Usage     : $re->revcom();
\& Purpose   : Get a string representing the reverse complement of
\&           : the recognition sequence.
\& Returns   : String
\& Argument  : n/a
\& Throws    : n/a
\& Comments  : Delegates to the Bio::PrimarySeq.pm-derived object, but needs to
\&             get out the string from it, as now Bio::PrimarySeq->revcom makes a
\&             Bio::PrimarySeq object
.Ve
.PP
See Also   : \fIseq()\fR, \fIstring()\fR
.SH "cut_seq"
.IX Header "cut_seq"
.Vb 19
\& Title     : cut_seq
\& Usage     : $re->cut_seq(<sequence object>);
\& Purpose   : Conceptually cut or "digest" a DNA sequence with the given enzyme.
\& Example   : $string = $re->cut_seq(<sequence object>); 
\& Returns   : List of strings containing the resulting fragments.
\& Argument  : Reference to a Bio::PrimarySeq.pm-derived object.
\& Throws    : Exception if argument is not an object.
\&           : (Does not yet verify that it is derived from Bio::PrimarySeq.pm.)
\& Comments  : Strategy relies on Perl's built-in split() function.
\&           : Since split removes the recognition pattern, the resulting
\&           : fragments are repaired after split()-ing.
\&           : A side-effect of this is that for sites with ambiguous
\&           : recognition sequence (i.e., containing N), the fragments
\&           : will contain ambiguity characters instead of AGCT.
\&           :
\&           : There is currently no support for partial digestions.
\&           : There is currently no support for circular sequences.
\&           : (This should just involve merging the first and last frag
\&           : if $seqObj->is_circular returns true).
.Ve
.SH "cut_locations"
.IX Header "cut_locations"
.Vb 9
\& Title     : cut_locations
\& Usage     : my $locations = $re->cut_locations(<sequence_object>);
\& Purpose   : Report the location of the recognition site(s) within
\&           : an input sequence. 
\& Example   : my $locations = $re->annotate_seq($seqObj);
\& Returns   : Arrayref of starting locations where enzyme would cut 
\& Argument  : Reference to a Bio::PrimarySeqI-derived sequence object.
\& Throws    : n/a
\& Comments  :
.Ve
.SH "annotate_seq"
.IX Header "annotate_seq"
.Vb 10
\& Title     : annotate_seq
\& Usage     : $re->annotate_seq(<sequence_object>);
\& Purpose   : Identify the location of the recognition site(s) within
\&           : an input sequence. Uses HTML.
\& Example   : $annot_seq = $re->annotate_seq($seqObj);
\& Returns   : String containing the annotated sequence.
\& Argument  : Reference to a Bio::PrimarySeq.pm-derived sequence object.
\& Throws    : n/a
\& Comments  : The annotated sequence must be viewed with a web
\&           : browser to see the location(s) of the recognition site(s).
.Ve
.SH "palindromic"
.IX Header "palindromic"
.Vb 10
\& Title     : palindromic
\& Usage     : $re->palindromic();
\& Purpose   : Determines if the recognition sequence is palindromic
\&           : for the current restriction enzyme.
\& Returns   : Boolean
\& Argument  : n/a
\& Throws    : n/a
\& Access    : Public 
\& Comments  : A palindromic site (EcoRI): 5-GAATTC-3
\&           :                             3-CTTAAG-5
.Ve
.SH "is_available"
.IX Header "is_available"
.Vb 12
\& Title     : is_available
\& Usage     : $re->is_available(<string containing name of enzyme>);
\& Purpose   : Determine if an enzyme is available (to this module).
\&           : (see the package lexical %RE).
\& Example   : $re->is_available('EcoRI');
\&           : &Bio::Tools::RestrictionEnzyme::is_available($object,'EcoRI');
\& Returns   : Boolean
\& Argument  : String
\& Throws    : n/a
\& Comments  : This method does NOT give information about
\&           : commercial availability (yet). 
\&           : Enzyme names are CASE SENSITIVE.
.Ve
.PP
See Also   : \fIavailable_list()\fR
.Sh "name"
.IX Subsection "name"
.Vb 6
\& Title   : name
\& Usage   : $obj->name($newval)
\& Function: 
\& Example : 
\& Returns : value of name
\& Args    : newvalue (optional)
.Ve
.SH "available_list"
.IX Header "available_list"
.Vb 9
\& Title     : available_list
\& Usage     : $re->available_list([<integer>]);
\& Purpose   : Retrieve a list of currently available enzymes.
\& Example   : @all = $re->available_list();  ## All enzymes
\&           : @six_cutters = $re->available_list(6);  ## All 6-cutters
\& Returns   : List of strings
\& Argument  : Integer (optional)
\& Throws    : n/a
\& Comments  : This method may be more appropriate for a REData.pm class.
.Ve
.PP
See Also   : \fIis_available()\fR
