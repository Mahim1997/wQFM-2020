.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Root::Exception 3"
.TH Bio::Root::Exception 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Root::Exception \- Generic exception objects for Bioperl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Sh "Throwing exceptions using \fIError::throw()\fP:"
.IX Subsection "Throwing exceptions using Error::throw():"
.Vb 2
\&    use Bio::Root::Exception;
\&    use Error;
.Ve
.PP
.Vb 2
\&    # Set Error::Debug to include stack trace data in the error messages
\&    $Error::Debug = 1;
.Ve
.PP
.Vb 3
\&    $file = shift;
\&    open (IN, $file) ||
\&            throw Bio::Root::FileOpenException ( "Can't open file $file for reading", $!);
.Ve
.Sh "Throwing exceptions using \fIBio::Root::Root::throw()\fP:"
.IX Subsection "Throwing exceptions using Bio::Root::Root::throw():"
.Vb 1
\&     # Here we have an object that ISA Bio::Root::Root, so it inherits throw().
.Ve
.PP
.Vb 4
\&     open (IN, $file) || 
\&                $object->throw(-class => 'Bio::Root::FileOpenException',
\&                               -text => "Can't open file $file for reading",
\&                               -value => $!);
.Ve
.Sh "Catching and handling exceptions using \fIError::try()\fP:"
.IX Subsection "Catching and handling exceptions using Error::try():"
.Vb 2
\&    use Bio::Root::Exception;
\&    use Error qw(:try);
.Ve
.PP
.Vb 1
\&    # Note that we need to import the 'try' tag from Error.pm
.Ve
.PP
.Vb 2
\&    # Set Error::Debug to include stack trace data in the error messages
\&    $Error::Debug = 1;
.Ve
.PP
.Vb 13
\&    $file = shift;
\&    try {
\&        open (IN, $file) ||
\&            throw Bio::Root::FileOpenException ( "Can't open file $file for reading", $!);
\&    }
\&    catch Bio::Root::FileOpenException with {
\&        my $err = shift;
\&        print STDERR "Using default input file: $default_file\en";
\&        open (IN, $default_file) || die "Can't open $default_file";
\&    }
\&    otherwise {
\&        my $err = shift;
\&        print STDERR "An unexpected exception occurred: \en$err";
.Ve
.PP
.Vb 8
\&        # By placing an the error object reference within double quotes,
\&        # you're invoking its stringify() method.
\&    }
\&   finally {
\&       # Any code that you want to execute regardless of whether or not
\&       # an exception occurred.
\&   };  
\&   # the ending semicolon is essential!
.Ve
.Sh "Defining a new Exception type as a subclass of Bio::Root::Exception:"
.IX Subsection "Defining a new Exception type as a subclass of Bio::Root::Exception:"
.Vb 1
\&    @Bio::TestException::ISA = qw( Bio::Root::Exception );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Sh "Exceptions defined in Bio::Root::Exception"
.IX Subsection "Exceptions defined in Bio::Root::Exception"
These are generic exceptions for typical problem situations that could arise
in any module or script. 
.IP "\fIBio::Root::Exception()\fR" 8
.IX Item "Bio::Root::Exception()"
.PD 0
.IP "\fIBio::Root::NotImplemented()\fR" 8
.IX Item "Bio::Root::NotImplemented()"
.IP "\fIBio::Root::IOException()\fR" 8
.IX Item "Bio::Root::IOException()"
.IP "\fIBio::Root::FileOpenException()\fR" 8
.IX Item "Bio::Root::FileOpenException()"
.IP "\fIBio::Root::SystemException()\fR" 8
.IX Item "Bio::Root::SystemException()"
.IP "\fIBio::Root::BadParameter()\fR" 8
.IX Item "Bio::Root::BadParameter()"
.IP "\fIBio::Root::OutOfRange()\fR" 8
.IX Item "Bio::Root::OutOfRange()"
.IP "\fIBio::Root::NoSuchThing()\fR" 8
.IX Item "Bio::Root::NoSuchThing()"
.PD
.PP
Using defined exception classes like these is a good idea because it
indicates the basic nature of what went wrong in a convenient,
computable way.
.PP
If there is a type of exception that you want to throw
that is not covered by the classes listed above, it is easy to define
a new one that fits your needs. Just write a line like the following
in your module or script where you want to use it (or put it somewhere
that is accessible to your code):
.PP
.Vb 1
\&    @NoCanDoException::ISA = qw( Bio::Root::Exception );
.Ve
.PP
All of the exceptions defined in this module inherit from a common
base class exception, Bio::Root::Exception. This allows a user to
write a handler for all Bioperl-derived exceptions as follows:
.PP
.Vb 2
\&           use Bio::Whatever;
\&           use Error qw(:try);
.Ve
.PP
.Vb 7
\&           try {
\&                # some code that depends on Bioperl
\&           }
\&           catch Bio::Root::Exception with {
\&               my $err = shift;
\&               print "A Bioperl exception occurred:\en$err\en";
\&           };
.Ve
.PP
So if you do create your own exceptions, just be sure they inherit
from Bio::Root::Exception directly, or indirectly by inheriting from a
Bio::Root::Exception subclass.
.PP
The exceptions in Bio::Root::Exception are extensions of Graham Barr's
Error module available from \s-1CPAN\s0.  Despite this dependency, the
Bio::Root::Exception module does not explicitly \f(CW\*(C`require Error\*(C'\fR.
This permits Bio::Root::Exception to be loaded even when
Error.pm is not available.
.Sh "Throwing exceptions within Bioperl modules"
.IX Subsection "Throwing exceptions within Bioperl modules"
Error.pm is not part of the Bioperl distibution, and may not be
present within  any given perl installation. So, when you want to 
throw an exception in a Bioperl module, the safe way to throw it
is to use \fIBio::Root::Root::throw()\fR which can use Error.pm 
when it's available. See documentation in Bio::Root::Root for details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
See the \f(CW\*(C`examples/exceptions\*(C'\fR directory of the Bioperl distribution for 
working demo code.
.PP
\&\fIBio::Root::Root::throw()\fR for information about throwing 
Bio::Root::Exception\-based exceptions.
.PP
Error (available from \s-1CPAN\s0, author: \s-1GBARR\s0)
.PP
Error.pm is helping to guide the design of exception handling in Perl 6. 
See these \s-1RFC\s0's: 
.PP
.Vb 1
\&     http://dev.perl.org/rfc/63.pod
.Ve
.PP
.Vb 1
\&     http://dev.perl.org/rfc/88.pod
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Steve Chervitz <sac@bioperl.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2001 Steve Chervitz. All Rights Reserved.
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This software is provided \*(L"as is\*(R" without warranty of any kind.
.SH "EXCEPTIONS"
.IX Header "EXCEPTIONS"
.Sh "Bio::Root::Exception"
.IX Subsection "Bio::Root::Exception"
.Vb 4
\& Purpose : A generic base class for all BioPerl exceptions.
\&           By including a "catch Bio::Root::Exception" block, you
\&           should be able to trap all BioPerl exceptions.
\& Example : throw Bio::Root::Exception("A generic exception", $!);
.Ve
.Sh "Methods defined by Bio::Root::Exception"
.IX Subsection "Methods defined by Bio::Root::Exception"
.IP "\fInew()\fR" 4
.IX Item "new()"
.Vb 2
\& Purpose : Guarantees that -value is set properly before
\&           calling Error::new().
.Ve
.Sp
.Vb 1
\& Arguments: key-value style arguments same as for Error::new()
.Ve
.Sp
.Vb 2
\&     You can also specify plain arguments as ($message, $value)
\&     where $value is optional.
.Ve
.Sp
.Vb 5
\&     -value, if defined, must be non-zero and not an empty string 
\&     in order for eval{}-based exception handlers to work. 
\&     These require that if($@) evaluates to true, which will not 
\&     be the case if the Error has no value (Error overloads 
\&     numeric operations to the Error::value() method).
.Ve
.Sp
.Vb 2
\&     It is OK to create Bio::Root::Exception objects without
\&     specifing -value. In this case, an invisible dummy value is used.
.Ve
.Sp
.Vb 2
\&     If you happen to specify a -value of zero (0), it will
\&     be replaced by the string "The number zero (0)".
.Ve
.Sp
.Vb 2
\&     If you happen to specify a -value of empty string (""), it will
\&     be replaced by the string "An empty string ("")".
.Ve
.IP "\fIpretty_format()\fR" 4
.IX Item "pretty_format()"
.Vb 6
\& Purpose : Get a nicely formatted string containing information about the 
\&           exception. Format is similar to that produced by 
\&           Bio::Root::Root::throw(), with the addition of the name of
\&           the exception class in the EXCEPTION line and some other
\&           data available via the Error object.
\& Example : print $error->pretty_format;
.Ve
.IP "\fIstringify()\fR" 4
.IX Item "stringify()"
.Vb 7
\& Purpose : Overrides Error::stringify() to call pretty_format(). 
\&           This is called automatically when an exception object 
\&           is placed between double quotes.
\& Example : catch Bio::Root::Exception with {
\&              my $error = shift;
\&              print "$error";
\&           }
.Ve
.Sp
See Also: \fIpretty_format()\fR
.SH "Subclasses of Bio::Root::Exception"
.IX Header "Subclasses of Bio::Root::Exception"
.Sh "Bio::Root::NotImplemented"
.IX Subsection "Bio::Root::NotImplemented"
.Vb 4
\& Purpose : Indicates that a method has not been implemented.
\& Example : throw Bio::Root::NotImplemented( 
\&               -text   => "Method \e"foo\e" not implemented in module FooBar.",
\&               -value  => "foo" );
.Ve
.Sh "Bio::Root::IOException"
.IX Subsection "Bio::Root::IOException"
.Vb 4
\& Purpose : Indicates that some input/output-related trouble has occurred.
\& Example : throw Bio::Root::IOException( 
\&               -text   => "Can't save data to file $file.",
\&               -value  => $! );
.Ve
.Sh "Bio::Root::FileOpenException"
.IX Subsection "Bio::Root::FileOpenException"
.Vb 4
\& Purpose : Indicates that a file could not be opened.
\& Example : throw Bio::Root::FileOpenException( 
\&               -text   => "Can't open file $file for reading.",
\&               -value  => $! );
.Ve
.Sh "Bio::Root::SystemException"
.IX Subsection "Bio::Root::SystemException"
.Vb 4
\& Purpose : Indicates that a system call failed.
\& Example : unlink($file) or throw Bio::Root::SystemException( 
\&               -text   => "Can't unlink file $file.",
\&               -value  => $! );
.Ve
.Sh "Bio::Root::BadParameter"
.IX Subsection "Bio::Root::BadParameter"
.Vb 5
\& Purpose : Indicates that one or more parameters supplied to a method 
\&           are invalid, unspecified, or conflicting.
\& Example : throw Bio::Root::BadParameter( 
\&               -text   => "Required parameter \e"-foo\e" was not specified",
\&               -value  => "-foo" );
.Ve
.Sh "Bio::Root::OutOfRange"
.IX Subsection "Bio::Root::OutOfRange"
.Vb 5
\& Purpose : Indicates that a specified (start,end) range or 
\&           an index to an array is outside the permitted range.
\& Example : throw Bio::Root::OutOfRange( 
\&               -text   => "Start coordinate ($start) cannot be less than zero.",
\&               -value  => $start  );
.Ve
.Sh "Bio::Root::NoSuchThing"
.IX Subsection "Bio::Root::NoSuchThing"
.Vb 5
\& Purpose : Indicates that a requested thing cannot be located 
\&           and therefore could possibly be bogus.
\& Example : throw Bio::Root::NoSuchThing( 
\&               -text   => "Accession M000001 could not be found.",
\&               -value  => "M000001"  );
.Ve
