.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::SearchIO 3"
.TH Bio::SearchIO 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::SearchIO \- Driver for parsing Sequence Database Searches 
(BLAST, FASTA, ...)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 12
\&   use Bio::SearchIO;
\&   # format can be 'fasta', 'blast', 'exonerate', ...
\&   my $searchio = new Bio::SearchIO( -format => 'blastxml',
\&                                     -file   => 'blastout.xml' );
\&   while ( my $result = $searchio->next_result() ) {
\&       while( my $hit = $result->next_hit ) {
\&        # process the Bio::Search::Hit::HitI object
\&           while( my $hsp = $hit->next_hsp ) { 
\&            # process the Bio::Search::HSP::HSPI object
\&           }
\&       }
\&   }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a driver for instantiating a parser for report files from
sequence database searches. This object serves as a wrapper for the
format parsers in Bio::SearchIO::* \- you should not need to ever
use those format parsers directly. (For people used to the SeqIO
system it, we are deliberately using the same pattern).
.PP
Once you get a SearchIO object, calling \fInext_result()\fR gives you back
a Bio::Search::Result::ResultI compliant object, which is an object that
represents one Blast/Fasta/HMMER whatever report.
.PP
A list of module names and formats is below:
.PP
.Vb 12
\&  blast      BLAST (WUBLAST, NCBIBLAST,bl2seq)   
\&  fasta      FASTA -m9 and -m0
\&  blasttable BLAST -m9 or -m8 output (NCBI not WUBLAST tabular)
\&  megablast  MEGABLAST
\&  psl        UCSC PSL format
\&  waba       WABA output
\&  axt        AXT format
\&  sim4       Sim4
\&  hmmer      HMMER hmmpfam and hmmsearch
\&  exonerate  Exonerate CIGAR and VULGAR format
\&  blastxml   NCBI BLAST XML
\&  wise       Genewise -genesf format
.Ve
.PP
Also see the SearchIO \s-1HOWTO:\s0
http://bioperl.open\-bio.org/wiki/HOWTO:SearchIO
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Jason Stajich & Steve Chervitz"
.IX Header "AUTHOR - Jason Stajich & Steve Chervitz"
Email jason\-at\-bioperl.org
Email sac\-at\-bioperl.org
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.Sh "new"
.IX Subsection "new"
.Vb 12
\& Title   : new
\& Usage   : my $obj = new Bio::SearchIO();
\& Function: Builds a new Bio::SearchIO object 
\& Returns : Bio::SearchIO initialized with the correct format
\& Args    : -file           => $filename
\&           -format         => format
\&           -fh             => filehandle to attach to
\&           -result_factory => Object implementing Bio::Factory::ObjectFactoryI
\&           -hit_factory    => Object implementing Bio::Factory::ObjectFactoryI
\&           -hsp_factory    => Object implementing Bio::Factory::ObjectFactoryI
\&           -writer         => Object implementing Bio::SearchIO::SearchWriterI
\&           -output_format  => output format, which will dynamically load writer
.Ve
.PP
See Bio::Factory::ObjectFactoryI, Bio::SearchIO::SearchWriterI
.PP
Any factory objects in the arguments are passed along to the
SearchResultEventBuilder object which holds these factories and sets
default ones if none are supplied as arguments.
.Sh "newFh"
.IX Subsection "newFh"
.Vb 10
\& Title   : newFh
\& Usage   : $fh = Bio::SearchIO->newFh(-file=>$filename,
\&                                      -format=>'Format')
\& Function: does a new() followed by an fh()
\& Example : $fh = Bio::SearchIO->newFh(-file=>$filename,
\&                                      -format=>'Format')
\&           $result = <$fh>;   # read a ResultI object
\&           print $fh $result; # write a ResultI object
\& Returns : filehandle tied to the Bio::SearchIO::Fh class
\& Args    :
.Ve
.Sh "fh"
.IX Subsection "fh"
.Vb 8
\& Title   : fh
\& Usage   : $obj->fh
\& Function:
\& Example : $fh = $obj->fh;      # make a tied filehandle
\&           $result = <$fh>;     # read a ResultI object
\&           print $fh $result;   # write a ResultI object
\& Returns : filehandle tied to the Bio::SearchIO::Fh class
\& Args    :
.Ve
.Sh "attach_EventHandler"
.IX Subsection "attach_EventHandler"
.Vb 5
\& Title   : attach_EventHandler
\& Usage   : $parser->attatch_EventHandler($handler)
\& Function: Adds an event handler to listen for events
\& Returns : none
\& Args    : Bio::SearchIO::EventHandlerI
.Ve
.PP
See Bio::SearchIO::EventHandlerI
.Sh "_eventHandler"
.IX Subsection "_eventHandler"
.Vb 5
\& Title   : _eventHandler
\& Usage   : private
\& Function: Get the EventHandler
\& Returns : Bio::SearchIO::EventHandlerI
\& Args    : none
.Ve
.PP
See Bio::SearchIO::EventHandlerI
.Sh "next_result"
.IX Subsection "next_result"
.Vb 3
\& Title   : next_result
\& Usage   : $result = stream->next_result
\& Function: Reads the next ResultI object from the stream and returns it.
.Ve
.PP
.Vb 12
\&           Certain driver modules may encounter entries in the stream that
\&           are either misformatted or that use syntax not yet understood
\&           by the driver. If such an incident is recoverable, e.g., by
\&           dismissing a feature of a feature table or some other non-mandatory
\&           part of an entry, the driver will issue a warning. In the case
\&           of a non-recoverable situation an exception will be thrown.
\&           Do not assume that you can resume parsing the same stream after
\&           catching the exception. Note that you can always turn recoverable
\&           errors into exceptions by calling $stream->verbose(2) (see
\&           Bio::Root::RootI POD page).
\& Returns : A Bio::Search::Result::ResultI object
\& Args    : n/a
.Ve
.PP
See Bio::Root::RootI
.Sh "write_result"
.IX Subsection "write_result"
.Vb 9
\& Title   : write_result
\& Usage   : $stream->write_result($result_result, @other_args)
\& Function: Writes data from the $result_result object into the stream.
\&         : Delegates to the to_string() method of the associated 
\&         : WriterI object.
\& Returns : 1 for success and 0 for error
\& Args    : Bio::Search:Result::ResultI object,
\&         : plus any other arguments for the Writer
\& Throws  : Bio::Root::Exception if a Writer has not been set.
.Ve
.PP
See Bio::Root::Exception
.Sh "writer"
.IX Subsection "writer"
.Vb 7
\& Title   : writer
\& Usage   : $writer = $stream->writer;
\& Function: Sets/Gets a SearchWriterI object to be used for this searchIO.
\& Returns : 1 for success and 0 for error
\& Args    : Bio::SearchIO::SearchWriterI object (when setting)
\& Throws  : Bio::Root::Exception if a non-Bio::SearchIO::SearchWriterI object
\&           is passed in.
.Ve
.Sh "result_count"
.IX Subsection "result_count"
.Vb 6
\& Title   : result_count
\& Usage   : $num = $stream->result_count;
\& Function: Gets the number of Blast results that have been parsed.
\& Returns : integer
\& Args    : none
\& Throws  : none
.Ve
.Sh "_load_format_module"
.IX Subsection "_load_format_module"
.Vb 6
\& Title   : _load_format_module
\& Usage   : *INTERNAL SearchIO stuff*
\& Function: Loads up (like use) a module at run time on demand
\& Example : 
\& Returns : 
\& Args    :
.Ve
.Sh "_guess_format"
.IX Subsection "_guess_format"
.Vb 6
\& Title   : _guess_format
\& Usage   : $obj->_guess_format($filename)
\& Function:
\& Example :
\& Returns : guessed format of filename (lower case)
\& Args    :
.Ve
