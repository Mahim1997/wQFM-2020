.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::AlignIO::phylip 3"
.TH Bio::AlignIO::phylip 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::AlignIO::phylip \- PHYLIP format sequence input/output stream
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
# Do not use this module directly.  Use it via the Bio::AlignIO class.
.PP
.Vb 10
\&    use Bio::AlignIO;
\&    use Bio::SimpleAlign;
\&    #you can set the name length to something other than the default 10
\&    #if you use a version of phylip (hacked) that accepts ids > 10
\&    my $phylipstream = new Bio::AlignIO(-format  => 'phylip',
\&                                        -fh      => \e*STDOUT,
\&                                        -idlength=>30);
\&    # convert data from one format to another
\&    my $gcgstream     =  new Bio::AlignIO(-format => 'msf',
\&                                          -file   => 't/data/cysprot1a.msf');
.Ve
.PP
.Vb 3
\&    while( my $aln = $gcgstream->next_aln ) {
\&        $phylipstream->write_aln($aln);
\&    }
.Ve
.PP
.Vb 9
\&    # do it again with phylip sequential format format
\&    $phylipstream->interleaved(0);
\&    # can also initialize the object like this
\&    $phylipstream = new Bio::AlignIO(-interleaved => 0,
\&                                     -format => 'phylip',
\&                                     -fh   => \e*STDOUT,
\&                                     -idlength=>10);
\&    $gcgstream     =  new Bio::AlignIO(-format => 'msf',
\&                                       -file   => 't/data/cysprot1a.msf');
.Ve
.PP
.Vb 3
\&    while( my $aln = $gcgstream->next_aln ) {
\&        $phylipstream->write_aln($aln);
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object can transform Bio::SimpleAlign objects to and from \s-1PHYLIP\s0
interleaved format. It will not work with \s-1PHYLIP\s0 sequencial format.
.PP
This module will output \s-1PHYLIP\s0 sequential format.  By specifying the
flag \-interleaved => 0 in the initialization the module can output
data in interleaved format.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHORS \- Heikki Lehvaslaiho and Jason Stajich"
.IX Header "AUTHORS - Heikki Lehvaslaiho and Jason Stajich"
Email: heikki at ebi.ac.uk
Email: jason at bioperl.org
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.Sh "new"
.IX Subsection "new"
.Vb 23
\& Title   : new
\& Usage   : my $alignio = new Bio::AlignIO(-format => 'phylip'
\&                                          -file   => '>file',
\&                                          -idlength => 10,
\&                                          -idlinebreak => 1);
\& Function: Initialize a new L<Bio::AlignIO::phylip> reader or writer
\& Returns : L<Bio::AlignIO> object
\& Args    : [specific for writing of phylip format files]
\&           -idlength => integer - length of the id (will pad w/
\&                                                    spaces if needed)
\&           -interleaved => boolean - whether or not write as interleaved
\&                                     or sequential format
\&           -line_length  => integer of how long a sequence lines should be
\&           -idlinebreak => insert a line break after the sequence id
\&                           so that sequence starts on the next line
\&           -flag_SI => whether or not write a "S" or "I" just after
\&                       the num.seq. and line len., in the first line
\&           -tag_length => integer of how long the tags have to be in
\&                         each line between the space separator. set it
\&                         to 0 to have 1 tag only.
\&           -wrap_sequential => boolean for whether or not sequential
\&                                   format should be broken up or a single line
\&                                   default is false (single line)
.Ve
.Sh "next_aln"
.IX Subsection "next_aln"
.Vb 7
\& Title   : next_aln
\& Usage   : $aln = $stream->next_aln()
\& Function: returns the next alignment in the stream.
\&           Throws an exception if trying to read in PHYLIP
\&           sequential format.
\& Returns : L<Bio::SimpleAlign> object
\& Args    :
.Ve
.Sh "write_aln"
.IX Subsection "write_aln"
.Vb 5
\& Title   : write_aln
\& Usage   : $stream->write_aln(@aln)
\& Function: writes the $aln object into the stream in MSF format
\& Returns : 1 for success and 0 for error
\& Args    : L<Bio::Align::AlignI> object
.Ve
.Sh "interleaved"
.IX Subsection "interleaved"
.Vb 5
\& Title   : interleaved
\& Usage   : my $interleaved = $obj->interleaved
\& Function: Get/Set Interleaved status
\& Returns : boolean
\& Args    : boolean
.Ve
.Sh "flag_SI"
.IX Subsection "flag_SI"
.Vb 7
\& Title   : flag_SI
\& Usage   : my $flag = $obj->flag_SI
\& Function: Get/Set if the Sequential/Interleaved flag has to be shown
\&           after the number of sequences and sequence length
\& Example :
\& Returns : boolean
\& Args    : boolean
.Ve
.Sh "idlength"
.IX Subsection "idlength"
.Vb 5
\& Title   : idlength
\& Usage   : my $idlength = $obj->idlength
\& Function: Get/Set value of id length
\& Returns : string
\& Args    : string
.Ve
.Sh "line_length"
.IX Subsection "line_length"
.Vb 5
\& Title   : line_length
\& Usage   : $obj->line_length($newval)
\& Function:
\& Returns : value of line_length
\& Args    : newvalue (optional)
.Ve
.Sh "tag_length"
.IX Subsection "tag_length"
.Vb 6
\& Title   : tag_length
\& Usage   : $obj->tag_length($newval)
\& Function:
\& Example : my $tag_length = $obj->tag_length
\& Returns : value of the length for each space-separated tag in a line
\& Args    : newvalue (optional) - set to zero to have one tag per line
.Ve
.Sh "id_linebreak"
.IX Subsection "id_linebreak"
.Vb 5
\& Title   : id_linebreak
\& Usage   : $obj->id_linebreak($newval)
\& Function:
\& Returns : value of id_linebreak
\& Args    : newvalue (optional)
.Ve
.Sh "wrap_sequential"
.IX Subsection "wrap_sequential"
.Vb 5
\& Title   : wrap_sequential
\& Usage   : $obj->wrap_sequential($newval)
\& Function:
\& Returns : value of wrap_sequential
\& Args    : newvalue (optional)
.Ve
