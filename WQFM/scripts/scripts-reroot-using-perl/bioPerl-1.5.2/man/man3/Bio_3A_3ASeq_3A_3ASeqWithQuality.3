.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Seq::SeqWithQuality 3"
.TH Bio::Seq::SeqWithQuality 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Seq::SeqWithQuality \- Bioperl object packaging a sequence with its quality
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&        use Bio::PrimarySeq;
\&        use Bio::Seq::PrimaryQual;
\&        use Bio::Seq::SeqWithQuality;
.Ve
.PP
.Vb 7
\&                # make from memory
\&        my $qual = Bio::Seq::SeqWithQuality->new
\&                ( -qual => '10 20 30 40 50 50 20 10',
\&                  -seq => 'ATCGATCG',
\&                  -id  => 'human_id',
\&                  -accession_number => 'AL000012',
\&                );
.Ve
.PP
.Vb 8
\&                # make from objects
\&                # first, make a PrimarySeq object
\&        my $seqobj = Bio::PrimarySeq->new
\&                ( -seq => 'atcgatcg',
\&                  -id  => 'GeneFragment-12',
\&                  -accession_number => 'X78121',
\&                  -alphabet => 'dna'
\&                );
.Ve
.PP
.Vb 7
\&                # now make a PrimaryQual object
\&        my $qualobj = Bio::Seq::PrimaryQual->new
\&                ( -qual => '10 20 30 40 50 50 20 10',
\&                  -id  => 'GeneFragment-12',
\&                  -accession_number => 'X78121',
\&                  -alphabet => 'dna'
\&                );
.Ve
.PP
.Vb 6
\&                # now make the SeqWithQuality object
\&        my $swqobj = Bio::Seq::SeqWithQuality->new
\&                ( -seq  => $seqobj,
\&                  -qual => $qualobj
\&                );
\&                # done!
.Ve
.PP
.Vb 5
\&        $swqobj->id(); # the id of the SeqWithQuality object
\&                        # may not match the the id of the sequence or
\&                        # of the quality (check the pod, luke)
\&        $swqobj->seq(); # the sequence of the SeqWithQuality object
\&        $swqobj->qual(); # the quality of the SeqWithQuality object
.Ve
.PP
.Vb 1
\&         # to get out parts of the sequence.
.Ve
.PP
.Vb 2
\&         print "Sequence ", $seqobj->id(), " with accession ",
\&                $seqobj->accession, " and desc ", $seqobj->desc, "\en";
.Ve
.PP
.Vb 1
\&         $string2 = $seqobj->subseq(1,40);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object stores base quality values together with the sequence string.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Chad Matsalla"
.IX Header "AUTHOR - Chad Matsalla"
Email bioinformatics@dieselwurks.com
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Jason Stajich, jason@bioperl.org
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.Sh "\fInew()\fP"
.IX Subsection "new()"
.Vb 32
\& Title   : new()
\& Usage   : $qual = Bio::Seq::SeqWithQuality ->new
\&                ( -qual => '10 20 30 40 50 50 20 10',
\&                  -seq => 'ATCGATCG',
\&                  -id  => 'human_id',
\&                  -accession_number => 'AL000012',
\&                  -trace_indices    => '0 5 10 15 20 25 30 35'
\&                );
\& Function: Returns a new Bio::Seq::SeqWithQual object from basic
\&           constructors.
\& Returns : a new Bio::Seq::PrimaryQual object
\& Notes   : Arguments:
\&        -qual can be a quality string (see Bio::Seq::PrimaryQual for more
\&        information on this) or a reference to a Bio::Seq::PrimaryQual
\&        object.
\&        -seq can be a sequence string (see Bio::PrimarySeq for more
\&        information on this) or a reference to a Bio::PrimaryQual object.
\&        -seq, -id, -accession_number, -primary_id, -desc, -id behave like
\&        this:
\&        1. if they are provided on construction of the
\&        Bio::Seq::SeqWithQuality they will be set as the descriptors for
\&        the object unless changed by one of the following mechanisms:
\&        a) $obj->set_common_descriptors() is used and both the -seq and
\&          the -qual object have the same descriptors. These common
\&          descriptors will then become the descriptors for the
\&          Bio::Seq::SeqWithQual object.
\&        b) the descriptors are manually set using the seq(), id(),
\&                desc(), or accession_number(), primary_id(),
\&        2. if no descriptors are provided, the new() constructor will see
\&                if the descriptor used in the PrimarySeq and in the
\&                PrimaryQual objects match. If they do, they will become
\&                the descriptors for the SeqWithQuality object.
.Ve
.PP
.Vb 5
\&        To eliminate ambiguity, I strongly suggest you set the
\&        descriptors manually on construction of the object. Really.
\&     -trace_indices : a space_delimited list of trace indices
\&         (where would the peaks be drawn if this list of qualities
\&          was to be plotted?)
.Ve
.Sh "\fI_common_id()\fP"
.IX Subsection "_common_id()"
.Vb 6
\& Title   : _common_id()
\& Usage   : $common_id = $self->_common_id();
\& Function: Compare the display_id of {qual_ref} and {seq_ref}.
\& Returns : Nothing if they don't match. If they do return
\&           {seq_ref}->display_id()
\& Args    : None.
.Ve
.Sh "\fI_common_display_id()\fP"
.IX Subsection "_common_display_id()"
.Vb 6
\& Title   : _common_id()
\& Usage   : $common_id = $self->_common_display_id();
\& Function: Compare the display_id of {qual_ref} and {seq_ref}.
\& Returns : Nothing if they don't match. If they do return
\&           {seq_ref}->display_id()
\& Args    : None.
.Ve
.Sh "\fI_common_accession_number()\fP"
.IX Subsection "_common_accession_number()"
.Vb 6
\& Title   : _common_accession_number()
\& Usage   : $common_id = $self->_common_accession_number();
\& Function: Compare the accession_number() of {qual_ref} and {seq_ref}.
\& Returns : Nothing if they don't match. If they do return
\&           {seq_ref}->accession_number()
\& Args    : None.
.Ve
.Sh "\fI_common_primary_id()\fP"
.IX Subsection "_common_primary_id()"
.Vb 6
\& Title   : _common_primary_id()
\& Usage   : $common_primard_id = $self->_common_primary_id();
\& Function: Compare the primary_id of {qual_ref} and {seq_ref}.
\& Returns : Nothing if they don't match. If they do return
\&           {seq_ref}->primary_id()
\& Args    : None.
.Ve
.Sh "\fI_common_desc()\fP"
.IX Subsection "_common_desc()"
.Vb 6
\& Title   : _common_desc()
\& Usage   : $common_desc = $self->_common_desc();
\& Function: Compare the desc of {qual_ref} and {seq_ref}.
\& Returns : Nothing if they don't match. If they do return
\&           {seq_ref}->desc()
\& Args    : None.
.Ve
.Sh "\fIset_common_descriptors()\fP"
.IX Subsection "set_common_descriptors()"
.Vb 8
\& Title   : set_common_descriptors()
\& Usage   : $self->set_common_descriptors();
\& Function: Compare the descriptors (id,accession_number,display_id,
\&        primary_id, desc) for the PrimarySeq and PrimaryQual objects
\&        within the SeqWithQuality object. If they match, make that
\&        descriptor the descriptor for the SeqWithQuality object.
\& Returns : Nothing.
\& Args    : None.
.Ve
.Sh "\fIalphabet()\fP"
.IX Subsection "alphabet()"
.Vb 5
\& Title   : alphabet();
\& Usage   : $molecule_type = $obj->alphabet();
\& Function: Get the molecule type from the PrimarySeq object.
\& Returns : What what PrimarySeq says the type of the sequence is.
\& Args    : None.
.Ve
.Sh "\fIdisplay_id()\fP"
.IX Subsection "display_id()"
.Vb 20
\& Title   : display_id()
\& Usage   : $id_string = $obj->display_id();
\& Function: Returns the display id, aka the common name of the Quality
\&        object.
\&        The semantics of this is that it is the most likely string to be
\&        used as an identifier of the quality sequence, and likely to have
\&        "human" readability.  The id is equivalent to the ID field of the
\&        GenBank/EMBL databanks and the id field of the Swissprot/sptrembl
\&        database. In fasta format, the >(\eS+) is presumed to be the id,
\&        though some people overload the id to embed other information.
\&        Bioperl does not use any embedded information in the ID field,
\&        and people are encouraged to use other mechanisms (accession
\&        field for example, or extending the sequence object) to solve
\&        this. Notice that $seq->id() maps to this function, mainly for
\&        legacy/convience issues.
\&        This method sets the display_id for the SeqWithQuality object.
\& Returns : A string
\& Args    : If a scalar is provided, it is set as the new display_id for
\&        the SeqWithQuality object.
\& Status  : Virtual
.Ve
.Sh "\fIaccession_number()\fP"
.IX Subsection "accession_number()"
.Vb 15
\& Title   : accession_number()
\& Usage   : $unique_biological_key = $obj->accession_number();
\& Function: Returns the unique biological id for a sequence, commonly
\&        called the accession_number. For sequences from established
\&        databases, the implementors should try to use the correct
\&        accession number. Notice that primary_id() provides the unique id
\&        for the implemetation, allowing multiple objects to have the same
\&        accession number in a particular implementation. For sequences
\&        with no accession number, this method should return "unknown".
\&        This method sets the accession_number for the SeqWithQuality
\&        object. 
\& Returns : A string (the value of accession_number)
\& Args    : If a scalar is provided, it is set as the new accession_number
\&        for the SeqWithQuality object.
\& Status  : Virtual
.Ve
.Sh "\fIprimary_id()\fP"
.IX Subsection "primary_id()"
.Vb 12
\& Title   : primary_id()
\& Usage   : $unique_implementation_key = $obj->primary_id();
\& Function: Returns the unique id for this object in this implementation.
\&        This allows implementations to manage their own object ids in a
\&        way the implementaiton can control clients can expect one id to
\&        map to one object. For sequences with no accession number, this
\&        method should return a stringified memory location.
\&        This method sets the primary_id for the SeqWithQuality
\&        object.
\& Returns : A string. (the value of primary_id)
\& Args    : If a scalar is provided, it is set as the new primary_id for
\&        the SeqWithQuality object.
.Ve
.Sh "\fIdesc()\fP"
.IX Subsection "desc()"
.Vb 7
\& Title   : desc()
\& Usage   : $qual->desc($newval); _or_ 
\&           $description = $qual->desc();
\& Function: Get/set description text for this SeqWithQuality object.
\& Returns : A string. (the value of desc)
\& Args    : If a scalar is provided, it is set as the new desc for the
\&        SeqWithQuality object.
.Ve
.Sh "\fIid()\fP"
.IX Subsection "id()"
.Vb 8
\& Title   : id()
\& Usage   : $id = $qual->id();
\& Function: Return the ID of the quality. This should normally be (and
\&        actually is in the implementation provided here) just a synonym
\&        for display_id().
\& Returns : A string. (the value of id)
\& Args    : If a scalar is provided, it is set as the new id for the
\&        SeqWithQuality object.
.Ve
.Sh "seq"
.IX Subsection "seq"
.Vb 16
\& Title   : seq()
\& Usage   : $string    = $obj->seq(); _or_
\&        $obj->seq("atctatcatca");
\& Function: Returns the sequence that is contained in the imbedded in the
\&        PrimarySeq object within the SeqWithQuality object
\& Returns : A scalar (the seq() value for the imbedded PrimarySeq object.)
\& Args    : If a scalar is provided, the SeqWithQuality object will
\&        attempt to set that as the sequence for the imbedded PrimarySeq
\&        object. Otherwise, the value of seq() for the PrimarySeq object
\&        is returned.
\& Notes   : This is probably not a good idea because you then should call
\&        length() to make sure that the sequence and quality are of the
\&        same length. Even then, how can you make sure that this sequence
\&        belongs with that quality? I provided this to give you rope to
\&        hang yourself with. Tie it to a strong device and use a good
\&        knot.
.Ve
.Sh "\fIqual()\fP"
.IX Subsection "qual()"
.Vb 16
\& Title   : qual()
\& Usage   : @quality_values  = @{$obj->qual()}; _or_
\&        $obj->qual("10 10 20 40 50");
\& Function: Returns the quality as imbedded in the PrimaryQual object
\&        within the SeqWithQuality object.
\& Returns : A reference to an array containing the quality values in the 
\&        PrimaryQual object.
\& Args    : If a scalar is provided, the SeqWithQuality object will
\&        attempt to set that as the quality for the imbedded PrimaryQual
\&        object. Otherwise, the value of qual() for the PrimaryQual
\&        object is returned.
\& Notes   : This is probably not a good idea because you then should call
\&        length() to make sure that the sequence and quality are of the
\&        same length. Even then, how can you make sure that this sequence
\&        belongs with that quality? I provided this to give you a strong
\&        board with which to flagellate yourself.
.Ve
.Sh "\fItrace_indices()\fP"
.IX Subsection "trace_indices()"
.Vb 16
\& Title   : trace_indices()
\& Usage   : @trace_indice_values  = @{$obj->trace_indices()}; _or_
\&        $obj->trace_indices("10 10 20 40 50");
\& Function: Returns the trace_indices as imbedded in the Primaryqual object
\&        within the SeqWithQualiity object.
\& Returns : A reference to an array containing the trace_indice values in the 
\&        PrimaryQual object.
\& Args    : If a scalar is provided, the SeqWithuQuality object will
\&        attempt to set that as the trace_indices for the imbedded PrimaryQual
\&        object. Otherwise, the value of trace_indices() for the PrimaryQual
\&        object is returned.
\& Notes   : This is probably not a good idea because you then should call
\&        length() to make sure that the sequence and trace_indices are of the
\&        same length. Even then, how can you make sure that this sequence
\&        belongs with that trace_indicex? I provided this to give you a strong
\&        board with which to flagellate yourself.
.Ve
.Sh "\fIlength()\fP"
.IX Subsection "length()"
.Vb 6
\& Title   : length()
\& Usage   : $length = $seqWqual->length();
\& Function: Get the length of the SeqWithQuality sequence/quality.
\& Returns : Returns the length of the sequence and quality if they are
\&        both the same. Returns "DIFFERENT" if they differ.
\& Args    : None.
.Ve
.Sh "qual_obj"
.IX Subsection "qual_obj"
.Vb 8
\& Title   : qual_obj($different_obj)
\& Usage   : $qualobj = $seqWqual->qual_obj(); _or_
\&        $qualobj = $seqWqual->qual_obj($ref_to_primaryqual_obj);
\& Function: Get the PrimaryQual object that is imbedded in the
\&        SeqWithQuality object or if a reference to a PrimaryQual object
\&        is provided, set this as the PrimaryQual object imbedded in the
\&        SeqWithQuality object.
\& Returns : A reference to a Bio::Seq::SeqWithQuality object.
.Ve
.Sh "seq_obj"
.IX Subsection "seq_obj"
.Vb 8
\& Title   : seq_obj()
\& Usage   : $seqobj = $seqWqual->qual_obj(); _or_
\&        $seqobj = $seqWqual->seq_obj($ref_to_primary_seq_obj);
\& Function: Get the PrimarySeq object that is imbedded in the
\&        SeqWithQuality object or if a reference to a PrimarySeq object is
\&        provided, set this as the PrimarySeq object imbedded in the
\&        SeqWithQuality object.
\& Returns : A reference to a Bio::PrimarySeq object.
.Ve
.Sh "_set_descriptors"
.IX Subsection "_set_descriptors"
.Vb 13
\& Title   : _set_descriptors()
\& Usage   : $seqWqual->_qual_obj($qual,$seq,$id,$acc,$pid,$desc,$given_id,
\&        $alphabet);
\& Function: Set the descriptors for the SeqWithQuality object. Try to
\&        match the descriptors in the PrimarySeq object and in the
\&        PrimaryQual object if descriptors were not provided with
\&        construction.
\& Returns : Nothing.
\& Args    : $qual,$seq,$id,$acc,$pid,$desc,$given_id,$alphabet as found
\&        in the new() method.
\& Notes   : Really only intended to be called by the new() method. If
\&        you want to invoke a similar function try
\&        set_common_descriptors().
.Ve
.Sh "subseq($start,$end)"
.IX Subsection "subseq($start,$end)"
.Vb 7
\& Title   : subseq($start,$end)
\& Usage   : $subsequence = $obj->subseq($start,$end);
\& Function: Returns the subseq from start to end, where the first base
\&           is 1 and the number is inclusive, ie 1-2 are the first two
\&           bases of the sequence.
\& Returns : A string.
\& Args    : Two positions.
.Ve
.Sh "baseat($position)"
.IX Subsection "baseat($position)"
.Vb 7
\& Title   : baseat($position)
\& Usage   : $base_at_position_6 = $obj->baseat("6");
\& Function: Returns a single base at the given position, where the first
\&        base is 1 and the number is inclusive, ie 1-2 are the first two
\&        bases of the sequence.
\& Returns : A scalar.
\& Args    : A position.
.Ve
.Sh "subqual($start,$end)"
.IX Subsection "subqual($start,$end)"
.Vb 8
\& Title   : subqual($start,$end)
\& Usage   : @qualities = @{$obj->subqual(10,20);
\& Function: returns the quality values from $start to $end, where the
\&        first value is 1 and the number is inclusive, ie 1-2 are the
\&        first two bases of the sequence. Start cannot be larger than
\&        end but can be equal.
\& Returns : A reference to an array.
\& Args    : a start position and an end position
.Ve
.Sh "qualat($position)"
.IX Subsection "qualat($position)"
.Vb 8
\& Title   : qualat($position)
\& Usage   : $quality = $obj->qualat(10);
\& Function: Return the quality value at the given location, where the
\&        first value is 1 and the number is inclusive, ie 1-2 are the
\&        first two bases of the sequence. Start cannot be larger than
\&        end but can be equal.
\& Returns : A scalar.
\& Args    : A position.
.Ve
.Sh "sub_trace_index($start,$end)"
.IX Subsection "sub_trace_index($start,$end)"
.Vb 8
\& Title   : sub_trace_index($start,$end)
\& Usage   : @trace_indices = @{$obj->sub_trace_index(10,20);
\& Function: returns the trace index values from $start to $end, where the
\&        first value is 1 and the number is inclusive, ie 1-2 are the
\&        first two bases of the sequence. Start cannot be larger than
\&        end but can be e_trace_index.
\& Returns : A reference to an array.
\& Args    : a start position and an end position
.Ve
.Sh "trace_index_at($position)"
.IX Subsection "trace_index_at($position)"
.Vb 8
\& Title   : trace_index_at($position)
\& Usage   : $trace_index = $obj->trace_index_at(10);
\& Function: Return the trace_index value at the given location, where the
\&        first value is 1 and the number is inclusive, ie 1-2 are the
\&        first two bases of the sequence. Start cannot be larger than
\&        end but can be etrace_index_.
\& Returns : A scalar.
\& Args    : A position.
.Ve
.Sh "\fIto_string()\fP"
.IX Subsection "to_string()"
.Vb 15
\& Title   : to_string()
\& Usage   : $quality = $obj->to_string();
\& Function: Return a textual representation of what the object contains.
\&        For this module, this function will return:
\&                qual
\&                seq
\&                display_id
\&                accession_number
\&                primary_id
\&                desc
\&                id
\&                length_sequence
\&                length_quality
\& Returns : A scalar.
\& Args    : None.
.Ve
