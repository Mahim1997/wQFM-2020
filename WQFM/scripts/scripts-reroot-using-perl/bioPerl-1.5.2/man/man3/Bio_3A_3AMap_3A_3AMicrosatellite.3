.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Map::Microsatellite 3"
.TH Bio::Map::Microsatellite 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Map::Microsatellite \- An object representing a Microsatellite marker.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 7
\&  $o_usat = new Bio::Map::Microsatellite
\&      (-name=>'Chad Super Marker 2',
\&       -sequence => 'gctgactgatcatatatatatatatatatatatatatatatcgcgatcgtga',
\&       -motif => 'at',
\&       -repeats => 15,
\&       -repeat_start_position => 11
\&       );
.Ve
.PP
.Vb 2
\&  $sequence_before_usat = $o_usat->get_leading_flank();
\&  $sequence_after_usat = $o_usat->get_trailing_flank();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object handles the notion of an Microsatellite. This microsatellite can
be placed on a (linear) Map or used on its own.  If this Microsatellites
will be used in a mapping context (it doesn't have to, you know) it can have
multiple positions in a map. For information about a Microsatellite's position
in a map one must query the associate PositionI object which is accessible
through the \fIposition()\fR method.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Chad Matsalla"
.IX Header "AUTHOR - Chad Matsalla"
Email bioinformatics1@dieselwurks.com
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Heikki Lehvaslaiho heikki-at-bioperl-dot-org
Lincoln Stein      lstein@cshl.org
Jason Stajich      jason@bioperl.org
Sendu Bala         bix@sendu.me.uk
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.Sh "new"
.IX Subsection "new"
.Vb 20
\& Title   : new
\& Usage   : $o_usat = 
\& Function: Builds a new Bio::Map::Microsatellite object
\& Returns : Bio::Map::Microsatellite
\& Args    :
\&        -name    => name of this microsatellite (optional, string,
\&                default 'Unknown microsatellite')
\&        -positions => position(s) for this marker in maps[optional],
\&                An array reference of tuples (array refs themselves)
\&                Each tuple conatins a Bio::Map::MapI-inherited object and a 
\&                Bio::Map::PositionI-inherited obj, no default)
\&        -sequence => the sequence of this microsatellite (optional,
\&                 scalar, no default)
\&        -motif => the repeat motif of this microsatellite (optional,
\&                 scalar, no default)
\&        -repeats => the number of motif repeats for this microsatellite
\&                (optional, scalar, no default)
\&        -repeat_start_position => the starting position of the
\&                microsatellite in this sequence. The first base of the
\&                sequence is position "1". (optional, scalar, no default)
.Ve
.PP
.Vb 5
\& Note    : Creating a Bio::Map::Microsatellite object with no position
\&        might be useful for microsatellite people wanting to embrace
\&        and extend this module. <raising hand> Me! Me! Me!
\&        - using repeat_start_position will trigger a mechinism to
\&        calculate a value for repeat_end_position.
.Ve
.Sh "motif"
.IX Subsection "motif"
.Vb 7
\& Title   : motif
\& Usage   : $o_usat->motif($new_motif);
\&               my $motif = $o_usat->motif();
\& Function: Get/Set the repeat motif for this Microsatellite.
\& Returns : A scalar representing the current repeat motif of this
\&               Microsatellite.
\& Args    : none to get, OR string to set
.Ve
.Sh "sequence"
.IX Subsection "sequence"
.Vb 7
\& Title   : sequence
\& Usage   : $o_usat->sequence($new_sequence);
\&               my $sequence = $o_usat->sequence();
\& Function: Get/Set the sequence for this Microsatellite.
\& Returns : A scalar representing the current sequence of this
\&               Microsatellite.
\& Args    : none to get, OR string to set
.Ve
.Sh "repeats"
.IX Subsection "repeats"
.Vb 7
\& Title   : repeats
\& Usage   : $o_usat->repeats($new_repeats);
\&               my $repeats = $o_usat->repeats()
\& Function: Get/Set the repeat repeats for this Microsatellite.
\& Returns : A scalar representing the current number of repeats of this
\&               Microsatellite.
\& Args    : none to get, OR int to set
.Ve
.Sh "repeat_start_position"
.IX Subsection "repeat_start_position"
.Vb 12
\& Title   : repeat_start_position
\& Usage   : $o_usat->repeat_start_position($new_repeat_start_position);
\&               my $repeat_start_position = $o_usat->repeat_start_position();
\& Function: Get/Set the repeat repeat_start_position for this
\&               Microsatellite
\& Returns : A scalar representing the repeat start position for this 
\&               Microsatellite.
\& Args    : none to get, OR string to set
\&               This method will also try to set the repeat end position. This
\&               depends on having information for the motif and the number of
\&               repeats. If you want to use methods like get_trailing_flank or
\&               get_leading flank, be careful to include the right information.
.Ve
.Sh "repeat_end_position"
.IX Subsection "repeat_end_position"
.Vb 19
\& Title   : repeat_end_position
\& Usage   : $o_usat->repeat_end_position("set");
\&               $o_usat->repeat_end_position($value);
\&               $current_repeat_end_position = $o_usat->repeat_end_position();
\& Function: Get/set the end position of the repeat in this sequence.
\& Returns : A scalar representing the base index of the end of the
\&               repeat in this Microsatellite. The first base in the sequence
\&               is base 1.
\& Args    : A scalar representing a value, the string "set", or no
\&               argument (see Notes).
\& Notes   : If you do not provide an argument to this method, the current
\&           end position of the repeat in this Microsatellite will be
\&           returned (a scalar).
\&           If you provide the string "set" to this method it will set the
\&           end position based on the start position, the length of the
\&           motif, and the number of repeats.
\&           If you specify a value the current end position of the repeat
\&           will be set to that value. This is a really bad idea. Don't do
\&           it.
.Ve
.Sh "equals"
.IX Subsection "equals"
.Vb 5
\& Title   : equals
\& Usage   : if ($mappable->equals($mapable2)) {...}
\& Function: Test if a position is equal to another position
\& Returns : boolean
\& Args    : Bio::Map::MappableI
.Ve
.Sh "less_than"
.IX Subsection "less_than"
.Vb 5
\& Title   : less_than
\& Usage   : if ($mappable->less_than($m2)) {...}
\& Function: Tests if a position is less than another position
\& Returns : boolean
\& Args    : Bio::Map::MappableI
.Ve
.Sh "greater_than"
.IX Subsection "greater_than"
.Vb 5
\& Title   : greater_than
\& Usage   : if ($mappable->greater_than($m2)) {...}
\& Function: Tests if position is greater than another position
\& Returns : boolean
\& Args    : Bio::Map::MappableI
.Ve
.Sh "get_leading_flank"
.IX Subsection "get_leading_flank"
.Vb 5
\& Title   : get_leading_flank
\& Usage   : $leading_sequence = $o_usat->get_leading_flank();
\& Returns : A scalar representing the sequence before the repeats in this
\&               Microsatellite.
\& Args    : none
.Ve
.Sh "get_trailing_flank"
.IX Subsection "get_trailing_flank"
.Vb 5
\& Title   : get_trailing_flank
\& Usage   : $trailing_flank = $o_usat->get_trailing_flank();
\& Returns : A scalar representing the sequence after the repeats in this
\&               Microsatellite.
\& Args    : none
.Ve
