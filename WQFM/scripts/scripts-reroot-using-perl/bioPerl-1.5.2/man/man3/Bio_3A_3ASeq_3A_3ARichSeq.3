.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Seq::RichSeq 3"
.TH Bio::Seq::RichSeq 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Seq::RichSeq \- Module implementing a sequence created from a rich
sequence database entry
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Bio::Seq::RichSeqI and documentation of methods.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements Bio::Seq::RichSeqI, an interface for sequences
created from or created for entries from/of rich sequence databanks,
like \s-1EMBL\s0, GenBank, and SwissProt. Methods added to the Bio::SeqI
interface therefore focus on databank-specific information. Note that
not every rich databank format may use all of the properties provided.
.SH "Implemented Interfaces"
.IX Header "Implemented Interfaces"
This class implementes the following interfaces.
.IP "Bio::Seq::RichSeqI" 4
.IX Item "Bio::Seq::RichSeqI"
Note that this includes implementing Bio::PrimarySeqI and Bio::SeqI.
.IP "Bio::IdentifiableI" 4
.IX Item "Bio::IdentifiableI"
.PD 0
.IP "Bio::DescribableI" 4
.IX Item "Bio::DescribableI"
.IP "Bio::AnnotatableI" 4
.IX Item "Bio::AnnotatableI"
.PD
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this
and other Bioperl modules. Send your comments and suggestions preferably
 to one of the Bioperl mailing lists.
Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Ewan Birney"
.IX Header "AUTHOR - Ewan Birney"
Email birney@ebi.ac.uk
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.Sh "new"
.IX Subsection "new"
.Vb 5
\& Title   : new
\& Usage   : $seq    = Bio::Seq::RichSeq->new( -seq => 'ATGGGGGTGGTGGTACCCT',
\&                                             -id  => 'human_id',
\&                                             -accession_number => 'AL000012',
\&                                            );
.Ve
.PP
.Vb 4
\& Function: Returns a new seq object from
\&           basic constructors, being a string for the sequence
\&           and strings for id and accession_number
\& Returns : a new Bio::Seq::RichSeq object
.Ve
.Sh "division"
.IX Subsection "division"
.Vb 5
\& Title   : division
\& Usage   : $obj->division($newval)
\& Function: 
\& Returns : value of division
\& Args    : newvalue (optional)
.Ve
.Sh "molecule"
.IX Subsection "molecule"
.Vb 5
\& Title   : molecule
\& Usage   : $obj->molecule($newval)
\& Function: 
\& Returns : type of molecule (DNA, mRNA)
\& Args    : newvalue (optional)
.Ve
.Sh "add_date"
.IX Subsection "add_date"
.Vb 3
\& Title   : add_date
\& Usage   : $self->add_date($datestr)
\& Function: adds one or more dates
.Ve
.PP
.Vb 3
\&           This implementation stores dates as keyed annotation, the
\&           key being 'date_changed'. You can take advantage of this
\&           fact when accessing the annotation collection directly.
.Ve
.PP
.Vb 3
\& Example :
\& Returns : 
\& Args    : a date string or an array of such strings
.Ve
.Sh "get_dates"
.IX Subsection "get_dates"
.Vb 6
\& Title   : get_dates
\& Usage   : my @dates = $seq->get_dates;
\& Function: Get the dates of the sequence (usually, when it was created and
\&           changed.
\& Returns : an array of date strings
\& Args    :
.Ve
.Sh "pid"
.IX Subsection "pid"
.Vb 6
\& Title   : pid
\& Usage   : my $pid = $seq->pid();
\& Function: Get (and set, depending on the implementation) the PID property
\&           for the sequence.
\& Returns : a string
\& Args    :
.Ve
.Sh "accession"
.IX Subsection "accession"
.Vb 4
\& Title   : accession
\& Usage   : $obj->accession($newval)
\& Function: Whilst the underlying sequence object does not 
\&           have an accession, so we need one here.
.Ve
.PP
.Vb 5
\&           In this implementation this is merely a synonym for
\&           accession_number().
\& Example : 
\& Returns : value of accession
\& Args    : newvalue (optional)
.Ve
.Sh "add_secondary_accession"
.IX Subsection "add_secondary_accession"
.Vb 3
\& Title   : add_secondary_accession
\& Usage   : $self->add_domment($ref)
\& Function: adds a secondary_accession
.Ve
.PP
.Vb 4
\&           This implementation stores secondary accession numbers as
\&           keyed annotation, the key being 'secondary_accession'. You
\&           can take advantage of this fact when accessing the
\&           annotation collection directly.
.Ve
.PP
.Vb 3
\& Example :
\& Returns : 
\& Args    : a string or an array of strings
.Ve
.Sh "get_secondary_accessions"
.IX Subsection "get_secondary_accessions"
.Vb 5
\& Title   : get_secondary_accessions
\& Usage   : my @acc = $seq->get_secondary_accessions();
\& Function: Get the secondary accession numbers as strings.
\& Returns : An array of strings
\& Args    : none
.Ve
.Sh "seq_version"
.IX Subsection "seq_version"
.Vb 5
\& Title   : seq_version
\& Usage   : $obj->seq_version($newval)
\& Function: Get/set the sequence version
\& Returns : value of seq_version (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.Sh "add_keyword"
.IX Subsection "add_keyword"
.Vb 3
\& Title   : add_keyword
\& Usage   : $obj->add_keyword($newval)
\& Function: Add a new keyword to the annotation of the sequence.
.Ve
.PP
.Vb 3
\&           This implementation stores keywords as keyed annotation,
\&           the key being 'keyword'. You can take advantage of this
\&           fact when accessing the annotation collection directly.
.Ve
.PP
.Vb 2
\& Returns : 
\& Args    : value to be added (optional) (a string)
.Ve
.Sh "get_keywords"
.IX Subsection "get_keywords"
.Vb 5
\& Title   : get_keywords
\& Usage   : $obj->get_keywords($newval)
\& Function: Get the keywords for this sequence as an array of strings.
\& Returns : an array of strings
\& Args    :
.Ve
.SH "Private methods and synonyms for backward compatibility"
.IX Header "Private methods and synonyms for backward compatibility"
.Sh "_add_annotation_value"
.IX Subsection "_add_annotation_value"
.Vb 6
\& Title   : _add_annotation_value
\& Usage   :
\& Function: Adds a value to the annotation collection under the specified
\&           key. Note that this is not a public method.
\& Returns : 
\& Args    : key (a string), value(s) (one or more scalars)
.Ve
.Sh "_get_annotation_values"
.IX Subsection "_get_annotation_values"
.Vb 8
\& Title   : _get_annotation_values
\& Usage   :
\& Function: Gets the values of a specific annotation as identified by the
\&           key from the annotation collection. Note that this is not a
\&           public method.
\& Example :
\& Returns : an array of strings
\& Args    : the key (a string)
.Ve
