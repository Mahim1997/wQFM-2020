.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Map::Mappable 3"
.TH Bio::Map::Mappable 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Map::Mappable \- An object representing a generic map element
that can have multiple locations in several maps.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  # a map element in two different positions on the same map
\&  $map1 = new Bio::Map::SimpleMap ();
\&  $position1 = new Bio::Map::Position (-map => $map1, -value => 100);
\&  $position2 = new Bio::Map::Position (-map => $map1, -value => 200);
\&  $mappable = new Bio::Map::Mappable (-positions => [$position1, $position2] );
.Ve
.PP
.Vb 4
\&  # add another position on a different map
\&  $map2 = new Bio::Map::SimpleMap ();
\&  $position3 = new Bio::Map::Position (-map => $map2, $value => 50);
\&  $mappable->add_position($position3);
.Ve
.PP
.Vb 4
\&  # get all the places our map element is found, on a particular map of interest
\&  foreach $pos ($mappable->get_positions($map1)) {
\&     print $pos->value, "\en";
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object handles the notion of a generic map element. Mappables are
entities with one or more positions on one or more maps.
.PP
This object is a pure perl implementation of Bio::Map::MappableI. That
interface implements some of its own methods so check the docs there for
those.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to the
Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Sendu Bala"
.IX Header "AUTHOR - Sendu Bala"
Email bix@sendu.me.uk
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.Sh "new"
.IX Subsection "new"
.Vb 6
\& Title   : new
\& Usage   : my $mappable = new Bio::Map::Mappable();
\& Function: Builds a new Bio::Map::Mappable object
\& Returns : Bio::Map::Mappable
\& Args    : -name => string : name of the mappable element
\&           -id   => string : id of the mappable element
.Ve
.Sh "name"
.IX Subsection "name"
.Vb 7
\& Title   : name
\& Usage   : $mappable->name($new_name);
\&               my $name = $mappable->name();
\& Function: Get/Set the name for this Mappable
\& Returns : A scalar representing the current name of this Mappable
\& Args    : none to get
\&           string to set
.Ve
.Sh "id"
.IX Subsection "id"
.Vb 7
\& Title   : id
\& Usage   : my $id = $mappable->id();
\&           $mappable->id($new_id);
\& Function: Get/Set the id for this Mappable.
\& Returns : A scalar representing the current id of this Mappable
\& Args    : none to get
\&           string to set
.Ve
.Sh "in_map"
.IX Subsection "in_map"
.Vb 5
\& Title   : in_map
\& Usage   : if ($mappable->in_map($map)) {...}
\& Function: Tests if this mappable is found on a specific map
\& Returns : boolean
\& Args    : L<Bio::Map::MapI>
.Ve
.Sh "Comparison methods"
.IX Subsection "Comparison methods"
.Sh "equals"
.IX Subsection "equals"
.Vb 14
\& Title   : equals
\& Usage   : if ($mappable->equals($other_mappable)) {...}
\&           my @equal_positions = $mappable->equals($other_mappable);
\& Function: Finds the positions in this mappable that are equal to any
\&           comparison positions.
\& Returns : array of L<Bio::Map::PositionI> objects
\& Args    : arg #1 = L<Bio::Map::MappableI> OR L<Bio::Map::PositionI> to compare
\&                    this one to (mandatory)
\&           arg #2 = optionally, one or more of the key => value pairs below
\&                   -map => MapI           : a Bio::Map::MapI to only consider positions
\&                                            on the given map
\&                   -relative => RelativeI : a Bio::Map::RelativeI to calculate in terms
\&                                    of each Position's relative position to the
\&                                    thing described by that Relative
.Ve
.Sh "less_than"
.IX Subsection "less_than"
.Vb 14
\& Title   : less_than
\& Usage   : if ($mappable->less_than($other_mappable)) {...}
\&           my @lesser_positions = $mappable->less_than($other_mappable);
\& Function: Finds the positions in this mappable that are less than all
\&           comparison positions.
\& Returns : array of L<Bio::Map::PositionI> objects
\& Args    : arg #1 = L<Bio::Map::MappableI> OR L<Bio::Map::PositionI> to compare
\&                    this one to (mandatory)
\&           arg #2 = optionally, one or more of the key => value pairs below
\&                   -map => MapI           : a Bio::Map::MapI to only consider positions
\&                                            on the given map
\&                   -relative => RelativeI : a Bio::Map::RelativeI to calculate in terms
\&                                    of each Position's relative position to the
\&                                    thing described by that Relative
.Ve
.Sh "greater_than"
.IX Subsection "greater_than"
.Vb 14
\& Title   : greater_than
\& Usage   : if ($mappable->greater_than($other_mappable)) {...}
\&           my @greater_positions = $mappable->greater_than($other_mappable);
\& Function: Finds the positions in this mappable that are greater than all
\&           comparison positions.
\& Returns : array of L<Bio::Map::PositionI> objects
\& Args    : arg #1 = L<Bio::Map::MappableI> OR L<Bio::Map::PositionI> to compare
\&                    this one to (mandatory)
\&           arg #2 = optionally, one or more of the key => value pairs below
\&                   -map => MapI           : a Bio::Map::MapI to only consider positions
\&                                            on the given map
\&                   -relative => RelativeI : a Bio::Map::RelativeI to calculate in terms
\&                                    of each Position's relative position to the
\&                                    thing described by that Relative
.Ve
.Sh "overlaps"
.IX Subsection "overlaps"
.Vb 14
\& Title   : overlaps
\& Usage   : if ($mappable->overlaps($other_mappable)) {...}
\&           my @overlapping_positions = $mappable->overlaps($other_mappable);
\& Function: Finds the positions in this mappable that overlap with any
\&           comparison positions.
\& Returns : array of L<Bio::Map::PositionI> objects
\& Args    : arg #1 = L<Bio::Map::MappableI> OR L<Bio::Map::PositionI> to compare
\&                    this one to (mandatory)
\&           arg #2 = optionally, one or more of the key => value pairs below
\&                   -map => MapI           : a Bio::Map::MapI to only consider positions
\&                                            on the given map
\&                   -relative => RelativeI : a Bio::Map::RelativeI to calculate in terms
\&                                    of each Position's relative position to the
\&                                    thing described by that Relative
.Ve
.Sh "contains"
.IX Subsection "contains"
.Vb 14
\& Title   : contains
\& Usage   : if ($mappable->contains($other_mappable)) {...}
\&           my @container_positions = $mappable->contains($other_mappable);
\& Function: Finds the positions in this mappable that contain any comparison
\&           positions.
\& Returns : array of L<Bio::Map::PositionI> objects
\& Args    : arg #1 = L<Bio::Map::MappableI> OR L<Bio::Map::PositionI> to compare
\&                    this one to (mandatory)
\&           arg #2 = optionally, one or more of the key => value pairs below
\&                   -map => MapI           : a Bio::Map::MapI to only consider positions
\&                                            on the given map
\&                   -relative => RelativeI : a Bio::Map::RelativeI to calculate in terms
\&                                    of each Position's relative position to the
\&                                    thing described by that Relative
.Ve
.Sh "overlapping_groups"
.IX Subsection "overlapping_groups"
.Vb 40
\& Title   : overlapping_groups
\& Usage   : my @groups = $mappable->overlapping_groups($other_mappable);
\&           my @groups = Bio::Map::Mappable->overlapping_groups(\e@mappables);
\& Function: Look at all the positions of all the supplied mappables and group
\&           them according to overlap.
\& Returns : array of array refs, each ref containing the Bio::Map::PositionI
\&           objects that overlap with each other
\& Args    : arg #1 = L<Bio::Map::MappableI> OR L<Bio::Map::PositionI> to  compare
\&                    this one to, or an array ref of such objects (mandatory)
\&           arg #2 = optionally, one or more of the key => value pairs below
\&                   -map => MapI           : a Bio::Map::MapI to only consider positions
\&                                            on the given map
\&                   -relative => RelativeI : a Bio::Map::RelativeI to calculate in terms
\&                                    of each Position's relative position to the
\&                                    thing described by that Relative
\&           -min_pos_num => int    : the minimum number of positions that must
\&                                    be in a group before it will be returned
\&                                    [default is 1]
\&           -min_mappables_num => int        : the minimum number of different
\&                                              mappables represented by the
\&                                              positions in a group before it
\&                                              will be returned [default is 1]
\&           -min_mappables_percent => number : as above, but the minimum
\&                                              percentage of input mappables
\&                                              [default is 0]
\&           -min_map_num => int              : the minimum number of different
\&                                              maps represented by the positions
\&                                              in a group before it will be
\&                                              returned [default is 1]
\&           -min_map_percent => number       : as above, but the minimum
\&                                              percentage of maps known by the
\&                                              input mappables [default is 0]
\&           -require_self => 1|0             : require that at least one of the
\&                                              calling object's positions be in
\&                                              each group [default is 1, has no
\&                                              effect when the second usage form
\&                                              is used]
\&           -required => \e@mappables         : require that at least one position
\&                                              for each mappable supplied in this
\&                                              array ref be in each group
.Ve
.Sh "disconnected_intersections"
.IX Subsection "disconnected_intersections"
.Vb 43
\& Title   : disconnected_intersections
\& Usage   : @positions = $mappable->disconnected_intersections($other_mappable);
\&           @positions = Bio::Map::Mappable->disconnected_intersections(\e@mappables);
\& Function: Make the positions that are at the intersection of each group of
\&           overlapping positions, considering all the positions of the supplied
\&           mappables.
\& Returns : new Bio::Map::Mappable who's positions on maps are the calculated
\&           disconnected unions
\& Args    : arg #1 = L<Bio::Map::MappableI> OR L<Bio::Map::PositionI> to  compare
\&                    this one to, or an array ref of such objects (mandatory)
\&           arg #2 = optionally, one or more of the key => value pairs below
\&                   -map => MapI           : a Bio::Map::MapI to only consider positions
\&                                            on the given map
\&                   -relative => RelativeI : a Bio::Map::RelativeI to calculate in terms
\&                                    of each Position's relative position to the
\&                                    thing described by that Relative
\&           -min_pos_num => int    : the minimum number of positions that must
\&                                    be in a group before the intersection will
\&                                    be calculated and returned [default is 1]
\&           -min_mappables_num => int        : the minimum number of different
\&                                              mappables represented by the
\&                                              positions in a group before the
\&                                              intersection will be calculated
\&                                              and returned [default is 1]
\&           -min_mappables_percent => number : as above, but the minimum
\&                                              percentage of input mappables
\&                                              [default is 0]
\&           -min_map_num => int              : the minimum number of different
\&                                              maps represented by the positions
\&                                              in a group before the intersection
\&                                              will be calculated and returned
\&                                              [default is 1]
\&           -min_map_percent => number       : as above, but the minimum
\&                                              percentage of maps known by the
\&                                              input mappables [default is 0]
\&           -require_self => 1|0             : require that at least one of the
\&                                              calling object's positions be in
\&                                              each group [default is 1, has no
\&                                              effect when the second usage form
\&                                              is used]
\&           -required => \e@mappables         : require that at least one position
\&                                              for each mappable supplied in this
\&                                              array ref be in each group
.Ve
.Sh "disconnected_unions"
.IX Subsection "disconnected_unions"
.Vb 42
\& Title   : disconnected_unions
\& Usage   : my @positions = $mappable->disconnected_unions($other_mappable);
\&           my @positions = Bio::Map::Mappable->disconnected_unions(\e@mappables);
\& Function: Make the positions that are the union of each group of overlapping
\&           positions, considering all the positions of the supplied mappables.
\& Returns : new Bio::Map::Mappable who's positions on maps are the calculated
\&           disconnected unions
\& Args    : arg #1 = L<Bio::Map::MappableI> OR L<Bio::Map::PositionI> to  compare
\&                    this one to, or an array ref of such objects (mandatory)
\&           arg #2 = optionally, one or more of the key => value pairs below
\&                   -map => MapI           : a Bio::Map::MapI to only consider positions
\&                                            on the given map
\&                   -relative => RelativeI : a Bio::Map::RelativeI to calculate in terms
\&                                    of each Position's relative position to the
\&                                    thing described by that Relative
\&           -min_pos_num => int    : the minimum number of positions that must
\&                                    be in a group before the union will be
\&                                    calculated and returned [default is 1]
\&           -min_mappables_num => int        : the minimum number of different
\&                                              mappables represented by the
\&                                              positions in a group before the
\&                                              union will be calculated and
\&                                              returned [default is 1]
\&           -min_mappables_percent => number : as above, but the minimum
\&                                              percentage of input mappables
\&                                              [default is 0]
\&           -min_map_num => int              : the minimum number of different
\&                                              maps represented by the positions
\&                                              in a group before the union will
\&                                              be calculated and returned
\&                                              [default is 1]
\&           -min_map_percent => number       : as above, but the minimum
\&                                              percentage of maps known by the
\&                                              input mappables [default is 0]
\&           -require_self => 1|0             : require that at least one of the
\&                                              calling object's positions be in
\&                                              each group [default is 1, has no
\&                                              effect when the second usage form
\&                                              is used]
\&           -required => \e@mappables         : require that at least one position
\&                                              for each mappable supplied in this
\&                                              array ref be in each group
.Ve
.Sh "tuple"
.IX Subsection "tuple"
.Vb 7
\& Title   : tuple
\& Usage   : Do Not Use!
\& Function: tuple was supposed to be a private method; this method no longer
\&           does anything
\& Returns : warning
\& Args    : none
\& Status  : deprecated, will be removed in next version
.Ve
.Sh "annotation"
.IX Subsection "annotation"
.Vb 8
\& Title   : annotation
\& Usage   : $mappable->annotation($an_col);
\&           my $an_col = $mappable->annotation();
\& Function: Get the annotation collection (see Bio::AnnotationCollectionI)
\&           for this annotatable object.
\& Returns : a Bio::AnnotationCollectionI implementing object, or undef
\& Args    : none to get, OR
\&           a Bio::AnnotationCollectionI implementing object to set
.Ve
