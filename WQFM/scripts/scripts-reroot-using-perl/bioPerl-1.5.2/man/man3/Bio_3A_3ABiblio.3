.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Biblio 3"
.TH Bio::Biblio 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Biblio \- A Bibliographic Query Service module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Bio::Biblio;
\&  my $biblio = new Bio::Biblio;
.Ve
.PP
.Vb 1
\&  print $biblio->find ('perl')->get_count . "\en";
.Ve
.PP
.Vb 4
\&  my $collection = $biblio->find ('brazma', 'authors');
\&  while ( $collection->has_next ) {
\&      print $collection->get_next;
\&  }
.Ve
.PP
.Vb 1
\&  # The new() method can accept parameters, for example:
.Ve
.PP
.Vb 4
\&  $biblio = Bio::Biblio
\&    (-access          => 'soap',
\&     -location        => 'http://www.ebi.ac.uk/openbqs/services/MedlineSRS',
\&     -destroy_on_exit => '0');
.Ve
.PP
.Vb 1
\&  # See below for some one-liners
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a class whose instances can access bibliographic
repositories. It allows to query a bibliographic database (such as
\&\s-1MEDLINE\s0) and then to retrieve resulting citations from it. The
citations are returned in an \s-1XML\s0 format which is native to the
repository but there are also supporting modules for converting them
into Perl objects.
.PP
The detailed descriptions of all query and retrieval methods are in
Bio::DB::BiblioI (an interface). All those methods should be
called on instances of this (Bio::Biblio) module.
.PP
The module complies (with some simplifications) with the specification
described in the \fBOpenBQS\fR project. Its home page is at
<http://www.ebi.ac.uk/~senger/openbqs>.
.PP
The module also gives an access to a set of controlled vocabularies
and their values. It allows to introspect bibliographic repositories
and to find what citation resource types (such as journal and book
articles, patents or technical reports) are provided, and what
attributes they have, eventually what attribute values are allowed.
.PP
Here are some one\-liners:
.PP
.Vb 5
\&  perl -MBio::Biblio -e 'print new Bio::Biblio->get_by_id ("12368254")'
\&  perl -MBio::Biblio \e
\&       -e 'print join ("\en", @{ new Bio::Biblio->find ("brazma")->get_all_ids })'
\&  perl -MBio::Biblio \e
\&       -e 'print new Bio::Biblio->find ("Java")->find ("perl")->get_count'
.Ve
.SH "OVERVIEW OF CLASSES AND PACKAGES"
.IX Header "OVERVIEW OF CLASSES AND PACKAGES"
.IP "Bio::Biblio" 4
.IX Item "Bio::Biblio"
This is the main class to be used by the end users. It
loads a real implementation for a particular access protocol according
to the argument \fI\-access\fR. At the time of writing this documentation
there is only one available access module implementing all query and
retrieval methods:
.Sp
.Vb 1
\&   -access => soap
.Ve
.Sp
This module implements all methods defined in the interface
\&\fIBio::DB::BiblioI\fR (see Bio::DB::BiblioI) by delegating
calls to a loaded low-level module (e.g. see
Bio::DB::Biblio::soap).
.Sp
Note that there are other modules which do not use the \s-1SOAP\s0 protocol 
and do not implement all query methods \- nevertheless they have retrieval 
methods and can be used in the same way:
.Sp
.Vb 1
\&   -access => biofetch
.Ve
.Sp
Lacking documentation:
.Sp
.Vb 1
\&   -access => eutils
.Ve
.IP "Bio::DB::BiblioI" 4
.IX Item "Bio::DB::BiblioI"
This is an interface defining all methods that can be called on
\&\fIBio::Biblio\fR instances.
.IP "Bio::DB::Biblio::soap" 4
.IX Item "Bio::DB::Biblio::soap"
This is a real implementation of all methods defined in
Bio::DB::BiblioI using \s-1SOAP\s0 protocol (calling a WebService
based on \s-1SOAP\s0). This class should not be instantiated directly (use
\&\fIBio::Biblio\fR instead). See Bio::DB::BiblioI for details.
.IP "Bio::Biblio::IO" 4
.IX Item "Bio::Biblio::IO"
This module instantiates and uses a converter of the citations read by
any of the access methods mentioned above. See Bio::Biblio::IO for
details.
.IP "Bio::Biblio::IO::medlinexml and Bio::Biblio::IO::medline2ref" 4
.IX Item "Bio::Biblio::IO::medlinexml and Bio::Biblio::IO::medline2ref"
A converter of \s-1MEDLINE\s0 citations in \s-1XML\s0 into Perl objects.
.IP "Bio::Biblio::IO::pubmedxml and Bio::Biblio::IO::pubmed2ref" 4
.IX Item "Bio::Biblio::IO::pubmedxml and Bio::Biblio::IO::pubmed2ref"
A converter of \s-1PUBMED\s0 citations in \s-1XML\s0 into Perl objects.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to
the Bioperl mailing list.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
of the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Martin Senger (martin.senger@gmail.com)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002 European Bioinformatics Institute. All Rights Reserved.
.PP
This module is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This software is provided \*(L"as is\*(R" without warranty of any kind.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
OpenBQS home page: http://www.ebi.ac.uk/~senger/openbqs/
.IP "\(bu" 4
Comments to the Perl client: http://www.ebi.ac.uk/~senger/openbqs/Client_perl.html
.SH "APPENDIX"
.IX Header "APPENDIX"
The main documentation details are to be found in
Bio::DB::BiblioI.
.PP
Here is the rest of the object methods.  Internal methods are preceded
with an underscore _.
.Sh "new"
.IX Subsection "new"
.Vb 3
\& Usage   : my $obj = new Bio::Biblio (@args);
\& Returns : Bio::Biblio object on success, or undef on failure
\& Args    : This module recognizes and uses:
.Ve
.PP
.Vb 3
\&             -access => 'soap'
\&               It indicates what lower-level module to load.
\&               Default is 'soap'.
.Ve
.PP
.Vb 4
\&             -location => 'http://...'
\&                It says where to find a bibliographic query service.
\&                The format and contents of this argument is dependent
\&                on the '-access' argument.
.Ve
.PP
.Vb 2
\&                For 'soap' access it is a URL of a WebService.
\&                Default is http://www.ebi.ac.uk/openbqs/services/MedlineSRS
.Ve
.PP
.Vb 3
\&           Other arguments can be given here but they are
\&           recognized by the lower-level module
\&           (e.g. see Bio::DB::Biblio::soap).
.Ve
.PP
It builds, populates and returns a new \fIBio::Biblio\fR object. This is
how it is seen from the outside. But in fact, it builds, populates and
returns a more specific lower-level object, for example
\&\fIBio::DB::Biblio::soap\fR object \- which one it is depends on the
parameter \fI\-access\fR.
.PP
The real initialization is done in the method \fI_initialize\fR of the
lower-level object.
.PP
This method can also be used for \fIcloning\fR an existing object and
changing or adding new attributes to it in the same time. This is,
however, not particulary useful for the casual users of this module,
because the query methods (see Bio::DB::BiblioI) themselves
already return cloned objects with more refined query
collections. Anyway this is how the cloning can be done:
.PP
.Vb 2
\&  use Bio::Biblio;
\&  my $biblio = new Bio::Biblio;
.Ve
.PP
.Vb 3
\&  # this will create a new object which will NOT send a 'destroy'
\&  # message to the remote server when its life ends
\&  my $clone = $biblio->new (-destroy-on-exit => '0');
.Ve
.Sh "_load_access_module"
.IX Subsection "_load_access_module"
.Vb 4
\& Usage   : $class->_load_access_module ($access)
\& Returns : 1 on success, undef on failure
\& Args    : 'access' should contain the last part of the
\&           name of a module who does the real implementation
.Ve
.PP
It does (in run\-time) a similar thing as
.PP
.Vb 1
\&   require Bio::DB::Biblio::$access
.Ve
.PP
It prints an error on \s-1STDERR\s0 if it fails to find and load the module
(for example, because of the compilation errors in the module).
.Sh "_guess_access"
.IX Subsection "_guess_access"
.Vb 5
\& Usage   : $class->_guess_access ($location)
\& Returns : string with a guessed access protocol (e.g. 'soap')
\& Args    : 'location' defines where to find a bibliographic service
\&           in a protocol-dependent manner (e.g. for SOAP it is
\&           a URL of a bibliographic WebService)
.Ve
.PP
It makes an expert guess what kind of access/transport protocol should
be used based on the \fIlocation\fR of the service (e.g. if the
\&\fIlocation\fR looks like an \s-1IOR\s0 then the access protocol is probably
\&\s-1CORBA\s0).
.Sh "\s-1VERSION\s0 and Revision"
.IX Subsection "VERSION and Revision"
.Vb 2
\& Usage   : print $Bio::Biblio::VERSION;
\&           print $Bio::Biblio::Revision;
.Ve
