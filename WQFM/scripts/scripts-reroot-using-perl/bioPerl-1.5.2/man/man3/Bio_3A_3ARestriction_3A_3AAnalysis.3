.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Restriction::Analysis 3"
.TH Bio::Restriction::Analysis 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Restriction::Analysis \- cutting sequences with restriction
enzymes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  # analyze a DNA sequence for restriction enzymes
\&  use Bio::Restriction::Analysis;
\&  use Bio::PrimarySeq;
\&  use Data::Dumper;
.Ve
.PP
.Vb 5
\&  # get a DNA sequence from somewhere
\&  my $seq = new Bio::PrimarySeq
\&      (-seq =>'AGCTTAATTCATTAGCTCTGACTGCAACGGGCAATATGTCTC',
\&       -primary_id => 'synopsis',
\&       -molecule => 'dna');
.Ve
.PP
.Vb 3
\&  # now start an analysis.
\&  # this is using the default set of enzymes
\&  my $ra = Bio::Restriction::Analysis->new(-seq=>$seq);
.Ve
.PP
.Vb 5
\&  # find unique cutters. This returns a
\&  # Bio::Restriction::EnzymeCollection object
\&  my $enzymes = $ra->unique_cutters;
\&  print "Unique cutters: ", join (', ', 
\&      map {$_->name} $enzymes->unique_cutters), "\en";
.Ve
.PP
.Vb 2
\&  # AluI is one them. Where does it cut?
\&  # This is will return an array of the sequence strings
.Ve
.PP
.Vb 4
\&  my $enz = 'AluI';
\&  my @frags = $ra->fragments($enz);
\&  # how big are the fragments?
\&  print "AluI fragment lengths: ", join(' & ', map {length $_} @frags), "\en";
.Ve
.PP
.Vb 5
\&  # You can also bypass fragments and call sizes directly:
\&  # to see all the fragment sizes
\&  print "All sizes: ", join " ", $ra->sizes($enz), "\en";
\&  # to see all the fragment sizes sorted by size like on a gel
\&  print "All sizes, sorted ", join (" ", $ra->sizes($enz, 0, 1)), "\en";
.Ve
.PP
.Vb 3
\&  # how many times does each enzyme cut
\&  my $cuts = $ra->cuts_by_enzyme('BamHI');
\&  print "BamHI cuts $cuts times\en";
.Ve
.PP
.Vb 3
\&  # How many enzymes do not cut at all?
\&  print "There are ", scalar $ra->zero_cutters->each_enzyme,
\&        " enzymes that do not cut\en";
.Ve
.PP
.Vb 4
\&  # what about enzymes that cut twice?
\&  my $two_cutters = $ra->cutters(2);
\&  print join (" ", map {$_->name} $two_cutters->each_enzyme),
\&      " cut the sequence twice\en";
.Ve
.PP
.Vb 6
\&  # what are all the enzymes that cut, and how often do they cut
\&  printf "\en%-10s%s\en", 'Enzyme', 'Number of Cuts';
\&  my $all_cutters = $ra->cutters;
\&  map {
\&      printf "%-10s%s\en", $_->name, $ra->cuts_by_enzyme($_->name)
\&  } $all_cutters->each_enzyme;
.Ve
.PP
.Vb 4
\&  # Finally, we can interact the restriction enzyme object by
\&  # retrieving it from the collection object see the docs for
\&  # Bio::Restriction::Enzyme.pm
\&  my $enzobj = $enzymes->get_enzyme($enz);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::Restriction::Analysis describes the results of cutting a \s-1DNA\s0
sequence with restriction enzymes.
.PP
To use this module you can pass a sequence object and optionally a
Bio::Restriction::EnzymeCollection that contains the enzyme(s) to cut the
sequences with. There is a default set of enzymes that will be loaded
if you do not pass in a Bio::Restriction::EnzymeCollection.
.PP
To cut a sequence, set up a Restriction::Analysis object with a sequence
like this:
.PP
.Vb 2
\&  use Bio::Restriction::Analysis;
\&  my $ra = Bio::Restriction::Analysis->new(-seq=>$seqobj);
.Ve
.PP
or
.PP
.Vb 2
\&  my $ra = Bio::Restriction::Analysis->new
\&      (-seq=>$seqobj, -enzymes=>$enzs);
.Ve
.PP
Then, to get the fragments for a particular enzyme use this:
.PP
.Vb 1
\&  @fragments = $ra->fragments('EcoRI');
.Ve
.PP
Note that the naming of restriction enzymes is that the last numbers
are usually Roman numbers (I, \s-1II\s0, \s-1III\s0, etc). You may want to use
something like this:
.PP
.Vb 6
\&  # get a reference to an array of unique (single) cutters
\&  $singles = $re->unique_cutters;
\&  foreach my $enz ($singles->each_enzyme) {
\&      @fragments = $re->fragments($enz);
\&      ... do something here ...
\&  }
.Ve
.PP
Note that if your sequence is circular, the first and last fragment
will be joined so that they are the appropriate length and sequence
for further analysis. This fragment will also be checked for cuts
by the enzyme(s).  However, this will change the start of the
sequence!
.PP
There are two separate algorithms used depending on whether your
enzyme has ambiguity. The non-ambiguous algoritm is a lot faster,
and if you are using very large sequences you should try and use
this algorithm. If you have a large sequence (e.g. genome) and 
want to use ambgiuous enzymes you may want to make seperate
Bio::Restriction::Enzyme objects for each of the possible
alternatives and make sure that you do not set is_ambiguous!
.PP
This version should correctly deal with overlapping cut sites
in both ambiguous and non-ambiguous enzymes.
.PP
I have tried to write this module with speed and memory in mind
so that it can be effectively used for large (e.g. genome sized)
sequence. This module only stores the cut positions internally,
and calculates everything else on an as-needed basis. Therefore
when you call fragment_maps (for example), there may be another
delay while these are generated.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists. Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution. Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Rob Edwards, redwards@utmem.edu, 
Steve Chervitz, sac@bioperl.org
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Heikki Lehvaslaiho, heikki-at-bioperl-dot-org
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2003 Rob Edwards.  Some of this work is Copyright (c)
1997\-2002 Steve A. Chervitz. All Rights Reserved.
.PP
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Bio::Restriction::Enzyme, 
Bio::Restriction::EnzymeCollection
.SH "APPENDIX"
.IX Header "APPENDIX"
Methods beginning with a leading underscore are considered private and
are intended for internal use by this module. They are not considered
part of the public interface and are described here for documentation
purposes only.
.SH "new"
.IX Header "new"
.Vb 4
\& Title     : new
\& Function  : Initializes the restriction enzyme object
\& Returns   : The Restriction::Analysis object 
\& Arguments :
.Ve
.PP
.Vb 5
\&             $re_anal->new(-seq=$seqobj, 
\&                 -enzymes=>Restriction::EnzymeCollection object)
\&             -seq requires a Bio::PrimarySeq object
\&             -enzymes is optional.
\&              If ommitted it will use the default set of enzymes
.Ve
.PP
This is the place to start. Pass in a sequence, and you will be able
to get the fragments back out.  Several other things are available
like the number of zero cutters or single cutters.
.SH "Methods to set parameters"
.IX Header "Methods to set parameters"
.Sh "seq"
.IX Subsection "seq"
.Vb 6
\& Title    : seq
\& Usage    : $ranalysis->seq($newval);
\& Function : get/set method for the  sequence to be cut
\& Example  : $re->seq($seq);
\& Returns  : value of seq
\& Args     : A Bio::PrimarySeqI dna object (optional)
.Ve
.Sh "enzymes"
.IX Subsection "enzymes"
.Vb 7
\& Title    : enzymes
\& Usage    : $re->enzymes($newval)
\& Function : gets/Set the restriction enzyme enzymes
\& Example  : $re->enzymes('EcoRI')
\& Returns  : reference to the collection
\& Args     : an array of Bio::Restriction::EnzymeCollection and/or
\&            Bio::Restriction::Enzyme objects
.Ve
.PP
The default object for this method is
Bio::Restriction::EnzymeCollection.  However, you can also pass it a
list of Bio::Restriction::Enzyme objects \- even mixed with Collection
objects.  They will all be stored into one collection.
.SH "Perform the analysis"
.IX Header "Perform the analysis"
.Sh "cut"
.IX Subsection "cut"
.Vb 6
\& Title    : cut
\& Usage    : $re->cut()
\& Function : Cut the sequence with the enzymes
\& Example  : $re->cut(); $re->cut('single'); or $re->cut('multiple', $enzymecollection);
\& Returns  : $self
\& Args     : 'single' (optional), 'multiple' with enzyme collection.
.Ve
.PP
An explicit cut method is needed to pass arguments to it. 
.PP
There are two varieties of cut. Single is the default, and need
not be explicitly called. This cuts the sequence with each
enzyme separately.
.PP
Multiple cuts a sequence with more than one enzyme. You must pass
it a Bio::Restriction::EnzymeCollection object of the set
of enzymes that you want to use in the double digest. The results
will be stored as an enzyme named \*(L"multiple_digest\*(R", so you can
use all the retrieval methods to get the data.
.PP
If you want to use the default setting there is no need to call cut
directly. Every method in the class that needs output checks the
object's internal status and recalculates the cuts if needed.
.PP
Note: cut doesn't now re-initialize everything before figuring
out cuts. This is so that you can do multiple digests, or add more
data or whatever. You'll have to use new to reset everything.
.PP
See also the comments in above about ambiguous and non-ambiguous
sequences.
.Sh "mulitple_digest"
.IX Subsection "mulitple_digest"
.Vb 4
\& Title     : multiple_digest
\& Function  : perform a multiple digest on a sequence
\& Returns   : $self so you can go and get any of the other methods
\& Arguments : An enzyme collection
.Ve
.PP
.Vb 4
\& Multiple digests can use 1 or more enzymes, and the data is stored
\& in as if it were an enzyme called multiple_digest. You can then
\& retrieve information about multiple digests from any of the other
\& methods.
.Ve
.PP
.Vb 1
\& You can use this method in place of $re->cut('multiple', $enz_coll);
.Ve
.SH "Query the results of the analysis"
.IX Header "Query the results of the analysis"
.Sh "positions"
.IX Subsection "positions"
.Vb 6
\&  Title    : positions
\&  Function : Retrieve the positions that an enzyme cuts at
\&  Returns  : An array of the positions that an enzyme cuts at
\&           : or an empty array if the enzyme doesn't cut
\&  Arguments: An enzyme name to retrieve the positions for
\&  Comments : The cut occurs after the base specified.
.Ve
.Sh "fragments"
.IX Subsection "fragments"
.Vb 4
\&  Title    : fragments
\&  Function : Retrieve the fragments that we cut
\&  Returns  : An array of the fragments retrieved. 
\&  Arguments: An enzyme name to retrieve the fragments for
.Ve
.PP
For example this code will retrieve the fragments for all enzymes that
cut your sequence
.PP
.Vb 4
\&  my $all_cutters = $analysis->cutters;
\&  foreach my $enz ($$all_cutters->each_enzyme}) {
\&      @fragments=$analysis->fragments($enz);
\&  }
.Ve
.Sh "fragment_maps"
.IX Subsection "fragment_maps"
.Vb 3
\&  Title     : fragment_maps
\&  Function  : Retrieves fragment sequences with start and end
\&              points. Useful for feature construction.
.Ve
.PP
.Vb 4
\&  Returns   : An array containing a hash reference for each fragment,
\&              containing the start point, end point and DNA
\&              sequence. The hash keys are 'start', 'end' and
\&              'seq'. Returns an empty array if not defined.
.Ve
.PP
.Vb 2
\&  Arguments : An enzyme name, enzyme object, 
\&              or enzyme collection to retrieve the fragments for.
.Ve
.PP
If passes an enzyme collection it will return the result of a multiple
digest. This : will also cause the special enzyme 'multiple_digest' to
be created so you can get : other information about this multiple
digest. (\s-1TMTOWTDI\s0).
.PP
There is a minor problem with this and \f(CW$self\fR\->fragments that I
haven't got a good answer for (at the moment). If the sequence is not
cut, do we return undef, or the whole sequence?
.PP
For linear fragments it would be good to return the whole
sequence. For circular fragments I am not sure.
.PP
At the moment it returns the whole sequence with start of 1 and end of
length of the sequence.  For example:
.PP
.Vb 3
\&  use Bio::Restriction::Analysis;
\&  use Bio::Restriction::EnzymeCollection;
\&  use Bio::PrimarySeq;
.Ve
.PP
.Vb 4
\&  my $seq = new Bio::PrimarySeq
\&      (-seq =>'AGCTTAATTCATTAGCTCTGACTGCAACGGGCAATATGTCTCTGTGTGGATCCAAAAAAGAGTGAGCTTCTGAT',
\&       -primary_id => 'synopsis',
\&       -molecule => 'dna');
.Ve
.PP
.Vb 1
\&  my $ra = Bio::Restriction::Analysis->new(-seq=>$seq);
.Ve
.PP
.Vb 10
\&  my @gel;
\&  my @bam_maps = $ra->fragment_maps('BamHI');
\&  foreach my $i (@bam_maps) {
\&     my $start = $i->{start};
\&     my $end = $i->{end};
\&     my $sequence = $i->{seq};
\&     push @gel, "$start--$sequence--$end";
\&     @gel = sort {length $b <=> length $a} @gel;
\&  }
\&  print join("\en", @gel) . "\en";
.Ve
.Sh "sizes"
.IX Subsection "sizes"
.Vb 8
\&  Title    : sizes
\&  Function : Retrieves an array with the sizes of the fragments
\&  Returns  : Array that has the sizes of the fragments ordered from 
\&             largest to smallest like they would appear in a gel.
\&  Arguments: An enzyme name to retrieve the sizes for is required and
\&             kilobases to the nearest 0.1 kb, else it will be in
\&             bp. If the optional third entry is set the results will
\&             be sorted.
.Ve
.PP
This is designed to make it easy to see what fragments you should get
on a gel!
.PP
You should be able to do these:
.PP
.Vb 6
\&  # to see all the fragment sizes,
\&  print join "\en", @{$re->sizes($enz)}, "\en";
\&  # to see all the fragment sizes sorted
\&  print join "\en", @{$re->sizes($enz, 0, 1)}, "\en";
\&  # to see all the fragment sizes in kb sorted
\&  print join "\en", @{$re->sizes($enz, 1, 1)}, "\en";
.Ve
.SH "How many times does enzymes X cut?"
.IX Header "How many times does enzymes X cut?"
.Sh "cuts_by_enzyme"
.IX Subsection "cuts_by_enzyme"
.Vb 5
\& Title     : cuts_by_enzyme
\& Function  : Return the number of cuts for an enzyme
\& Returns   : An integer with the number of times each enzyme cuts.
\&             Returns 0 if doesn't cut or undef if not defined
\& Arguments : An enzyme name string
.Ve
.SH "Which enzymes cut the sequence N times?"
.IX Header "Which enzymes cut the sequence N times?"
.Sh "cutters"
.IX Subsection "cutters"
.Vb 7
\& Title     : cutters
\& Function  : Find enzymes that cut a given number of times
\& Returns   : a Bio::Restriction::EnzymeCollection
\& Arguments : 1. exact time or lower limit,
\&                non-negative integer, optional
\&             2. upper limit, non-negative integer,
\&                larger or equalthan first, optional
.Ve
.PP
If no argumets are given, the method returns all enzymes that do cut
the sequence. The argument zero, '0', is same as method
\&\fIzero_cutters()\fR.  The argument one, '1', corresponds to unique_cutters.
If either of the limits is larger than number of cuts any enzyme cuts the
sequence, the that limit is automagically lowered. The method \fImax_cuts()\fR
gives the largest number of cuts.
.PP
See Also : unique_cutters,
zero_cutters, max_cuts
.Sh "unique_cutters"
.IX Subsection "unique_cutters"
.Vb 4
\& Title     : unique_cutters
\& Function  : A special case if cutters() where enzymes only cut once
\& Returns   : a Bio::Restriction::EnzymeCollection
\& Arguments : -
.Ve
.PP
See also:  cutters, zero_cutters
.Sh "zero_cutters"
.IX Subsection "zero_cutters"
.Vb 4
\& Title     : zero_cutters
\& Function  : A special case if cutters() where enzymes don't cut the sequence
\& Returns   : a Bio::Restriction::EnzymeCollection
\& Arguments : -
.Ve
.PP
See also:  cutters, unique_cutters
.Sh "max_cuts"
.IX Subsection "max_cuts"
.Vb 4
\& Title     : max_cuts
\& Function  : Find the most number of cuts
\& Returns   : The number of times the enzyme that cuts most cuts.
\& Arguments : None
.Ve
.PP
This is not a very practical method, but if you are curious...
.SH "Internal methods"
.IX Header "Internal methods"
.Sh "_cuts"
.IX Subsection "_cuts"
.Vb 6
\& Title     : _cuts
\& Function  : Figures out which enzymes we know about and cuts the sequence.
\& Returns   : Nothing.
\& Arguments : None.
\& Comments  : An internal method. This will figure out where the sequence 
\&             should be cut, and provide the appropriate results.
.Ve
.Sh "_enzyme_sites"
.IX Subsection "_enzyme_sites"
.Vb 4
\& Title     : _enzyme_sites
\& Function  : An internal method to figure out the two sides of an enzyme
\& Returns   : The sequence before the cut and the sequence after the cut
\& Arguments : A Bio::Restriction::Enzyme object
.Ve
.Sh "_non_pal_enz"
.IX Subsection "_non_pal_enz"
.Vb 4
\&  Title    : _non_pal_enz
\&  Function : Analyses non_palindromic enzymes for cuts in both ways
\&  Returns  : A reference to an array of cut positions
\&  Arguments: The sequence to check and the enzyme object
.Ve
.Sh "_ambig_cuts"
.IX Subsection "_ambig_cuts"
.Vb 6
\& Title     : _ambig_cuts
\& Function  : An internal method to localize the cuts in the sequence
\& Returns   : A reference to an array of cut positions
\& Arguments : The separated enzyme site, the target sequence, and the enzyme object
\& Comments  : This is a slow implementation but works for ambiguous sequences.
\&             Whenever possible, _nonambig_cuts should be used as it is a lot faster.
.Ve
.Sh "_nonambig_cuts"
.IX Subsection "_nonambig_cuts"
.Vb 4
\& Title     : _nonambig_cuts
\& Function  : Figures out which enzymes we know about and cuts the sequence.
\& Returns   : Nothing.
\& Arguments : The separated enzyme site, the target sequence, and the enzyme object
.Ve
.PP
An internal method. This will figure out where the sequence should be
cut, and provide the appropriate results.  This is a much faster
implementation because it doesn't use a regexp, but it can not deal
with ambiguous sequences
.Sh "_mulitple_cuts"
.IX Subsection "_mulitple_cuts"
.Vb 6
\& Title     : _multiple_cuts
\& Function  : Figures out multiple digests
\& Returns   : An array of the cut sites for multiply digested DNA
\& Arguments : A Bio::Restriction::EnzymeCollection object
\& Comments  : Double digests is one subset of this, but you can use
\&             as many enzymes as you want.
.Ve
.Sh "_circular"
.IX Subsection "_circular"
.Vb 4
\& Title     : _circular
\& Function  : Deals with circular sequences
\& Returns   : Nothing.
\& Arguments : None.
.Ve
.PP
There are two problems with circular sequences.
.PP
.Vb 2
\&  1. When you cut a sequence and rejoin fragments you could generate
\&  new cut sites.
.Ve
.PP
.Vb 1
\&  2. There could be a cut site at the end of the sequence.
.Ve
.PP
I think these may be the same problem, and so we're working on #2 first!
.Sh "_expanded_string"
.IX Subsection "_expanded_string"
.Vb 4
\& Title     : _expanded_string
\& Function  : Expand nucleotide ambiguity codes to their representative letters
\& Returns   : The full length string
\& Arguments : The string to be expanded.
.Ve
.PP
Stolen from the original RestrictionEnzyme.pm
