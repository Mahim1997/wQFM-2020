.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Seq::Meta::Array 3"
.TH Bio::Seq::Meta::Array 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Seq::Meta::Array \- array\-based generic implementation of a
sequence class with residue\-based meta information
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Bio::LocatableSeq;
\&  use Bio::Seq::Meta::Array;
.Ve
.PP
.Vb 9
\&  my $seq = Bio::LocatableSeq->new(-id=>'test',
\&                                   -seq=>'ACTGCTAGCT',
\&                                   -start=>2434,
\&                                   -start=>2443,
\&                                   -strand=>1,
\&                                   -varbose=>1, # to see warnings
\&                                  );
\&  bless $seq, Bio::Seq::Meta::Array;
\&  # the existing sequence object can be a Bio::PrimarySeq, too
.Ve
.PP
.Vb 3
\&  # to test this is a meta seq object
\&  $seq->isa("Bio::Seq::Meta::Array")
\&      || $seq->throw("$seq is not a Bio::Seq::Meta::Array");
.Ve
.PP
.Vb 1
\&  $seq->meta('1 2 3 4 5 6 7 8 9 10');
.Ve
.PP
.Vb 9
\&  # or you could create the Meta object directly
\&  $seq = Bio::Seq::Meta::Array->new(-id=>'test',
\&                                    -seq=>'ACTGCTAGCT',
\&                                    -start=>2434,
\&                                    -start=>2443,
\&                                    -strand=>1,
\&                                    -meta=>'1 2 3 4 5 6 7 8 9 10',
\&                                    -varbose=>1, # to see warnings
\&                                   );
.Ve
.PP
.Vb 5
\&  # accessors
\&  $arrayref   = $seq->meta();
\&  $string     = $seq->meta_text();
\&  $substring  = $seq->submeta_text(2,5);
\&  $unique_key = $seq->accession_number();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class implements generic methods for sequences with residue-based
meta information. Meta sequences with meta data are Bio::LocatableSeq
objects with additional methods to store that meta information. See
Bio::LocatableSeq and Bio::Seq::MetaI.
.PP
The meta information in this class can be a string of variable length
and can be a complex structure.  Blank values are undef or zero.
.PP
Application specific implementations should inherit from this class to
override and add to these methods.
.PP
This class can be used for storing sequence quality values but
Bio::Seq::Quality has named methods that make it easier.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Bio::LocatableSeq, 
Bio::Seq::MetaI, 
Bio::Seq::Meta, 
Bio::Seq::Quality
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Heikki Lehvaslaiho"
.IX Header "AUTHOR - Heikki Lehvaslaiho"
Email heikki-at-bioperl-dot-org
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Chad Matsalla, bioinformatics@dieselwurks.com
Aaron Mackey, amackey@virginia.edu
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.Sh "new"
.IX Subsection "new"
.Vb 10
\& Title   : new
\& Usage   : $metaseq = Bio::Seq::Meta::Array->new
\&                ( -meta => 'aaaaaaaabbbbbbbb',
\&                  -seq =>  'TKLMILVSHIVILSRM'
\&                  -id  => 'human_id',
\&                  -accession_number => 'S000012',
\&                );
\& Function: Constructor for Bio::Seq::Meta::Array class, meta data being in a
\&           string. Note that you can provide an empty quality string.
\& Returns : a new Bio::Seq::Meta::Array object
.Ve
.Sh "meta"
.IX Subsection "meta"
.Vb 3
\& Title   : meta
\& Usage   : $meta_values  = $obj->meta($values_string);
\& Function:
.Ve
.PP
.Vb 3
\&           Get and set method for the meta data starting from residue
\&           position one. Since it is dependent on the length of the
\&           sequence, it needs to be manipulated after the sequence.
.Ve
.PP
.Vb 2
\&           The length of the returned value always matches the length
\&           of the sequence.
.Ve
.PP
.Vb 2
\& Returns : reference to an array of meta data
\& Args    : new value, string or array ref, optional
.Ve
.Sh "meta_text"
.IX Subsection "meta_text"
.Vb 6
\& Title   : meta_text
\& Usage   : $meta_values  = $obj->meta_text($values_arrayref);
\& Function: Variant of meta() guarantied to return a string
\&           representation  of meta data. For details, see L<meta>.
\& Returns : a string
\& Args    : new value, string or array ref, optional
.Ve
.Sh "named_meta"
.IX Subsection "named_meta"
.Vb 7
\& Title   : named_meta()
\& Usage   : $meta_values  = $obj->named_meta($name, $values_arrayref);
\& Function: A more general version of meta(). Each meta data set needs
\&           to be named. See also L<meta_names>.
\& Returns : reference to an array of meta data
\& Args    : scalar, name of the meta data set
\&           new value, string or array ref, optional
.Ve
.Sh "_test_gap_positions"
.IX Subsection "_test_gap_positions"
.Vb 4
\& Title   : _test_gap_positions
\& Usage   : $meta_values  = $obj->_test_gap_positions($name);
\& Function: Internal test for correct position of gap characters.
\&           Gap being only '-' this time.
.Ve
.PP
.Vb 5
\&           This method is called from named_meta() when setting meta
\&           data but only if verbose is positive as this can be an
\&           expensive process on very long sequences. Set verbose(1) to
\&           see warnings when gaps do not align in sequence and meta
\&           data and turn them into errors by setting verbose(2).
.Ve
.PP
.Vb 2
\& Returns : true on success, prints warnings
\& Args    : none
.Ve
.Sh "named_meta_text"
.IX Subsection "named_meta_text"
.Vb 8
\& Title   : named_meta_text()
\& Usage   : $meta_values  = $obj->named_meta_text($name, $values_arrayref);
\& Function: Variant of named_meta() guarantied to return a textual
\&           representation  of the named meta data.
\&           For details, see L<meta>.
\& Returns : a string
\& Args    : scalar, name of the meta data set
\&           new value, string or array ref, optional
.Ve
.Sh "submeta"
.IX Subsection "submeta"
.Vb 4
\& Title   : submeta
\& Usage   : $subset_of_meta_values = $obj->submeta(10, 20, $value_string);
\&           $subset_of_meta_values = $obj->submeta(10, undef, $value_string);
\& Function:
.Ve
.PP
.Vb 1
\&           Get and set method for meta data for subsequences.
.Ve
.PP
.Vb 3
\&           Numbering starts from 1 and the number is inclusive, ie 1-2
\&           are the first two residue of the sequence. Start cannot be
\&           larger than end but can be equal.
.Ve
.PP
.Vb 2
\&           If the second argument is missing the returned values
\&           should extend to the end of the sequence.
.Ve
.PP
.Vb 4
\&           The return value may be a string or an array reference,
\&           depending on the implentation. If in doubt, use
\&           submeta_text() which is a variant guarantied to return a
\&           string.  See L<submeta_text>.
.Ve
.PP
.Vb 4
\& Returns : A reference to an array or a string
\& Args    : integer, start position
\&           integer, end position, optional when a third argument present
\&           new value, string or array ref, optional
.Ve
.Sh "submeta_text"
.IX Subsection "submeta_text"
.Vb 6
\& Title   : submeta_text
\& Usage   : $meta_values  = $obj->submeta_text(20, $value_string);
\& Function: Variant of submeta() guarantied to return a textual
\&           representation  of meta data. For details, see L<meta>.
\& Returns : a string
\& Args    : new value, string or array ref, optional
.Ve
.Sh "named_submeta"
.IX Subsection "named_submeta"
.Vb 10
\& Title   : named_submeta
\& Usage   : $subset_of_meta_values = $obj->named_submeta($name, 10, 20, $value_string);
\&           $subset_of_meta_values = $obj->named_submeta($name, 10);
\& Function: Variant of submeta() guarantied to return a textual
\&           representation  of meta data. For details, see L<meta>.
\& Returns : A reference to an array or a string
\& Args    : scalar, name of the meta data set
\&           integer, start position
\&           integer, end position, optional when a third argument present (can be undef)
\&           new value, string or array ref, optional
.Ve
.Sh "named_submeta_text"
.IX Subsection "named_submeta_text"
.Vb 9
\& Title   : named_submeta_text
\& Usage   : $meta_values  = $obj->named_submeta_text($name, 20, $value_string);
\& Function: Variant of submeta() guarantied to return a textual
\&           representation  of meta data. For details, see L<meta>.
\& Returns : a string
\& Args    : scalar, name of the meta data
\& Args    : integer, start position, optional
\&           integer, end position, optional
\&           new value, string or array ref, optional
.Ve
.Sh "meta_names"
.IX Subsection "meta_names"
.Vb 7
\& Title   : meta_names
\& Usage   : @meta_names  = $obj->meta_names()
\& Function: Retrives an array of meta data set names. The default
\&           (unnamed) set name is guarantied to be the first name if it
\&           contains any data.
\& Returns : an array of names
\& Args    : none
.Ve
.Sh "meta_length"
.IX Subsection "meta_length"
.Vb 5
\& Title   : meta_length()
\& Usage   : $meta_len  = $obj->meta_length();
\& Function: return the number of elements in the meta set
\& Returns : integer
\& Args    : -
.Ve
.Sh "named_meta_length"
.IX Subsection "named_meta_length"
.Vb 5
\& Title   : named_meta_length()
\& Usage   : $meeta_len  = $obj->named_meta_length($name);
\& Function: return the number of elements in the named meta set
\& Returns : integer
\& Args    : -
.Ve
.Sh "force_flush"
.IX Subsection "force_flush"
.Vb 6
\& Title   : force_flush()
\& Usage   : $force_flush = $obj->force_flush(1);
\& Function: Automatically pad with empty values or truncate meta values
\&           to sequence length. Not done by default.
\& Returns : boolean 1 or 0
\& Args    : optional boolean value
.Ve
.PP
Note that if you turn this forced padding off, the previously padded
values are not changed.
.Sh "_do_flush"
.IX Subsection "_do_flush"
.Vb 6
\& Title   : _do_flush
\& Usage   : 
\& Function: internal method to do the force that meta values are same
\&           length as sequence . Called from L<force_flush>
\& Returns : 
\& Args    :
.Ve
.Sh "is_flush"
.IX Subsection "is_flush"
.Vb 9
\& Title   : is_flush
\& Usage   : $is_flush  = $obj->is_flush()
\&           or  $is_flush = $obj->is_flush($my_meta_name)
\& Function: Boolean to tell if all meta values are in
\&           flush with the sequence length.
\&           Returns true if force_flush() is set
\&           Set verbosity to a positive value to see failed meta sets
\& Returns : boolean 1 or 0
\& Args    : optional name of the meta set
.Ve
.SH "Bio::PrimarySeqI methods"
.IX Header "Bio::PrimarySeqI methods"
.Sh "revcom"
.IX Subsection "revcom"
.Vb 7
\& Title   : revcom
\& Usage   : $newseq = $seq->revcom();
\& Function: Produces a new Bio::Seq::MetaI implementing object where
\&           the order of residues and their meta information is reversed.
\& Returns : A new (fresh) Bio::Seq::Meta object
\& Args    : none
\& Throws  : if the object returns false on is_flush()
.Ve
.PP
Note: The method does nothing to meta values, it reorders them, only.
.Sh "trunc"
.IX Subsection "trunc"
.Vb 5
\& Title   : trunc
\& Usage   : $subseq = $seq->trunc(10,100);
\& Function: Provides a truncation of a sequence together with meta data
\& Returns : a fresh Bio::Seq::Meta implementing object
\& Args    : Two integers denoting first and last residue of the sub-sequence.
.Ve
