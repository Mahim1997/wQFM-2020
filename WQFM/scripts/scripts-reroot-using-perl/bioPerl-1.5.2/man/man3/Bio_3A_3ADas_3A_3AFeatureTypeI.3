.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Das::FeatureTypeI 3"
.TH Bio::Das::FeatureTypeI 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Das::FeatureTypeI \- Simple interface to Sequence Ontology feature types
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # Get a Bio::Das::FeatureTypeI object from somewhere
\&  $term = $db->fetch....
.Ve
.PP
.Vb 2
\&  # Get the name of the term
\&  $definition = $term->name;
.Ve
.PP
.Vb 2
\&  # Get the accession of the term
\&  $accession = $term->accession;
.Ve
.PP
.Vb 2
\&  # Get the definition of the term
\&  $definition = $term->definition;
.Ve
.PP
.Vb 2
\&  # Get the parents of the term, optionally filtered by relationship
\&  @parents = $term->parents($relationship);
.Ve
.PP
.Vb 2
\&  # Get the children of the term, optionally filtered by relationship
\&  @children = $term->children($relationship);
.Ve
.PP
.Vb 3
\&  # Given a parent and child, returns their relationship, or undef if
\&  # not directly related
\&  $relationship = $parent->relationship($child);
.Ve
.PP
.Vb 2
\&  # Return true if two terms are identical
\&  $match = $term1->equals($term2);
.Ve
.PP
.Vb 3
\&  # Return true if $term2 is a descendent of $term1, optionally
\&  # filtering by relationship ("isa" assumed)
\&  $match = $term1->is_descendent($term2,$relationship);
.Ve
.PP
.Vb 3
\&  # Return true if $term2 is a parent of $term1, optionally
\&  # filtering by relationship ("isa" assumed)
\&  $match = $term1->is_parent($term2,$relationship);
.Ve
.PP
.Vb 3
\&  # Return true if $term2 is equal to $term1 or if $term2 descends
\&  # from term 1 via the "isa" relationship
\&  $match = $term1->match($term2);
.Ve
.PP
.Vb 4
\&  # Create a new term de novo
\&  $term = Bio::Das::FeatureTypeI->new(-name       => $name,
\&                                      -accession  => $accession,
\&                                      -definition => $definition);
.Ve
.PP
.Vb 2
\&  # Add a child to a term
\&  $term1->add_child($term2,$relationship);
.Ve
.PP
.Vb 2
\&  # Delete a child from a term
\&  $term1->delete_child($term2);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::Das::FeatureTypeI is an interface to the Gene Ontology
Consortium's Sequence Ontology (\s-1SO\s0).  The \s-1SO\s0, like other ontologies,
is a directed acyclic graph in which a child node may have multiple
parents.  The relationship between parent and child is one of a list
of relationships.  The \s-1SO\s0 currently recognizes two relationships \*(L"isa\*(R"
and \*(L"partof\*(R".
.PP
The intent of this interface is to interoperate with older software
that uses bare strings to represent feature types.  For this reason,
the interface overloads the stringify ("") and string equals (eq)
operations.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this
and other Bioperl modules. Send your comments and suggestions preferably
 to one of the Bioperl mailing lists.
Your participation is much appreciated.
.PP
.Vb 1
\&  bioperl-l@bio.perl.org
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Lincoln Stein"
.IX Header "AUTHOR - Lincoln Stein"
Email lstein@cshl.org
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.PP
this is somehow \s-1FUBAR\s0, implementation classes cannot successfully inherit from Bio::Das::FeatureTypeI
.Sh "name"
.IX Subsection "name"
.Vb 6
\& Title   : name
\& Usage   : $string = $term->name
\& Function: return the term for the type
\& Returns : a string
\& Args    : none
\& Status  : Public
.Ve
.Sh "accession"
.IX Subsection "accession"
.Vb 6
\& Title   : accession
\& Usage   : $string = $term->accession
\& Function: return the accession number for the term
\& Returns : a string
\& Args    : none
\& Status  : Public
.Ve
.Sh "definition"
.IX Subsection "definition"
.Vb 6
\& Title   : definition
\& Usage   : $string = $term->definition
\& Function: return the human-readable definition for the term
\& Returns : a string
\& Args    : none
\& Status  : Public
.Ve
.Sh "parents"
.IX Subsection "parents"
.Vb 6
\& Title   : parents
\& Usage   : @terms = $term->parents($relationship)
\& Function: return parent terms
\& Returns : list of Bio::Das::FeatureTypeI
\& Args    : none
\& Status  : Public
.Ve
.PP
Returns the parents for the current term, empty if there are none.  An
optional relationship argument will return those parents
that are related via the specified relationship type.
.PP
The relationship is one of \*(L"isa\*(R" or \*(L"partof\*(R".
.Sh "children"
.IX Subsection "children"
.Vb 6
\& Title   : children
\& Usage   : @terms = $term->children($relationship)
\& Function: return children terms
\& Returns : list of Bio::Das::FeatureTypeI
\& Args    : none
\& Status  : Public
.Ve
.PP
Returns the children for the current term, empty if there are none.  An
optional relationship argument will return those children
that are related via the specified relationship type.
.PP
The relationship is one of \*(L"isa\*(R" or \*(L"partof\*(R".
.Sh "relationship"
.IX Subsection "relationship"
.Vb 6
\& Title   : relationship
\& Usage   : $relationship = $parent->relationship($child)
\& Function: return the relationship between a parent and a child
\& Returns : one of "isa" or "partof"
\& Args    : none
\& Status  : Public
.Ve
.PP
This method returns the relationship between a parent and one of its
immediate descendents.  It can return \*(L"isa\*(R", \*(L"partof\*(R", or undef if
there is not a direct parent/child relationship (kissing cousins are
*not* recognized).
.Sh "equals"
.IX Subsection "equals"
.Vb 6
\& Title   : equals
\& Usage   : $boolean = $term1->equals($term2)
\& Function: return true if $term1 and $term2 are the same
\& Returns : boolean
\& Args    : second term
\& Status  : Public
.Ve
.PP
The two terms must be identical.  In practice, this means that if
term2 is a Bio::Das::FeatureI object, then its accession number must
match the first term's accession number.  Otherwise, if term2 is a
bare string, then it must equal (in a case insensitive manner)
the name of term1.
.PP
\&\s-1NOTE\s0 \s-1TO\s0 \s-1IMPLEMENTORS:\s0 This method is defined in terms of other
methods, so does not need to be implemented.
.Sh "is_descendent"
.IX Subsection "is_descendent"
.Vb 6
\& Title   : is_descendent
\& Usage   : $boolean = $term1->is_descendent($term2 [,$relationship])
\& Function: return true of $term2 is a descendent of $term1
\& Returns : boolean
\& Args    : second term
\& Status  : Public
.Ve
.PP
This method returns true if \f(CW$term2\fR descends from \f(CW$term1\fR.  The
operation traverses the tree.  The traversal can be limited to the
relationship type (\*(L"isa\*(R" or \*(L"partof\*(R") if desired.  \f(CW$term2\fR can be a
bare string, in which case the term names will be used as the basis
for term matching (see \fIequals()\fR).
.PP
\&\s-1NOTE\s0 \s-1TO\s0 \s-1IMPLEMENTORS:\s0 this method is defined as the inverse of
\&\fIis_parent()\fR.  Do not implement it directly, but do implement
\&\fIis_parent()\fR.
.Sh "is_parent"
.IX Subsection "is_parent"
.Vb 6
\& Title   : is_parent
\& Usage   : $boolean = $term1->is_parent($term2 [,$relationship])
\& Function: return true of $term2 is a parent of $term1
\& Returns : boolean
\& Args    : second term
\& Status  : Public
.Ve
.PP
This method returns true if \f(CW$term2\fR is a parent of \f(CW$term1\fR.  The
operation traverses the tree.  The traversal can be limited to the
relationship type (\*(L"isa\*(R" or \*(L"partof\*(R") if desired.  \f(CW$term2\fR can be a
bare string, in which case the term names will be used as the basis
for term matching (see \fIequals()\fR).
.PP
\&\s-1NOTE\s0 \s-1TO\s0 \s-1IMPLEMENTORS:\s0 Implementing this method will also implement
\&\fIis_descendent()\fR.
.Sh "match"
.IX Subsection "match"
.Vb 6
\& Title   : match
\& Usage   : $boolean = $term1->match($term2)
\& Function: return true if $term1 equals $term2 or if $term2 is an "isa" descendent
\& Returns : boolean
\& Args    : second term
\& Status  : Public
.Ve
.PP
This method combines \fIequals()\fR and \fIis_descendent()\fR in such a way that
the two terms will match if they are the same or if the second term is
an instance of the first one.  This is also the basis of the operator
overloading of eq.
.PP
\&\s-1NOTE\s0 \s-1TO\s0 \s-1IMPLEMENTORS:\s0 This method is defined in terms of other methods
and does not need to be implemented.
.Sh "new"
.IX Subsection "new"
.Vb 6
\& Title   : new
\& Usage   : $term = Bio::Das::FeatureTypeI->new(@args)
\& Function: create a new term
\& Returns : new term
\& Args    : see below
\& Status  : Public
.Ve
.PP
This method creates a new Bio::Das::FeatureTypeI.  Arguments:
.PP
.Vb 2
\&  Argument    Description
\&  --------   ------------
.Ve
.PP
.Vb 1
\&  -name       Name of this term
.Ve
.PP
.Vb 1
\&  -accession  Accession number for the term
.Ve
.PP
.Vb 1
\&  -definition Definition of the term
.Ve
.Sh "add_child"
.IX Subsection "add_child"
.Vb 7
\& Title   : add_child
\& Usage   : $boolean = $term->add_child($term2,$relationship)
\& Function: add a child to a term
\& Returns : a boolean indicating success
\& Args    : new child
\& Throws  : a "cycle detected" exception
\& Status  : Public
.Ve
.PP
This method adds a new child to the indicated node.  It may detect a
cycle in the \s-1DAG\s0 and throw a \*(L"cycle detected\*(R" exception.
.Sh "delete_child"
.IX Subsection "delete_child"
.Vb 7
\& Title   : delete_child
\& Usage   : $boolean = $term->delete_child($term2);
\& Function: delete a child of the term
\& Returns : a boolean indicating success
\& Args    : child to be deleted
\& Throws  : a "not a child" exception
\& Status  : Public
.Ve
.PP
This method deletes a new child from the indicated node.  It will
throw an exception if the indicated child is not a direct descendent.
