.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::SeqFeature::Annotated 3"
.TH Bio::SeqFeature::Annotated 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::SeqFeature::Annotated \- PLEASE PUT SOMETHING HERE
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    # none yet, complain to authors
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
None yet, complain to authors.
.SH "Implemented Interfaces"
.IX Header "Implemented Interfaces"
This class implementes the following interfaces.
.IP "Bio::SeqFeatureI" 4
.IX Item "Bio::SeqFeatureI"
Note that this includes implementing Bio::RangeI.
.IP "Bio::AnnotatableI" 4
.IX Item "Bio::AnnotatableI"
.PD 0
.IP "Bio::FeatureHolderI" 4
.IX Item "Bio::FeatureHolderI"
.PD
Features held by a feature are essentially sub\-features.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via 
the web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Allen Day"
.IX Header "AUTHOR - Allen Day"
Allen Day <allenday at ucla.edu>
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.SH "ATTRIBUTE ACCESSORS FOR Bio::SeqFeature::Annotated"
.IX Header "ATTRIBUTE ACCESSORS FOR Bio::SeqFeature::Annotated"
.Sh "from_feature"
.IX Subsection "from_feature"
.Vb 8
\&  Usage: $obj->from_feature($myfeature);
\&  Desc : initialize this object with the contents of another feature
\&         object.  Useful for converting objects like
\&         L<Bio::SeqFeature::Generic> to this class
\&  Ret  : nothing meaningful
\&  Args : a single object of some other feature type,
\&  Side Effects: throws error on failure
\&  Example:
.Ve
.Sh "\fIseq_id()\fP"
.IX Subsection "seq_id()"
.Vb 6
\& Usage   : $obj->seq_id($newval)
\& Function: holds a string corresponding to the unique
\&           seq_id of the sequence underlying the feature
\&           (e.g. database accession or primary key).
\& Returns : a Bio::Annotation::SimpleValue object representing the seq_id.
\& Args    : on set, some string or a Bio::Annotation::SimpleValue object.
.Ve
.Sh "\fIname()\fP"
.IX Subsection "name()"
.Vb 4
\& Usage   : $obj->name($newval)
\& Function: human-readable name for the feature.
\& Returns : value of name (a scalar)
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.Sh "\fItype()\fP"
.IX Subsection "type()"
.Vb 4
\& Usage   : $obj->type($newval)
\& Function: a SOFA type for the feature.
\& Returns : Bio::Annotation::OntologyTerm object representing the type.
\& Args    : on set, a SOFA name, identifier, or Bio::Annotation::OntologyTerm object.
.Ve
.Sh "\fIsource()\fP"
.IX Subsection "source()"
.Vb 4
\& Usage   : $obj->source($newval)
\& Function: holds a string corresponding to the source of the feature.
\& Returns : a Bio::Annotation::SimpleValue object representing the source.
\& Args    : on set, some scalar or a Bio::Annotation::SimpleValue object.
.Ve
.Sh "\fIscore()\fP"
.IX Subsection "score()"
.Vb 5
\& Usage   : $score = $feat->score()
\&           $feat->score($score)
\& Function: holds a value corresponding to the score of the feature.
\& Returns : a Bio::Annotation::SimpleValue object representing the score.
\& Args    : on set, a scalar or a Bio::Annotation::SimpleValue object.
.Ve
.Sh "\fIphase()\fP"
.IX Subsection "phase()"
.Vb 7
\& Usage   : $phase = $feat->phase()
\&           $feat->phase($phase)
\& Function: get/set on phase information
\& Returns : a Bio::Annotation::SimpleValue object holdig one of 0,1,2,'.'
\&           as its value.
\& Args    : on set, one of 0,1,2,'.' or a Bio::Annotation::SimpleValue
\&           object holding one of 0,1,2,'.' as its value.
.Ve
.Sh "\fIframe()\fP"
.IX Subsection "frame()"
.Vb 7
\& Usage   : $frame = $feat->frame()
\&           $feat->frame($phase)
\& Function: get/set on phase information
\& Returns : a Bio::Annotation::SimpleValue object holdig one of 0,1,2,'.'
\&           as its value.
\& Args    : on set, one of 0,1,2,'.' or a Bio::Annotation::SimpleValue
\&           object holding one of 0,1,2,'.' as its value.
.Ve
.SH "SHORTCUT METHDODS TO ACCESS Bio::AnnotatableI INTERFACE METHODS"
.IX Header "SHORTCUT METHDODS TO ACCESS Bio::AnnotatableI INTERFACE METHODS"
.Sh "\fIadd_Annotation()\fP"
.IX Subsection "add_Annotation()"
.Vb 4
\& Usage   :
\& Function: $obj->add_Annotation() is a shortcut to $obj->annotation->add_Annotation
\& Returns : 
\& Args    :
.Ve
.Sh "\fIremove_Annotations()\fP"
.IX Subsection "remove_Annotations()"
.Vb 4
\& Usage   :
\& Function: $obj->remove_Annotations() is a shortcut to $obj->annotation->remove_Annotations
\& Returns : 
\& Args    :
.Ve
.SH "INTERFACE METHODS FOR Bio::SeqFeatureI"
.IX Header "INTERFACE METHODS FOR Bio::SeqFeatureI"
.Sh "\fIdisplay_name()\fP"
.IX Subsection "display_name()"
.Vb 1
\& Deprecated, use L<Bio::SeqFeatureI/name()>.  Will raise a warning.
.Ve
.Sh "\fIprimary_tag()\fP"
.IX Subsection "primary_tag()"
.Vb 1
\& Deprecated, use L<Bio::SeqFeatureI/type()>.  Will raise a warning.
.Ve
.Sh "\fIsource_tag()\fP"
.IX Subsection "source_tag()"
.Vb 1
\& Deprecated, use L<Bio::SeqFeatureI/source()>.  Will raise a warning.
.Ve
.Sh "\fIattach_seq()\fP"
.IX Subsection "attach_seq()"
.Vb 6
\& Usage   : $sf->attach_seq($seq)
\& Function: Attaches a Bio::Seq object to this feature. This
\&           Bio::Seq object is for the *entire* sequence: ie
\&           from 1 to 10000
\& Returns : TRUE on success
\& Args    : a Bio::PrimarySeqI compliant object
.Ve
.Sh "\fIseq()\fP"
.IX Subsection "seq()"
.Vb 5
\& Usage   : $tseq = $sf->seq()
\& Function: returns a truncated version of seq() with bounds matching this feature
\& Returns : sub seq (a Bio::PrimarySeqI compliant object) on attached sequence
\&           bounded by start & end, or undef if there is no sequence attached
\& Args    : none
.Ve
.Sh "\fIentire_seq()\fP"
.IX Subsection "entire_seq()"
.Vb 5
\& Usage   : $whole_seq = $sf->entire_seq()
\& Function: gives the entire sequence that this seqfeature is attached to
\& Returns : a Bio::PrimarySeqI compliant object, or undef if there is no
\&           sequence attached
\& Args    : none
.Ve
.Sh "\fIhas_tag()\fP"
.IX Subsection "has_tag()"
.Vb 1
\& See Bio::AnnotatableI::has_tag().
.Ve
.Sh "\fIadd_tag_value()\fP"
.IX Subsection "add_tag_value()"
.Vb 1
\& See Bio::AnnotatableI::add_tag_value().
.Ve
.Sh "\fIget_tag_values()\fP"
.IX Subsection "get_tag_values()"
.Vb 1
\& See Bio::AnnotationCollectionI::get_tag_values().
.Ve
.Sh "\fIget_all_tags()\fP"
.IX Subsection "get_all_tags()"
.Vb 1
\& See Bio::AnnotationCollectionI::get_all_annotation_keys().
.Ve
.Sh "\fIremove_tag()\fP"
.IX Subsection "remove_tag()"
.Vb 1
\& See Bio::AnnotationCollectionI::remove_tag().
.Ve
.SH "INTERFACE METHODS FOR Bio::RangeI"
.IX Header "INTERFACE METHODS FOR Bio::RangeI"
.Vb 1
\& as inherited via Bio::SeqFeatureI
.Ve
.Sh "\fIlength()\fP"
.IX Subsection "length()"
.Vb 4
\& Usage   : $feature->length()
\& Function: Get the feature length computed as $feat->end - $feat->start + 1
\& Returns : integer
\& Args    : none
.Ve
.Sh "\fIstart()\fP"
.IX Subsection "start()"
.Vb 4
\& Usage   : $obj->start($newval)
\& Function: Get/set on the start coordinate of the feature
\& Returns : integer
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.Sh "\fIend()\fP"
.IX Subsection "end()"
.Vb 4
\& Usage   : $obj->end($newval)
\& Function: Get/set on the end coordinate of the feature
\& Returns : integer
\& Args    : on set, new value (a scalar or undef, optional)
.Ve
.Sh "\fIstrand()\fP"
.IX Subsection "strand()"
.Vb 4
\& Usage   : $strand = $feat->strand($newval)
\& Function: get/set on strand information, being 1,-1 or 0
\& Returns : -1,1 or 0
\& Args    : ???
.Ve
.SH "INTERFACE METHODS FOR Bio::FeatureHolderI"
.IX Header "INTERFACE METHODS FOR Bio::FeatureHolderI"
This includes methods for retrieving, adding, and removing
features. Since this is already a feature, features held by this
feature holder are essentially sub\-features.
.Sh "get_SeqFeatures"
.IX Subsection "get_SeqFeatures"
.Vb 4
\& Usage   : @feats = $feat->get_SeqFeatures();
\& Function: Returns an array of Bio::SeqFeatureI objects
\& Returns : An array
\& Args    : none
.Ve
.Sh "\fIadd_SeqFeature()\fP"
.IX Subsection "add_SeqFeature()"
.Vb 6
\& Usage   : $feat->add_SeqFeature($subfeat);
\&           $feat->add_SeqFeature($subfeat,'EXPAND')
\& Function: adds a SeqFeature into the subSeqFeature array.
\&           with no 'EXPAND' qualifer, subfeat will be tested
\&           as to whether it lies inside the parent, and throw
\&           an exception if not.
.Ve
.PP
.Vb 6
\&           If EXPAND is used, the parent''s start/end/strand will
\&           be adjusted so that it grows to accommodate the new
\&           subFeature
\& Example :
\& Returns : nothing
\& Args    : a Bio::SeqFeatureI object
.Ve
.Sh "\fIremove_SeqFeatures()\fP"
.IX Subsection "remove_SeqFeatures()"
.Vb 6
\& Usage   : $obj->remove_SeqFeatures
\& Function: Removes all sub SeqFeatures.  If you want to remove only a subset,
\&           remove that subset from the returned array, and add back the rest.
\& Returns : The array of Bio::SeqFeatureI implementing sub-features that was
\&           deleted from this feature.
\& Args    : none
.Ve
.SH "INTERFACE METHODS FOR Bio::AnnotatableI"
.IX Header "INTERFACE METHODS FOR Bio::AnnotatableI"
.Sh "\fIannotation()\fP"
.IX Subsection "annotation()"
.Vb 5
\& Usage   : $obj->annotation($annot_obj)
\& Function: Get/set the annotation collection object for annotating this
\&           feature.
\& Returns : A Bio::AnnotationCollectionI object
\& Args    : newvalue (optional)
.Ve
.Sh "\fIlocation()\fP"
.IX Subsection "location()"
.Vb 5
\& Usage   : my $location = $seqfeature->location()
\& Function: returns a location object suitable for identifying location 
\&           of feature on sequence or parent feature  
\& Returns : Bio::LocationI object
\& Args    : [optional] Bio::LocationI object to set the value to.
.Ve
.Sh "\fIadd_target()\fP"
.IX Subsection "add_target()"
.Vb 4
\& Usage   : $seqfeature->add_target(Bio::LocatableSeq->new(...));
\& Function: adds a target location on another reference sequence for this feature
\& Returns : true on success
\& Args    : a Bio::LocatableSeq object
.Ve
.Sh "\fIeach_target()\fP"
.IX Subsection "each_target()"
.Vb 5
\& Usage   : @targets = $seqfeature->each_target();
\& Function: Returns a list of Bio::LocatableSeqs which are the locations of this object.
\&           To obtain the "primary" location, see L</location()>.
\& Returns : a list of 0..N Bio::LocatableSeq objects
\& Args    : none
.Ve
.Sh "_expand_region"
.IX Subsection "_expand_region"
.Vb 4
\& Title   : _expand_region
\& Usage   : $self->_expand_region($feature);
\& Function: Expand the total region covered by this feature to
\&           accomodate for the given feature.
.Ve
.PP
.Vb 4
\&           May be called whenever any kind of subfeature is added to this
\&           feature. add_SeqFeature() already does this.
\& Returns : 
\& Args    : A Bio::SeqFeatureI implementing object.
.Ve
