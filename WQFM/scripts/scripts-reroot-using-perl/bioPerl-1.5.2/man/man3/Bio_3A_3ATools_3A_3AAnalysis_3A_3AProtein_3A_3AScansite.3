.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Tools::Analysis::Protein::Scansite 3"
.TH Bio::Tools::Analysis::Protein::Scansite 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Tools::Analysis::Protein::Scansite \- a wrapper around the Scansite server
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Bio::Tools::Analysis::Protein::Scansite;
.Ve
.PP
.Vb 1
\&  my $seq; # a Bio::PrimarySeqI object
.Ve
.PP
.Vb 2
\&  my $tool = Bio::Tools::Analysis::Protein::Scansite->new
\&     ( -seq => $seq->primary_seq );
.Ve
.PP
.Vb 2
\&  # run Scansite prediction on a sequence
\&  $tool->run();
.Ve
.PP
.Vb 2
\&  # alternatively you can say
\&  $tool->seq($seq->primary_seq)->run;
.Ve
.PP
.Vb 1
\&  die "Could not get a result" unless $tool->status =~ /^COMPLETED/;
.Ve
.PP
.Vb 1
\&  print $tool->result;     # print raw prediction to STDOUT
.Ve
.PP
.Vb 1
\&  foreach my $feat ( $tool->result('Bio::SeqFeatureI') ) {
.Ve
.PP
.Vb 5
\&      # do something to SeqFeature
\&      # e.g. print as GFF
\&      print $feat->gff_string, "\en";
\&      # or store within the sequence - if it is a Bio::RichSeqI
\&      $seq->add_SeqFeature($feat);
.Ve
.PP
.Vb 1
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is a wrapper around the Scansite 2.0 server which produces
predictions for serine, threonine and tyrosine phosphorylation sites
in eukaryotic proteins. At present this is a basic wrapper for the
\&\*(L"Scan protein by input sequence\*(R" functionality, which takes a sequence
and searches for motifs, with the option to select the search
stringency. At present, searches for specific phosphorylation
sites are not supported; all predicted sites are returned.
.Sh "Return formats"
.IX Subsection "Return formats"
The Scansite results can be obtained in several formats:
.IP "1." 3
By calling
.Sp
.Vb 1
\&  my $res = $tool->result('');
.Ve
.Sp
$res holds a string of the predicted sites in tabular format.
.IP "2." 3
By calling 
.Sp
.Vb 1
\&  my $data_ref = $tool->result('value')
.Ve
.Sp
$data_ref is a reference to an array of hashes. Each element in the
array represents a predicted phosphorylation site. The hash keys are
the names of the data fields,i.e.,
.Sp
.Vb 8
\&    'motif'      => 'Casn_Kin1'       # name of kinase
\&    'percentile' => 0.155             # see Scansite docs
\&    'position'   => 9                 # position in protein
\&    'protein'    => 'A1'              # protein id
\&    'score'      => 0.3696            # see Scansite docs
\&    'sequence'   => 'ASYFDTASYFSADAT' # sequence surrounding site
\&    'site'       => 'S9'              # phosphorylated residue
\&    'zscore'     => '-3.110'          # see Scansite docs
.Ve
.IP "3." 3
By calling
.Sp
.Vb 1
\&  my @fts = $tool->Result('Bio::SeqFeatureI');
.Ve
.Sp
which returns an array of Bio::SeqFeatureI compliant objects with
primary tag value 'Site' and tag names of 'motif', 'score',
\&'sequence', 'zscore' as above.
.PP
See <http://scansite.mit.edu/>.
.PP
This inherits Bio::SimpleAnalysisI which hopefully makes it easier to
write wrappers on various services. This class uses a web resource and
therefore inherits from Bio::WebAgent.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Bio::SimpleAnalysisI, 
Bio::WebAgent
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Richard Adams, Richard.Adams@ed.ac.uk, 
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.Sh "result"
.IX Subsection "result"
.Vb 6
\& Name    : result
\& Usage   : $job->result (...)
\& Returns : a result created by running an analysis
\& Args    : none (but an implementation may choose
\&           to add arguments for instructions how to process
\&           the raw result)
.Ve
.PP
The method returns a scalar representing a result of an executed
job. If the job was terminated by an error, the result may contain 
an error message instead of the real data.
.PP
This implementation returns differently processed data depending on
argument:
.IP "undef" 3
.IX Item "undef"
Returns the raw \s-1ASCII\s0 data stream but without \s-1HTML\s0 tags
.IP "'Bio::SeqFeatureI'" 3
.IX Item "'Bio::SeqFeatureI'"
The argument string defined the type of bioperl objects returned in an
array.  The objects are Bio::SeqFeature::Generic.
.IP "'parsed'" 3
.IX Item "'parsed'"
Returns a reference to an array of hashes containing the data of one
phosphorylation site prediction. Key values are:
.Sp
motif, percentile, position, protein, score, site, zscore,  sequence.
.Sh "stringency"
.IX Subsection "stringency"
.Vb 4
\& Usage    : $job->stringency(...)
\& Returns  : The significance stringency of a prediction
\& Args     : None (retrieves value) or 'High', 'Medium' or 'Low'.
\& Purpose  : Get/setter of the stringency to be sumitted for analysis.
.Ve
.Sh "protein_id"
.IX Subsection "protein_id"
.Vb 5
\& Usage    : $job->protein_id(...)
\& Returns  : The sequence id of the protein or 'unnamed' if not set. 
\& Args     : None  
\& Purpose  : Getter of the seq_id. Returns the display_id of the sequence
\&            object.
.Ve
