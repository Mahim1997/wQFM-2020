.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::Seq::MetaI 3"
.TH Bio::Seq::MetaI 3 "2008-07-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::Seq::MetaI \- Interface for sequence objects with residue\-based
meta information
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  # get a Bio::Seq::MetaI compliant object somehow
.Ve
.PP
.Vb 3
\&  # to test this is a meta seq object
\&  $obj->isa("Bio::Seq::MetaI")
\&     || $obj->throw("$obj not a Bio::Seq::MetaI");
.Ve
.PP
.Vb 5
\&  # accessors
\&  $string     = $obj->meta;
\&  $string     = $obj->meta_text;
\&  $substring  = $obj->submeta(12,50);
\&  $unique_key = $obj->accession_number();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class defines an abstract interface for basic residue-based meta
information. Examples of this kind of meta data are secondary
structures (\s-1RNA\s0 and protein), protein hydrophobicity assignments, or
other alternative alphabets for polypeptides, sequence quality data
and nucleotide alignments with translations.
.PP
The length of the meta data sequence is not dependent on the amount of
the meta information. The meta information always covers all the
residues, but a blank value is used to denote unavailable
information. If necessary the implementation quietly truncates or
extends meta information with blank values. Definition of blank is
implementation dependent. Gaps in MSAs should not have meta
information.
.PP
At this point a residue in a sequence object can have only one meta
value. If you need more, use multiple copies of the sequence object.
.PP
Meta data storage can be implemented in various ways, e.g: string,
array of scalars, array of hashes, array of objects.
.PP
If the implementation so chooses, there can be more then one meta
values associated to each residue. See named_meta and
names_submeta. Note that use of arbitrary names is very prone to
typos leading to creation of additional copies of meta data sets.
.PP
Bio::Seq::Meta provides basic, pure perl implementation of sequences
with meta information. See Bio::Seq::Meta. Application specific
implementations will override and add to these methods.
.Sh "Method naming"
.IX Subsection "Method naming"
Character based meta data is read and set by method \fImeta()\fR and its
variants. These are the suffixes and prefixes used in the variants:
.PP
.Vb 1
\&    [named_] [sub] meta [_text]
.Ve
.IP "_text" 3
.IX Item "_text"
Suffix \fB_text\fR guaranties that output is a string. Note that it does
not limit the input.
.IP "sub" 3
.IX Item "sub"
Prefix \fBsub\fR, like in \fIsubseq()\fR, means that the method applies to sub
region of the sequence range and takes start and end as arguments.
Unlike \fIsubseq()\fR, these methods are able to set values.  If the range
is not defined, it defaults to the complete sequence.
.IP "named_" 3
.IX Item "named_"
Prefix \fBnamed_\fR in method names allows the used to attach multiple
meta strings to one sequence by explicitly naming them. The name is
always the first argument to the method. The \*(L"unnamed\*(R" methods use the
class wide default name for the meta data and are thus special cases
\&\*(L"named\*(R" methods.
.Sp
Note that internally names are keys in a hash and any misspelling of a
name will silently store the data under a wrong name. The used names
(keys) can be retrieved using method \fImeta_names()\fR. See meta_names.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Bio::Seq::Meta, 
Bio::Seq::Meta::Array, 
Bio::Seq::EncodedSeq, 
Bio::Tools::OddCodes, 
Bio::Seq::Quality
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 2
\&  bioperl-l@bioperl.org                  - General discussion
\&  http://bioperl.org/wiki/Mailing_lists  - About the mailing lists
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:
.PP
.Vb 1
\&  http://bugzilla.open-bio.org/
.Ve
.SH "AUTHOR \- Heikki Lehvaslaiho"
.IX Header "AUTHOR - Heikki Lehvaslaiho"
Email heikki-at-bioperl-dot-org
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Chad Matsalla, bioinformatics@dieselwurks.com;
Aaron Mackey, amackey@virginia.edu;
Peter Schattner schattner@alum.mit.edu;
Richard Adams, Richard.Adams@ed.ac.uk
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _
.Sh "meta"
.IX Subsection "meta"
.Vb 3
\& Title   : meta
\& Usage   : $meta_values  = $obj->meta($values_string);
\& Function:
.Ve
.PP
.Vb 4
\&           Get and set method for the unnamed meta data starting from
\&           residue position one. Since it is dependent on the length
\&           of the sequence, it needs to be manipulated after the
\&           sequence.
.Ve
.PP
.Vb 3
\&           The implementation may choose to accept argument values in
\&           a string or in an array (reference) or in a hash
\&           (reference).
.Ve
.PP
.Vb 4
\&           The return value may be a string or an array reference,
\&           depending on the implentation. If in doubt, use meta_text()
\&           which is a variant guarantied to return a string.  See
\&           L<meta_text>.
.Ve
.PP
.Vb 2
\&           The length of the returned value always matches the length
\&           of the sequence.
.Ve
.PP
.Vb 2
\& Returns : A reference to an array or a string
\& Args    : new value, optional
.Ve
.Sh "meta_text"
.IX Subsection "meta_text"
.Vb 6
\& Title   : meta_text()
\& Usage   : $meta_values  = $obj->meta_text($values_arrayref);
\& Function: Variant of meta() guarantied to return a textual
\&           representation of the meta data. For details, see L<meta>.
\& Returns : a string
\& Args    : new value, optional
.Ve
.Sh "named_meta"
.IX Subsection "named_meta"
.Vb 7
\& Title   : named_meta()
\& Usage   : $meta_values  = $obj->named_meta($name, $values_arrayref);
\& Function: A more general version of meta(). Each meta data set needs
\&           to be named. See also L<meta_names>.
\& Returns : a string
\& Args    : scalar, name of the meta data set
\&           new value, optional
.Ve
.Sh "named_meta_text"
.IX Subsection "named_meta_text"
.Vb 8
\& Title   : named_meta_text()
\& Usage   : $meta_values  = $obj->named_meta_text($name, $values_arrayref);
\& Function: Variant of named_meta() guarantied to return a textual
\&           representation  of the named meta data.
\&           For details, see L<meta>.
\& Returns : a string
\& Args    : scalar, name of the meta data set
\&           new value, optional
.Ve
.Sh "submeta"
.IX Subsection "submeta"
.Vb 4
\& Title   : submeta
\& Usage   : $subset_of_meta_values = $obj->submeta(10, 20, $value_string);
\&           $subset_of_meta_values = $obj->submeta(10, undef, $value_string);
\& Function:
.Ve
.PP
.Vb 1
\&           Get and set method for meta data for subsequences.
.Ve
.PP
.Vb 3
\&           Numbering starts from 1 and the number is inclusive, ie 1-2
\&           are the first two residue of the sequence. Start cannot be
\&           larger than end but can be equal.
.Ve
.PP
.Vb 2
\&           If the second argument is missing the returned values
\&           should extend to the end of the sequence.
.Ve
.PP
.Vb 2
\&           If implementation tries to set values beyond the current
\&           sequence, they should be ignored.
.Ve
.PP
.Vb 4
\&           The return value may be a string or an array reference,
\&           depending on the implentation. If in doubt, use
\&           submeta_text() which is a variant guarantied to return a
\&           string.  See L<submeta_text>.
.Ve
.PP
.Vb 4
\& Returns : A reference to an array or a string
\& Args    : integer, start position, optional
\&           integer, end position, optional
\&           new value, optional
.Ve
.Sh "submeta_text"
.IX Subsection "submeta_text"
.Vb 8
\& Title   : submeta_text
\& Usage   : $meta_values  = $obj->submeta_text(20, $value_string);
\& Function: Variant of submeta() guarantied to return a textual
\&           representation  of meta data. For details, see L<meta>.
\& Returns : a string
\& Args    : integer, start position, optional
\&           integer, end position, optional
\&           new value, optional
.Ve
.Sh "named_submeta"
.IX Subsection "named_submeta"
.Vb 10
\& Title   : named_submeta
\& Usage   : $subset_of_meta_values = $obj->named_submeta($name, 10, 20, $value_string);
\&           $subset_of_meta_values = $obj->named_submeta($name, 10);
\& Function: Variant of submeta() guarantied to return a textual
\&           representation  of meta data. For details, see L<meta>.
\& Returns : A reference to an array or a string
\& Args    : scalar, name of the meta data set
\&           integer, start position
\&           integer, end position, optional when a third argument present
\&           new value, optional
.Ve
.Sh "named_submeta_text"
.IX Subsection "named_submeta_text"
.Vb 9
\& Title   : named_submeta_text
\& Usage   : $meta_values  = $obj->named_submeta_text($name, 20, $value_string);
\& Function: Variant of submeta() guarantied to return a textual
\&           representation  of meta data. For details, see L<meta>.
\& Returns : a string
\& Args    : scalar, name of the meta data
\& Args    : integer, start position, optional
\&           integer, end position, optional
\&           new value, optional
.Ve
.Sh "meta_names"
.IX Subsection "meta_names"
.Vb 6
\& Title   : meta_names
\& Usage   : @meta_names  = $obj->meta_names()
\& Function: Retrives an array of meta data set names. The default (unnamed)
\&           set name is guarantied to be the first name.
\& Returns : an array of names
\& Args    : none
.Ve
.Sh "force_flush"
.IX Subsection "force_flush"
.Vb 6
\& Title   : force_flush()
\& Usage   : $force_flush = $obj->force_flush(1);
\& Function: Automatically pad with empty values or truncate meta values to
\&            sequence length
\& Returns : boolean 1 or 0
\& Args    : optional boolean value
.Ve
.Sh "is_flush"
.IX Subsection "is_flush"
.Vb 9
\& Title   : is_flush
\& Usage   : $is_flush  = $obj->is_flush()
\&           or  $is_flush = $obj->is_flush($my_meta_name)
\& Function: Boolean to tell if all meta values are in
\&           flush with the sequence length.
\&           Returns true if force_flush() is set
\&           Set verbosity to a positive value to see failed meta sets
\& Returns : boolean 1 or 0
\& Args    : optional name of the meta set
.Ve
.Sh "meta_length"
.IX Subsection "meta_length"
.Vb 5
\& Title   : meta_length()
\& Usage   : $meeta_len  = $obj->meta_length();
\& Function: return the number of elements in the meta set
\& Returns : integer
\& Args    : -
.Ve
.Sh "named_meta_length"
.IX Subsection "named_meta_length"
.Vb 5
\& Title   : named_meta_length()
\& Usage   : $meeta_len  = $obj->named_meta_length($name);
\& Function: return the number of elements in the named meta set
\& Returns : integer
\& Args    : -
.Ve
.SH "Bio::PrimarySeqI methods"
.IX Header "Bio::PrimarySeqI methods"
Implemeting classes will need to rewrite these Bio::PrimaryI methods.
.Sh "revcom"
.IX Subsection "revcom"
.Vb 6
\& Title   : revcom
\& Usage   : $newseq = $seq->revcom();
\& Function: Produces a new Bio::Seq::MetaI implementing object where
\&           the order of residues and their meta information is reversed.
\& Returns : A new (fresh) Bio::Seq::MetaI object
\& Args    : none
.Ve
.Sh "trunc"
.IX Subsection "trunc"
.Vb 5
\& Title   : trunc
\& Usage   : $subseq = $myseq->trunc(10,100);
\& Function: Provides a truncation of a sequence
\& Returns : a fresh Bio::Seq::MetaI implementing object
\& Args    : Two integers denoting first and last residue of the sub-sequence.
.Ve
